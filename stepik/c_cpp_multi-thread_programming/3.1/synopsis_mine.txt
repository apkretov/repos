Step 2.

int s = socket(domain, type, protocol); //Create an endpoint for communication.

	domain: AF_INET  - IPv4 socket.
			AF_INET6 - IPv6 socket.
			AF_UNIX  - Unix socket.

	type:	SOCK_STREM - TCP.
			SOCK_DGRAM - UDP.

	protocol: IPPROTO_TCP - TCP.
			  IPPROTO_UDP - UDP.
			  0 - Default = IPPROTO_TCP/IPPROTO_UDP for SOCK_STREAM/SOCK_DGRAM respectively.


Step 3.

bind(s, (struct sockaddr *)sa, sizeof(sa)); //Bind a name to a socket

struct sockaddr_in sa; //An IPv4 AF_INET socket address.
					   //See also: 9.24. struct sockaddr and pals @ http://beej.us/guide/bgnet/output/html/multipage/sockaddr_inman.html.

sa.sin_family = AF_INET;
sa.sin_port = htnos(12345); //htonl, htons, ntohl, ntohs - Convert values between host and network byte order. 
							//See also: 9.12. htons(), htonl(), ntohs(), ntohl() @ http://beej.us/guide/bgnet/output/html/multipage/htonsman.html
sa.sin_addr.s_addr = htonl(INADDR_LOOPBACK); //IP address.
											 //INADDR_LOOPBACK = (127.0.0.1) - An internal address of the PC that a connection is arranged at.
											 //INADDR_ANY = (0.0.0.0) - An access to all available server addresses.

ip = inet_addr("10.0.0.1"); //Convert the Internet host address cp from IPv4 numbers-and-dots notation into binary data in network byte order.
inet_pton(AF_INET, "10.0.0.1", &(sa.sin_addr)); //Convert IPv4 and IPv6 addresses from text to binary form.

struct sockaddr_in6 sa; //An IPv6 AF_INET socket address.
						//See also: 9.24. struct sockaddr and pals @ http://beej.us/guide/bgnet/output/html/multipage/sockaddr_inman.html.
struct sockaddr_un sa; //A UNIX domain socket address (see also Linux Programmer's Manual @ http://man7.org/linux/man-pages/man7/unix.7.html)
sa.sun_family = AF_UNIX;
strcpy(sa.sun_path, "/tmp/a.sock"); //The path name to the file.


Step 4.

listen(s, SOMAXCONN); //int listen(int sockfd, int backlog); - Listen for connections on a socket.
					  //backlog defines the maximum length to which the queue of pending connections for sockfd may grow.
while(s1 = accept(s, 0, 0)) { //int accept(int s, struct sockaddr *addr, socklen_t *addrlen); Accepts an incoming connection on a listening socket.
							  //addr - is filled in with the address of the site that's connecting to you. 0 ignores it.
							  //addrlen - is filled in with the sizeof() the structure returned in the addr parameter.
							  //Returns the newly connected socket descriptor, or -1 on error, with errno set appropriately.
							  //(Source: 9.1. accept() @ http://beej.us/guide/bgnet/output/html/multipage/acceptman.html)
	
}


Step 5.

size_t read(int fd, void* buf, size_t count); 		 //Read from a socket.
size_t write(int fd, const void* buf, size_t count); //Write to a socket.
SIGPIPE												 //If a connection gets lost the OS return this signal and the application termninates.
signal(SIGPIPE, SIG_IGN); 							 //Ignores SIGPIPE not to terminate the application. A poor solution...

size_t recv(int fd, void* buf, size_t count, int flags); 	   //Receive a message from a socket.
size_t send(int fd, const void* buf, size_t count, int flags); //Send a message to a socket.
flags: MSG_NOSIGNAL											   //A flag to solve the problem with SIGPIPE.


Step 6.

TCP
	Server			Client
	----------		----------
1	socket()		socket()
2	bind()
3	listen()		
4	accept()  <---	connect()
5			Hand-shaking
6	send/recv <-->	send/recv
7.1			  <-OR	shutdown
7.1	shutdown  OR->
8	close	   		close


Step 7.

shutdown(s, SHUT_RDWR); //Close a read-write socket.
			SHUT_RD		//Close only a read socket.
			SHUT_WR		//Close only a write socket 
close(s);				//Close the file descriptor.


Step 8.

UDP
	Server			Client
	----------		----------
1	socket()		socket()
2	bind()
3	recvfrom()		sendto()	//Unlike TCP recv()/send().

size_t recvfromi(int fd, void* buf, size_t count, int flags, const struct sockaddr* from, socket_t fromlen); //Receive a message from a socket.
size_t sendto(int s, const void* buf, size_t len, int flags, const struct sockaddr* to, socklen_t tolen); 	 //Send a message to a socket.
576 byts are atomically sent/received.


Step 10.

//Enable use of an address that was used by an application terminated previously.
int optval = 1;
setsockopt(s, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval));

//Set a receive/send time-out interval.
struct timeval tv;
tv.tv_sec = 16; //16 seconds.
tv.tv_usec = 0; //0 milliseconds.
setsockopt(s, SOL_SOCKET, SO_RCVTIMEO, (char*) &tv, sizeof(tv)); //Set a receive time-out.
						  SO_SNDTIMEO							 //Set a send time-out.
