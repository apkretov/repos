<html><head><meta http-equiv='Content-Type' content='text/html; charset=utf8'>
<style>
BODY {text-align : justify }
p.book {text-indent:20px;  margin-bottom: 0pt; margin-top: 0pt;}
H1.book{ /* Book title */ font-size : 160%; font-style : normal; font-weight : bold; text-align : left; }
H2.book{ /* Avtor */ font-size : 100%; font-style : normal; font-weight : bold; text-align : left; padding-left : 1em; }
H3.book{ /* Title */  font-size : 110%; font-style : normal; font-weight : bold; text-align : center; padding-top : 11px;padding-bottom : 6px;}
H4.book{ /* Subtitle */ font-size : 100%; font-style : italic; font-weight : bold; text-align : left; }
.epigraph{margin-right:5em; margin-left : 25%;}
BLOCKQUOTE.book{ margin : 0 1em 0.2em 4em }
H5.book{ font-size : 100%; font-style : italic; font-weight : bold; padding-left : 2.5em;text-align : left; padding-top : 9px;}
DIV.book{text-align : justify}
DIV.poem{margin: 0.6em 0 0.6em 50px}
DIV.stanza{margin: 0.6em 0} 
</style><title>Programming with POSIX® Threads - Флибуста</title>
</head>
<body>

<h3 class=book>
Programming with POSIX® Threads
</h3>

<a name=t1></a><h3 class=book>
Addison-Wesley Professional Computing Series
</h3>
<p class=book>Brian W. Kernighan, Consulting Editor</p>
<p class=book>Ken Arnold/John Peyton, <i>A C User's Guide to ANSI C</i> David R. Butenhof, <i>Programming with POSIX® Threads</i> Tom Cargill, C++ <i>Programming Style</i></p>
<p class=book>William R. Cheswick/Steven M. Bellovin, <i>Firewalls and Internet Security: Repelling the Wily Hacker</i> David A. Curry, <i>UNIX® System Security: A Guide for Users and System Administrators</i> Erich Gamma/Richard Helm/Ralph Johnson/John Vlissides, <i>Design Patterns: Elements of</i></p>
<p class=book><i>Reusable Object-Oriented Software</i> Erich Gamma/Richard Helm/RalphJohnson/John Vlissides, <i>Design Patterns CD: Elements of</i></p>
<p class=book><i>Reusable Object-Oriented Software</i> David R. Hanson, C <i>Interfaces and Implementations: Techniques for Creating Reusable Software</i> S. Keshav, <i>An Engineering Approach to Computer Networking: ATM Networks, The Internet, and</i></p>
<p class=book><i>the Telephone Network</i> John Lakos, <i>Large-Scale</i> C++ <i>Software Design</i></p>
<p class=book>Scott Meyers, <i>Effective</i> C++, <i>Second Edition: 50 Specific Ways to Improve Your Programs and Designs</i> Scott Meyers, <i>More Effective C++: 35 New Ways to Improve Your Programs and Designs</i> Robert B. Murray, C++ <i>Strategies and Tactics</i></p>
<p class=book>David R. Musser/Atul Saini, <i>STL Tutorial and Reference Guide: C++ Programming with the</i></p>
<p class=book><i>Standard Template Library</i> John K. Ousterhout, <i>Tcl and the Tk Toolkit</i> Craig Partridge, <i>Gigabit Networking</i></p>
<p class=book>J. Stephen Pendergrast Jr., <i>Desktop KornShell Graphical Programming</i> Radia Perlman, <i>Interconnections: Bridges and Routers</i></p>
<p class=book>David M. Piscitello/A. Lyman Chapin, <i>Open Systems Networking: TCP/IP and OSI</i> Stephen A. Rago, <i>UNIX® System V Network Programming</i></p>
<p class=book>Curt Schimmel, <i>UNIX® Systemsfor Modern Architectures: Symmetric Multiprocessing and</i></p>
<p class=book><i>Cachingfor Kernel Programmers</i> W. Richard Stevens, <i>Advanced Programming in the UNIX® Environment</i> W. Richard Stevens, <i>TCP/IP Illustrated, Volume 1: The Protocols</i></p>
<p class=book>W. Richard Stevens, <i>TCP/IP Illustrated, Volume 3: TCP for Transactions, HTTP,</i> NNTP and the</p>
<p class=book><i>UNIX® Domain Protocols</i> Gary R. Wright/W. Richard Stevens, <i>TCP/IP Illustrated, Volume 2: The Implementation</i></p>
<br>
<p class=book></p>
<br>
<p class=book><b>An Imprint of Addison Wesley Longman, Inc.</b></p>
<p class=book>Reading, Massachusetts • Harlow, England • Menlo Park, California Berkeley, California • Don Mills, Ontario • Sydney Bonn • Amsterdam • Tokyo • Mexico City</p>
<p class=book><img border=0 style='spacing 9px;' src="img_1.png"></p>
<p class=book><b>Trademark acknowledgments:</b></p>
<p class=book>UNIX is a registered trademark in the United States and other countries, licensed exclusively through X/Open Company Ltd. Digital, DEC, Digital UNIX, DECthreads, VMS, and OpenVMS are trademarks of Digital Equipment Corporation. Solaris, SPARC, SunOS, and Sun are trademarks of Sun Microsystems Incorporated. SGI and IRIX are trademarks of Silicon Graphics, Incorporated. HP-UX is a trademark of Hewlett-Packard Company. ALX, lBM, and OS/2 are trademarks or registered trademarks of the IBM Corporation. X/Open is a trademark of X/Open Company Ltd. POSIX is a registered trademark of the Institute of Electrical and Electronics Engineers, Inc.</p>
<p class=book>Many of the designations used by manufacturers and sellers to distinguish their products are claimed as trademarks. Where those designations appear in this book and Addison-Wesley was aware of a trademark claim, the designations have been printed in initial caps or all caps.</p>
<p class=book>The authors and publishers have taken care in the preparation of this book, but make no expressed or implied warranty of any kind and assume no responsibility for errors or omissions. No liability is assumed for incidental or consequential damages in connection with or arising out of the use of the information or programs contained herein.</p>
<p class=book>The publisher offers discounts on this book when ordered in quantity for special sales.</p>
<p class=book>For more information, please contact:</p>
<p class=book>Corporate & Professional Publishing Group Addison-Wesley Publishing Company One Jacob Way</p>
<p class=book>Reading, Massachusetts 01867</p>
<p class=book><b>Library of Congress Cataloging-in-Publication Data</b></p>
<p class=book>Butenhof, David R., 1956-</p>
<p class=book>Programming with POSIX threads / David R. Butenhof.</p>
<p class=book>p. cm. — (Addison-Wesley professional computing series) Includes bibliographical references and index. ISBN 0-201-63392-2 (pbk.)</p>
<p class=book>l.Threads(Computerprograms) 2. POSIX(Computersoftware standard) 3. Electronic digital computers—Programming. I. Title. II. Series.</p>
<p class=book>QA76.76.T55B88 1997</p>
<p class=book>005.4'32-dc21 97-6635</p>
<p class=book>CIP</p>
<p class=book>Copyright © 1997 by Addison Wesley Longman, Inc.</p>
<p class=book>All rights reserved. No part ofthis publication may be reproduced, stored in a retrieval system, or transmitted, in any form, or by any means, electronic, mechanical, photocopying, recording, or otherwise, without the prior consent of the publisher. Printed in the United States of America. Published simultaneously in Canada.</p>
<p class=book>Text printed on recycled and acid-free paper.</p>
<p class=book>2 3 4 5 6 7 8 9 MA 00 99 98 97</p>
<p class=book>2nd Printing October, 1997</p>
<blockquote class="epigraph">
<p class=book>To Anne, Amy, and Alyssa.</p>
</blockquote>


<a name=t2></a><h3 class=book>
Quote acknowledgments:
</h3>
<p class=book><i>American Heritage Dictionary of the English Language:</i> page 1. <i>ISO/IEC 9945-1:1996,</i> © 1996 by IEEE: page 29.</p>
<p class=book>Lewis Carroll, <i>Alice's Adventures in Wonderland:</i> pages xv, 47, 70, 88, 97, 98, 106, 131, 142, 161, 189, 197.Reproduced by permission of Macmillan Children's Books.</p>
<p class=book>Lewis Carroll, <i>Through the Looking-Glass:</i> pages 1, 4, 8, 20, 25, 29, 35, 45, 172, 214, 241, 283, 290, 302. Reproduced by permission of Macmillan Children's Books.</p>
<p class=book>Lewis Carroll, <i>The Hunting ofthe Snark:</i> pages 3, 13, 28, 39, 120, 131, 134, 289, 367. Reproduced by permission of Macmillan Children's Books.</p>


<a name=t3></a><h3 class=book>
Preface
</h3>
<blockquote class="epigraph">
<p class=book>The White Rabbit put on his spectacles, "Where shall I begin, please your Majesty?" he asked. "Begin at the beginning," the King said, very gravely, "and go on till you come to the end: then stop."</p>
<blockquote class=book><i>—<i>Lewis Carroll,Alice's Adventures in Wonderland</i></i></blockquote>
</blockquote>

<p class=book>This book is about "threads" and how to use them. "Thread" is just a name for a basic software "thing" that can do work on a computer. A thread is smaller, faster, and more maneuverable than a traditional process. In fact, once threads have been added to an operating system, a "process" becomes just data—address space, files, and so forth—plus one or more threads that do something with all that data.</p>
<p class=book>With threads, you can build applications that utilize system resources more efficiently, that are more friendly to users, that run blazingly fast on multiprocessors, and that may even be easier to maintain. To accomplish all this, you need only add some relatively simple function calls to your code, adjust to a new way of thinking about programming, and leap over a few yawning chasms. Reading this book carefully will, I hope, help you to accomplish all that without losing your sense of humor.</p>
<p class=book>The threads model used in this book is commonly called "Pthreads," or "POSIX threads." Or, more formally (since you haven't yet been properly introduced), the POSIX 1003.lc-1995 standard. I'll give you a few other names later— but for now, "Pthreads" is all you need to worry about.</p>
<p class=book>As I write this, Sun's Solaris, Digital's Digital UNIX, and SGI's IRIX already support Pthreads. The other major commercial UNIX operating systems will soon have Pthreads as well, maybe even by the time you read this, including IBM's AIX and Hewlett-Packard's HP-UX. Pthreads implementations are also available for Linux and other UNIX operating systems.</p>
<p class=book>In the personal computer market, Microsoft's Win32 API (the primary programming interface to both Windows NT and Windows 95) supports threaded programming, as does IBM's OS/2. These threaded programming models are quite different from Pthreads, but the important first step toward using them productively is understanding concurrency, synchronization, and scheduling. The rest is (more or less) a matter of syntax and style, and an experienced thread programmer can adapt to any of these models.</p>
<p class=book>The threaded model can be (and has been) applied with great success to a wide range of programming problems. Here are just a few:</p>
<p class=book>• Large scale, computationally intensive programs</p>
<p class=book>• High-performance application programs and library code that can take advantage of multiprocessor systems</p>
<p class=book>• Library code that can be used by threaded application programs</p>
<p class=book>• Realtime application programs and library code</p>
<p class=book>• Application programs and library code that perform I/O to slow external devices (such as networks and human beings).</p>


<a name=t4></a><h3 class=book>
Intended audience
</h3>
<p class=book>This book assumes that you are an experienced programmer, familiar with developing code for an operating system in "the UNIX family" using the ANSI C language. I have tried not to assume that you have any experience with threads or other forms of asynchronous programming. The <i>Introduction</i> chapter provides a general overview of the terms and concepts you'll need for the rest of the book. If you don't want to read the Introduction first, that's fine, but if you ever feel like you're "missing something" you might try skipping back to get introduced.</p>
<p class=book>Along the way you'll find examples and simple analogies for everything. In the end I hope that you'll be able to continue comfortably threading along on your own. Have fun, and "happy threading."</p>


<a name=t5></a><h3 class=book>
About the author
</h3>
<p class=book>I have been involved in the Pthreads standard since it began, although I stayed at home for the first few meetings. I was finally forced to spend a grueling week in the avalanche-proof concrete bunker at the base of Snowbird ski resort in Utah, watching hard-working standards representatives from around the world wax their skis. This was very distracting, because I had expected a standards meeting to be a formal and stuffy environment. As a result of this misunderstanding, I was forced to rent ski equipment instead of using my own.</p>
<p class=book>After the Pthreads standard went into balloting, I worked on additional thread synchronization interfaces and multiprocessor issues with several POSIX working groups. I also helped to define the Aspen threads extensions, which were fast-tracked into X/Open XSH5.</p>
<p class=book>I have worked at Digital Equipment Corporation for (mumble, mumble) years, in various locations throughout Massachusetts and New Hampshire. I was one of the creators of Digital's own threading architecture, and I designed (and implemented much of) the Pthreads interfaces on Digital UNIX 4.0. I have been helping people develop and debug threaded code for more than eight years.</p>
<p class=book>My unofficial motto is "Better Living Through Concurrency." Threads are not sliced bread, but then, we're programmers, not bakers, so we do what we can.</p>


<a name=t6></a><h3 class=book>
Acknowledgments
</h3>
<p class=book>This is the part where I write the stuff that I'd like to see printed, and that my friends and coworkers want to see. You probably don't care, and I promise not to be annoyed if you skip over it—but if you're curious, by all means read on.</p>
<p class=book>No project such as this book can truly be accomplished by a single person, despite the fact that only one name appears on the cover. I could have written a book about threads without any help—I know a great deal about threads, and I am at least reasonably competent at written communication. However, the result would not have been <i>this</i> book, and <i>this</i> book is better than that hypothetical work could possibly have been.</p>
<p class=book>Thanks first and foremost to my manager Jean Fullerton, who gave me the time and encouragement to write this book on the job—and thanks to the rest of the DECthreads team who kept things going while I wrote, including Brian Keane, Webb Scales, Jacqueline Berg, Richard Love, Peter Portante, Brian Silver, Mark Simons, and Steve Johnson.</p>
<p class=book>Thanks to Garret Swart who, while he was with Digital at the Systems Research Center, got us involved with POSIX. Thanks to Nawaf Bitar who worked with Garret to create, literally overnight, the first draft of what became Pthreads, and who became <i>POSIX thread evangelist</i> through the difficult period of getting everyone to understand just what the heck this threading thing was all about anyway. Without Garret, and especially Nawaf, Pthreads might not exist, and certainly wouldn't be as good as it is. (The lack of perfection is not their responsibility—that's the way life is.)</p>
<p class=book>Thanks to everyone who contributed to the design of cma, Pthreads, UNLX98, and to the users of DCE threads and DECthreads, for all the help, thought-provoking discourse, and assorted skin-thickening exercises, including Andrew Birrell, Paul Borman, Bob Conti, Bill Cox, Jeff Denham, Peter Gilbert, Rick Greer, Mike Grier, Kevin Harris, Ken Hobday, Mike Jones, Steve Kleiman, Bob Knighten, Leslie Lamport, Doug Locke, Paula Long, Finnbarr P. Murphy, Bill Noyce, Simon Patience, Harold Seigel, Al Simons, Jim Woodward, and John Zolnowsky.</p>
<p class=book>Many thanks to all those who patiently reviewed the drafts of this book (and even to those who didn't seem so patient at times). Brian Kernighan, Rich Stevens, Dave Brownell, Bill Gallmeister, Ilan Ginzburg, Will Morse, Bryan O'Sullivan, Bob Robillard, Dave Ruddock, Bil Lewis, and many others suggested or motivated improvements in structure and detail—and provided additional skin-thickening exercises to keep me in shape. Devang Shah and Bart Smaalders answered some Solaris questions, and Bryan O'Sullivan suggested what became the "bailing programmers" analogy.</p>
<p class=book>Thanks to John Wait and Lana Langlois at Addison Wesley Longman, who waited with great patience as a first-time writer struggled to balance writing a book with engineering and consulting commitments. Thanks to Pamela Yee and Erin Sweeney, who managed the book's production process, and to all the team (many of whose names I'll never know), who helped.</p>
<p class=book>Thanks to my wife, Anne Lederhos, and our daughters Amy and Alyssa, for all the things for which any writers may thank their families, including support, tolerance, and just being there. And thanks to Charles Dodgson (Lewis Carroll), who wrote extensively about threaded programming (and nearly everything else) in his classic works <i>Alice's Adventures in Wonderland, Through the Looking-Glass,</i> and <i>The Hunting of the Snark,</i></p>
<p class=book>Dave Butenhof</p>
<p class=book>Digital Equipment Corporation 110 Spit Brook Road, ZK02-3/Q18 Nashua, NH 03062 butenhof@zko.<a  l:href = "http://dec.com/">dec.com</A> December 1996</p>



<a name=t7></a><h3 class=book>
1 Introduction
</h3>
<blockquote class="epigraph">
<p class=book>"The time has come," the Walrus said,</p>
<p class=book>"To talk of many things;</p>
<p class=book>Of shoes—and ships—and sealing wax—</p>
<p class=book><i>Of</i> c<i>abbages—and kings—</i></p>
<p class=book>And why the sea is boiling hot—</p>
<p class=book>And whether pigs have wings."</p>
<blockquote class=book><i>— <i>Lewis Carroll, Through the Looking-Glass</i></i></blockquote>
</blockquote>

<p class=book>In a dictionary, you would probably see that one of several definitions for "thread" is along the lines of the third definition in the American Heritage paperback dictionary on my desk: "Anything suggestive of the continuousness and sequence of thread." In computer terms, a thread is the set of properties that suggest "continuousness and sequence" within the machine. A thread comprises the machine state necessary to execute a sequence of machine instructions—the location of the current instruction, the machine's address and data registers, and so forth.</p>
<p class=book>A UNIX process can be thought of as a thread, plus an address space, file descriptors, and an assortment of other data. Some versions of UNIX support "lightweight" or "variable weight" processes that allow you to strip some or all of that data from some of your processes for efficiency. Now, whether you're using a "thread" or a "lightweight process," you still need the address space, file descriptors, and everything else. So, you might ask, what's the point? The point is that you can have many threads sharing an address space, doing different things. On a multiprocessor, the threads in a process can be doing different things simultaneously.</p>
<p class=book>When computers lived in glass caves and were fed carefully prepared punch cards, the real world outside could be kept waiting with no consequences more severe than some grumbling programmers. But the real world doesn't do one thing at a time, and gradually computers began to model that world by adding capabilities such as multiprogramming, time sharing, multiprocessing, and, eventually, threads.</p>
<p class=book>Threads can help you bring your application out of the cave, and Pthreads helps you do it in a way that will be neat, efficient, and portable. This chapter briefly introduces you to what you need to begin understanding and using threads. Don't worry—the rest of the book will follow up on the details left dangling in this chapter.</p>
<p class=book>Section 1.1 presents the framework for a number of analogies that I will use to explain threading as we go. There is nothing all that unusual in the brief story—</p>
<p class=book>but hereafter you will understand when I talk about programmers and buckets, which, otherwise, might seem mildly odd.</p>
<p class=book>Section 1.2 defines some essential concepts and terms used in this book. The most important of these concepts deserves a special introduction, which will also serve to demonstrate the convention with which various particularly important points shall be emphasized throughout this book:</p>
<p class=book><b>Asynchronous:</b></p>
<p class=book>Any two operations are "asynchronous" when they can proceed independently of each other.</p>
<p class=book>Section 1.3 describes how you already use asynchronous programming on a regular basis, both as a UNIX programmer and user, and as a human being in the real world. I wouldn't dare to claim that asynchronous programming is easy, but the basic concepts it tries to model are so easy and natural that you rarely need even to think about them until you try to apply them to software.</p>
<p class=book>Threads are, to some extent, just one more way to make applications asynchronous, but threads have some advantages over other models that have been used to build asynchronous applications. Section 1.5 will show you some of the advantages as we apply various programming methods in several versions of a simple alarm clock. You will get to see "threads in action" right away, with a brief description of the few Pthreads interfaces needed to build this simple application.</p>
<p class=book>Armed, now, with a basic understanding of what threads are all about, you can go on to Section 1.6, where we will explore some of the fundamental advantages of a threaded programming model.</p>
<p class=book>Although there are a lot of excellent reasons to use threads, there is a price to be paid. Section 1.7 provides a counterpoint to the previous section by describing some of the costs. What it boils down to, though, is simply that you need to learn how the model works, and then apply it carefully. It is not as hard as some folks would have you believe.</p>
<p class=book>You have seen some of the fundamental benefits and costs. It may be obvious that you do not want to rush out and put threads into every application or library you write. Section 1.8 asks the question "To thread, or not to thread?" and I will attempt to guide you toward determining the proper answer in various cases.</p>
<p class=book>You will know at that point what threads are, what they do, and when to use them. Aside from brief examples, you haven't yet seen any detailed information about the particular programming interfaces (APIs) that compose Pthreads. Section 1.9 points out some of the basic landmarks of the Pthreads universe to get you oriented before we plunge ahead. The most important part of this section is 1.9.3, which describes the Pthreads model for reporting errors—which is somewhat different than the rest of UNIX and POSIX.</p>


<a name=t8></a><h3 class=book>
1.1 The "bailing programmers"
</h3>
<blockquote class="epigraph">
<p class=book>This was charming, no doubt: but they shortly found out</p>
<p class=book>That the Captain they trusted so well</p>
<p class=book>Had only one notion for crossing the ocean,</p>
<p class=book>And that was to tingle his bell.</p>
<blockquote class=book><i>— <i>Lewis Carroll, The Hunting of the Snark</i></i></blockquote>
</blockquote>
<p class=book>Three programmers sail out to sea one fine day in a small boat, They sail quite some distance from shore, enjoying the sun and sea breeze, allowing the wind to carry them. The sky darkens, and a storm strikes. The small boat is tossed violently about, and when the storm abates the programmers are missing their boat's sail and most of the mast. The boat has sprung a small leak,and there is no land in sight.</p>
<p class=book>The boat is equipped with food, water, oars, and a bailing bucket, and the programmers set to work. One programmer rows, and monitors the accumulating water in the bottom of the boat. The other programmers alternately sleep, watch the water level,or scan the horizon for sight of land or another ship.</p>
<p class=book>An idle programmer may notice rising water in the boat, and begin bailing. When both idle programmers are awake, and become simultaneously concerned regarding their increasing dampness, they may both lunge for the bailing bucket—but one will inevitably reach it first, and the other will have to wait.</p>
<p class=book>If the rower decides that bailing is required while both his companions sleep,a nudge is usually sufficient to awaken a programmer,allowing the other to continue sleeping. But if the rower is in a bad mood, he may resort to a loud yell,awakening both sleeping programmers. While one programmer assumes the necessary duty, the other can try to fall asleep again.</p>
<p class=book>When the rower tires, he can signal one of the other programmers to take over the task, and immediately fall into a deep sleep waiting to be signaled in turn. In this way, they journey on for some time.</p>
<p class=book>So, just what do the Bailing Programmers have to do with threads? I'm glad you asked! The elements of the story represent analogies that apply to the Pthreads programming model. We'll explore some additional analogies in later sections, and even expand the story a little, but for now consider a few basics:</p>
<p class=book>A <b>programmer</b> is an entity that is capable of independent activity. Our programmers represent <i>threads. A</i> thread is not really much like a programmer, who, as we all know, is a fascinatingly sophisticated mixture of engineer, mathematician, and artist that no computer can match. Still, as a representation of the "active element" in our programming model, it will be sufficient.</p>
<p class=book>The <b>bailing bucket</b> and the <b>oars</b> are "tokens" that can be held by only one individual at a time. They can be thought of as shared data, or as synchronization objects. The primary Pthreads synchronization object, by the way, is called a <i>mutex.</i></p>
<p class=book><b>Nudges</b> and <b>shouts</b> are communication mechanisms associated with a synchronization object, on which individuals wait for some condition. Pthreads provides <i>condition variables,</i> which may be signaled or broadcast to indicate changes in shared data state.</p>


<a name=t9></a><h3 class=book>
1.2 Definitions and terminology
</h3>
<blockquote class="epigraph">
<p class=book>"When I use a word," Humpty Dumpty said, in rather a scornful tone, "it means just what I choose it to mean—neither more nor less."</p>
<blockquote class=book><i>— <i>Lewis Carroll, Through the Looking-Glass</i></i></blockquote>
</blockquote>

<p class=book>This book will use several critical terms that may be unfamiliar to you unless you've already had some experience with parallel or asynchronous programming. Even if you are familiar with them, some of the terms have seen assorted and even contradictory uses within research and industry, and that is clearly not going to help communication. We need to begin by coming to a mutual agreement regarding the meaning of these terms, and, since I am writing the book, we will agree to use my definitions. (Thank you.)</p>


<a name=t10></a><h3 class=book>
1.2.1 Asynchronous
</h3>
<p class=book><i>Asynchronous</i> means that things happen independently (concurrently) unless there's some enforced dependency. Life is asynchronous. The dependencies are supplied by nature, and events that are not dependent on one another can occur simultaneously. A programmer cannot row without the oars, or bail effectively without the bucket—but a programmer with oars can row while another programmer with a bucket bails. Traditional computer programming, on the other hand, causes all events to occur in series unless the programmer takes "extraordinary measures" to allow them to happen concurrently.</p>
<p class=book>The greatest complication of "asynchrony" has been that there's little advantage to being asynchronous unless you can have more than one activity going at a time. If you can start an asynchronous operation, but then you can do nothing but wait for it, you're not getting much benefit from the asynchrony.</p>


<a name=t11></a><h3 class=book>
1.2.2 Concurrency
</h3>
<p class=book><i>Concurrency,</i> which an English dictionary will tell you refers to things happening at the same time, is used to refer to things that appear to happen at the same time, but which may occur serially. Concurrency describes the behavior of threads or processes on a uniprocessor system. The definition of concurrent execution in POSIX requires that "functions that suspend the execution of the calling thread shall not cause the execution of other threads to be indefinitely suspended."</p>
<p class=book>Concurrent operations may be arbitrarily interleaved so that they make progress independently (one need not be completed before another begins), but concurrency does not imply that the operations proceed simultaneously. Nevertheless, concurrency allows applications to take advantage of asynchronous capabilities, and "do work" while independent operations are proceeding.</p>
<p class=book>Most programs have asynchronous aspects that may not be immediately obvious. Users, for example, prefer asynchronous interfaces. They expect to be able to issue a command while they're thinking about it, even before the program has finished with the last one. And when a windowing interface provides separate windows, don't you intuitively <i>expect</i> those windows to act asynchronously? Nobody likes a "busy" cursor. Pthreads provides you with both concurrency and asynchrony, and the combination is exactly what you need to easily write responsive and efficient programs. Your program can "wait in parallel" for slow I/O devices, and automatically take advantage of multiprocessor systems to compute in parallel.</p>


<a name=t12></a><h3 class=book>
1.2.3 Uniprocessor and multiprocessor
</h3>
<p class=book>The terms <i>uniprocessor</i> and <i>multiprocessor</i> are fairly straightforward, but let's define them just to make sure there's no confusion. By <i>uniprocessor,</i> I mean a computer with a single programmer-visible execution unit (processor). A single general-purpose processor with superscalar processing, or vector processors, or other math or I/O coprocessors is still usually considered a uniprocessor.</p>
<p class=book>By <i>multiprocessor,</i> I mean a computer with more than one processor sharing a common instruction set and access to the same physical memory. While the processors need not have equal access to all physical memory, it should be possible for any processor to gain access to most memory. A "massively parallel processor" (MPP) may or may not qualify as a multiprocessor for the purposes of this book. Many MPP systems do qualify, because they provide access to all physical memory from every processor, even though the access times may vary widely.</p>


<a name=t13></a><h3 class=book>
1.2.4 Parallelism
</h3>
<p class=book><i>Parallelism</i> describes concurrent sequences that proceed simultaneously. In other words, software "parallelism" is the same as English "concurrency" and different from software "concurrency." Parallelism has a vaguely redeeming analogy to the English definition: It refers to things proceeding in the same direction independently (without intersection).</p>
<p class=book>True parallelism can occur only on a multiprocessor system, but concurrency can occur on both uniprocessor and multiprocessor systems. Concurrency can</p>
<p class=book>occur on a uniprocessor because concurrency is, essentially, the illusion of parallelism. While parallelism requires that a program be able to perform two computations at once, concurrency requires only that the programmer be able to pretend that two things can happen at once.</p>


<a name=t14></a><h3 class=book>
1.2.5 Thread safety and reentrancy
</h3>
<p class=book>"Thread-safe" means that the code can be called from multiple threads without destructive results. It does not require that the code run <i>efficiently</i> in multiple threads, only that it can operate <i>safely</i> in multiple threads. Most existing functions can be made thread-safe using tools provided by Pthreads— mutexes, condition variables, and thread-specific data. Functions that don't require persistent context can be made thread-safe by serializing the entire function, for example, by locking a mutex on entry to the function, and unlocking the mutex before returning. Functions made thread-safe by serializing the entire function can be called in multiple threads—but only one thread can truly perform the function at a time.</p>
<p class=book>More usefully, thread-safe functions can be broken down into smaller critical sections. That allows more than one thread to execute within the function, although not within the same part. Even better, the code can be redesigned to protect critical data rather than critical code, which may allow fully parallel execution of the code, when the threads don't need to use the same data at the same time.</p>
<p class=book>The putchar function, for example, which writes a character into a standard I/O (<i>stdio)</i> buffer, might be made thread-safe by turning putchar into a critical section. That is, putchar might lock a "putchar mutex," write the character, and then unlock the putchar mutex. You could call putchar from two threads, and no data would be corrupted—it would be thread-safe. However, only one thread could write its character at a time, and the others would wait, even if they were writing to different <i>stdio</i> streams.</p>
<p class=book>The correct solution is to associate the mutex with the stream, protecting the data rather than the code. Now your threads, as long as they are writing to different streams, can execute putchar in parallel. More importantly, all functions that access a stream can use the same mutex to safely coordinate their access to that stream.</p>
<p class=book>The term "reentrant" is sometimes used to mean "efficiently thread-safe." That is, the code was made thread-safe by some more sophisticated measures than converting the function or library into a single serial region. Although existing code can usually be made thread-safe by adding mutexes and thread-specific data, it is often necessary to change the interface to make a function reentrant. Reentrant code should avoid relying on static data and, ideally, should avoid reliance on any form of synchronization between threads.</p>
<p class=book>Often, a function can avoid internal synchronization by saving state in a "context structure" that is controlled by the caller. The caller is then responsible for any necessary synchronization of the data. The UNIX readdir function, for example, returns each directory entry in sequence. To make readdir thread-safe, you might add a mutex that readdir locked each time it was called, and unlocked before it returned to the caller. Another approach, as Pthreads has taken with readdir_r, is to avoid any locking within the function, letting the caller allocate a structure that maintains the context of readdir_r as it searches a directory.</p>
<p class=book>At first glance, it may seem that we're just making the caller perform what ought to be the job of readdir_r. But remember that only the caller knows how the data will be used. If only one thread uses this particular directory context, for example, then no synchronization is needed. Even when the data is shared between threads, the caller may be able to supply more efficient synchronization, for example, if the context can be protected using a mutex that the application also uses for other data.</p>


<a name=t15></a><h3 class=book>
1.2.6 Concurrency control functions
</h3>
<p class=book>Any "concurrent system" must provide a core set of essential functions that you need to create concurrent execution contexts, and control how they operate within your library or application. Here are three essential facilities, or aspects, of any concurrent system:</p>
<p class=book>1<b>.</b> <i>Execution context</i> is the state of a concurrent entity. A concurrent system must provide a way to create and delete execution contexts, and maintain their state independently. It must be able to save the state of one context and dispatch to another at various times, for example, when one needs to wait for an external event. It must be able to continue a context from the point where it last executed, with the same register contents, at a later time.</p>
<p class=book>2. <i>Scheduling</i> determines which context (or set of contexts) should execute at any given point in time, and switches between contexts when necessary.</p>
<p class=book>3. <i>Synchronization</i> provides mechanisms for concurrent execution contexts to coordinate their use of shared resources. We use this term in a way that is nearly the opposite of the standard dictionary meaning. You'll find a definition much like "cause to occur at the same time," whereas we usually mean something that might better be expressed as "prevent from occurring at the same time." In a thesaurus, you may find that "cooperate" is a synonym for "synchronize"-and synchronization is the mechanism by which threads <i>cooperate</i> to accomplish a task. This book will use the term "synchronization," though, because that is what you'll see used, almost universally.</p>
<p class=book>There are many ways to provide each of these facilities—but they are always present in some form. The particular choices presented in this book are dictated by the book's subject—Pthreads. Table <b>1.1</b> shows a few examples of the three facilities in various systems.</p>
<TABLE>
<TR>
<TD></TD>
<TD align = "left" ><b>Execution context</b></TD>
<TD align = "left" ><b>Scheduling</b></TD>
<TD align = "left" ><b>Synchronization</b></TD>
</TR>
<TR>
<TD align = "left" ><b>Real traffic</b></TD>
<TD align = "left" >automobile</TD>
<TD align = "left" >traffic lights and signs</TD>
<TD align = "left" >turn signals and brake lights</TD>
</TR>
<TR>
<TD align = "left" ><b>UNIX</b></TD>
<TD align = "left" >process</TD>
<TD align = "left" >priority (nice)</TD>
<TD align = "left" >wait and pipes</TD>
</TR>
<TR>
<TD align = "left" ><b>(before threads)</b></TD>
<TD></TD>
<TD></TD>
<TD></TD>
</TR>
<TR>
<TD align = "left" ><b>Pthreads</b></TD>
<TD align = "left" >thread</TD>
<TD align = "left" >policy, priority</TD>
<TD align = "left" >condition variables and mutexes</TD>
</TR>
</TABLE>
<p class=book><b>TABLE 1.1</b> <i>Execution contexts, schedulers, and synchronization</i></p>
<p class=book>A system's scheduling facility may allow each thread to run until it voluntarily yields the processor to another thread ("run until block"). It may provide time-slicing, where each thread is forced to periodically yield so that other threads may run ("round-robin"). It may provide various scheduling policies that allow the application to control how each thread is scheduled according to that thread's function. It may provide a "class scheduler" where dependencies between threads are described so that, for example, the scheduler can ensure that members of a tightly coupled parallel algorithm are scheduled at the same time.</p>
<p class=book>Synchronization may be provided using a wide variety of mechanisms. Some of the most common forms are mutexes, condition variables, semaphores, and events. You may also use message passing mechanisms, such as UNIX pipes, sockets, POSIX message queues, or other protocols for communicating between asynchronous processes—on the same system or across a network. Any form of communication protocol contains some form of synchronization, because passing data around with no synchronization results in chaos, not <i>communication.</i></p>
<p class=book>The terms <i>thread, mutex,</i> and <i>condition variable</i> are the main topics of this book. For now, it is enough to know that a <i>thread</i> represents an "executable thing" on your computer. A mutex provides a mechanism to prevent threads from colliding unexpectedly, and a <i>condition variable</i> allows a thread, once it has avoided such a collision, to wait until it is safe to proceed. Both mutexes and condition variables are used to synchronize the operation of threads.</p>



<a name=t16></a><h3 class=book>
1.3 Asynchronous programming is intuitive ...
</h3>
<blockquote class="epigraph">
<p class=book>"In most gardens," the Tiger-lily said,</p>
<p class=book>"they make the beds too soft—so that the flowers are always asleep." This sounded a very good reason, and Alice was quite</p>
<p class=book>pleased to know it. "I never thought of that before!" she said.</p>
<blockquote class=book><i>— <i>Lewis Carroll, Through the Looking-Glass</i></i></blockquote>
</blockquote>

<p class=book>If you haven't been involved in traditional realtime programming, asynchronous programming may seem new and different. But you've probably been using</p>
<p class=book>asynchronous programming techniques all along. You've probably used UNIX, for example, and, even as a user, the common UNIX shells from sh to ksh have been designed for asynchronous programming. You've also been using asynchronous "programming" techniques in real life since you were born.</p>
<p class=book>Most people understand asynchronous behavior much more thoroughly than they expect, once they get past the complications of formal and restricted definitions.</p>


<a name=t17></a><h3 class=book>
1.3.1 ... because UNIX is asynchronous
</h3>
<p class=book>In any UNIX system, processes execute asynchronously with respect to each other, even when there is only a single processor. Yes, until recently it was difficult to write individual programs for UNIX that behaved asynchronously—but UNIX has always made it fairly easy for you to behave asynchronously. When you type a command to a shell, you are really starting an independent program—if you run the program in the background, it runs asynchronously with the shell. When you pipe the output of one command to another you are starting several independent programs, which synchronize between themselves using the pipe.</p>
<p class=book><b>I</b> Time is a synchronization mechanism.</p>
<p class=book>In many cases you provide synchronization between a series of processes yourself, maybe without even thinking about it. For example, you run the compiler <i>after</i> you've finished editing the source files. It wouldn't occur to you to compile them first, or even at the same time. That's elementary real-life synchronization.</p>
<p class=book><b>I</b> UNIX pipes and files can be synchronization mechanisms.</p>
<p class=book>In other cases you may use more complicated software synchronization mechanisms. When you type "ls|more" to a shell to pass the output of the ls command into the more command, you're describing synchronization by specifying a data dependency. The shell starts both commands right away, but the more command can't generate any output until it receives input from ls through the pipe. Both commands proceed concurrently (or even in parallel on a multiprocessor) with ls supplying data and more processing that data, independently of each other. If the pipe buffer is big enough, ls could complete before more ever started; but more can't ever get ahead of ls.</p>
<p class=book>Some UNIX commands perform synchronization internally. For example, the command "cc -o thread thread.c" might involve a number of separate processes. The cc command might be a "front end" to the C language environment, which runs a filter to expand preprocessor commands (like #include and #if), a compiler to translate the program into an intermediate form, an optimizer to reorder the translation, an assembler to translate the intermediate form into object language, and a loader to translate that into an executable binary file. As with ls |more, all these programs may be running at the same time, with synchronization provided by pipes, or by access to temporary files.</p>
<p class=book>UNIX processes can operate asynchronously because each process includes all the information needed to execute code. The operating system can save the state of one process and switch to another without affecting the operation of either. Any general-purpose asynchronous "entity" needs enough state to enable the operating system to switch between them arbitrarily. But a UNIX process includes additional state that is not directly related to "execution context," such as an address space and file descriptors.</p>
<p class=book>A thread is the part of a process that's necessary to execute code. On most computers that means each thread has a pointer to the thread's current instruction (often called a "PC" or "program counter"), a pointer to the top of the thread's stack (SP), general registers, and floating-point or address registers if they are kept separate. A thread may have other things, such as processor status and coprocessor control registers. A thread does not include most of the rest of the state associated with a process; for example, threads do not have their own file descriptors or address space. All threads within a process share all of the files and memory, including the program text and data segments.</p>
<p class=book><b>I</b> Threads are "simpler" than processes.</p>
<p class=book>You can think of a thread as a sort of "stripped down" process, lean and mean and ready to go. The system can switch between two threads within a process much faster than it can switch between processes. A large part of this advantage comes from the fact that threads within a process share the address space—code, data, stack, everything.</p>
<p class=book>When a processor switches between two processes, all of the hardware state for that process becomes invalid. Some may need to be changed as part of the context switch procedure—data cache and virtual memory translation entries may be flushed, for example. Even when they do not need to be flushed immediately, however, the data is not useful to the new process. Each process has a separate virtual memory address space, but threads running within the same process share the virtual address space and all other process data.</p>
<p class=book>Threads can make high-bandwidth communication easier between independent parts of your program. You don't have to worry about message passing mechanisms like pipes or about keeping shared memory region address references consistent between several different address spaces. Synchronization is faster, and programming is much more natural. If you create or open a file, all threads can use it. If you allocate a dynamic data structure with malloc, you can pass the address to other threads and they can reference it. Threads make it easy to take advantage of concurrency.</p>


<a name=t18></a><h3 class=book>
1.3.2 ... because the world is asynchronous
</h3>
<p class=book>Thinking asynchronously can seem awkward at first, but it'll become natural with a little practice. Start by getting over the unnatural expectation that everything will happen serially unless you do something "unusual." On a one-lane road cars proceed one at a time—but on a two-lane road two cars go at once. You can go out for a cup of coffee, leaving your computer compiling some code and fully expecting that it will proceed without you. Parallelism happens everywhere in the real world, and you expect it.</p>
<p class=book>A row of cashiers in a store serve customers in parallel; the customers in each line generally wait their turn. You can improve throughput by opening more lines, as long as there are registers and cashiers to serve them, and enough customers to be served by them. Creating two lines for the same register may avoid confusion by keeping lines shorter—but nobody will get served faster. Opening three registers to serve two customers may look good, but it is just a waste of resources.</p>
<p class=book>In an assembly line, workers perform various parts of the complete job in parallel, passing work down the line. Adding a station to the line may improve performance if it parallels or subdivides a step in the assembly that was so complicated that the operator at the next station spent a lot of time waiting for each piece. Beware of improving one step so much that it generates more work than the next step on the assembly line can handle.</p>
<p class=book>In an office, each project may be assigned to a "specialist." Common specialties include marketing, management, engineering, typing pool, sales, support, and so forth. Each specialist handles her project independently on behalf of the customer or some other specialist, reporting back in some fashion when done. Assigning a second specialist to some task, or defining narrower specialties (for example, assigning an engineer or manager permanently to one product) may improve performance as long as there's enough work to keep her busy. If not, some specialists play games while others' in-baskets overflow.</p>
<p class=book>Motor vehicles move in parallel on a highway. They can move at different speeds, pass each other, and enter and exit the highway independently. The drivers must agree to certain conventions in order to avoid collisions. Despite speed limits and traffic signs, compliance with the "rules of the road" is mostly voluntary. Similarly, threads must be coded to "agree" to rules that protect the program, or risk ending up undergoing emergency debugging at the thread hospital.</p>
<p class=book>Software can apply parallelism in the same ways you might use it in real life, and for the same reasons. When you have more than one "thing" capable of doing work, you naturally expect them to all do work at the same time. A multiprocessor system can perform multiple computations, and any time-sharing system can perform computations while waiting for an external device to respond. Software</p>
<p class=book>parallelism is subject to all of the complications and problems that we have seen in real life—and the solutions may not be as easy to see or to apply. You need enough threads, but not too many; enough communication, but not too much. A key to good threaded programming is learning how to judge the proper balance for each situation.</p>
<p class=book>Each thread can process similar parts of a problem, just like supermarket cashiers handling customers. Each thread can perform a specific operation on each data item in turn, just like the workers on an assembly line. Each thread can specialize in some specific operation and perform that operation repeatedly on behalf of other threads. You can combine these basic models in all sorts of ways; for example, in parallel assembly lines with some steps performed by a pool of servers.</p>
<p class=book>As you read this book you'll be introduced to concepts that may seem unfamiliar: mutexes, condition variables, race conditions, deadlocks, and priority inversions. Threaded programming may feel daunting and unnatural. But I'll explain all those concepts as we move through this book, and once you've been writing multithreaded code for a while you may find yourself noticing real-world analogies to the concepts. Threads and all this other stuff are formalized and restricted representations of things you already understand.</p>
<p class=book>If you find yourself thinking that someone shouldn't interrupt you because you have the conversation mutex locked, you've begun to develop an intuitive understanding of threaded programming. You can apply that understanding to help you design better threaded code with less effort. If something wouldn't make sense in real life, you probably shouldn't try it in a program either.</p>



<a name=t19></a><h3 class=book>
1.4 About the examples in this book
</h3>
<p class=book>This book contains a number of examples. All are presented as complete programs, and they have been built and tested on Digital UNIX 4.0d and Solaris 2.5.</p>
<p class=book>All of these programs do something, but many do not do anything of any particular importance. The purpose of the examples is to demonstrate thread management and synchronization techniques, which are mere overhead in most real programs. They would be less effective at revealing the details if that "overhead" was buried within large programs that "did something."</p>
<p class=book>Within the book, examples are presented in sections, usually one function at a time. The source code is separated from the surrounding text by a header and trailer block which include the file name and, if the example comprises more than one section, a section number and the name of the function. Each line of the source code has a line number at the left margin. Major functional blocks of each section are described in specially formatted paragraphs preceding the source code. These paragraphs are marked by line numbers outside the left margin of</p>
<p class=book>* It may also be a good time to take a break and read some healthy escapist fiction for a while.</p>
<p class=book>the paragraph, denoting the line numbers in the source listing to which the paragraph refers. Here's an example: <b>1-2</b> These lines show the header files included in most of the examples. The &lt;pthread.h&gt; header file declares constants and prototypes for the Pthreads functions, and the errors.h header file includes various other headers and some error-checking functions.</p>
<p class=book>■ sample.c part <b>1</b> sampleinfo</p>
<p class=book><CODE>1 #include &lt;pthread.h&gt;</CODE></p>
<p class=book><CODE>2 #include "errors.h"</CODE></p>
<p class=book>I have written these examples to use error checking everywhere. That is, I check for errors on each function call. As long as you code carefully, this isn't necessary, and some experts recommend testing only for errors that can result from insufficient resources or other problems beyond your control. I disagree, unless of course you're the sort of programmer who never makes a mistake. Checking for errors is not that tedious, and may save you a lot of trouble during debugging.</p>
<p class=book>You can build and run all of the examples for yourself—the source code is available online at <i>http://www.aw.com/butenhof/posixcode.html</i>. A Makefile is provided to build all of the examples, though it requires modifications for various platforms. On Digital UNIX, the examples were built with <CODE><b>CFLAGS</b>=-pthread -stdl -wl</CODE>. On Solaris, they were built with <CODE><b>CFLAGS=-D_REENTRANT -D_POSIX</b>_C_ <b>SOURCE=199506</b> -lpthread</CODE>. Some of the examples require interfaces that may not be in the Pthreads library on your system, for example, clock_gettime, which is part of the POSIX. lb realtime standard. The additional realtime library is specified by the <b>RTFLAGS</b> variable, which is defined as <b>RTFLAGS</b>=-lrt on Digital UNIX, and as <b>RTFLAGS</b>=-lposix4 on Solaris.</p>
<p class=book>On Solaris 2.5 systems, several of the examples require calls to thr_setcon-currency to ensure proper operation. This function causes Solaris to provide the process with additional concurrency. In a few cases, the example will not operate at all without this call, and in other cases, the example would fail to demonstrate some behavior.</p>


<a name=t20></a><h3 class=book>
1.5 Asynchronous programming, by example
</h3>
<blockquote class="epigraph">
<p class=book>"In one moment I've seen what has hitherto been Enveloped in absolute mystery, And without extra charge I will give you at large A Lesson in Natural History."</p>
<blockquote class=book><i>— <i>Lewis Carroll, The Hunting of the Snark</i></i></blockquote>
</blockquote>

<p class=book>This section demonstrates some basic asynchronous programming, using a simple program that does something vaguely useful, by pretending to be an alarm clock with a command interface for which you would not consider paying a dime in a store. But then, this book is about threads, not user interfaces, and the code that I need to show takes up quite enough space already.</p>
<p class=book>The program prompts for input lines in a loop until it receives an error or end of file on stdin. On each line, the first nonblank token is interpreted as the number of seconds to wait, and the rest of the line (up to 64 characters) is a message that will be printed when the wait completes. I will offer two additional versions— one using multiple processes, and one using multiple threads. We'll use the three examples to compare the approaches.</p>


<a name=t21></a><h3 class=book>
1.5.1 The baseline, synchronous version
</h3>
<p class=book><b>1	</b> Include the header file errors.h, which includes standard headers like &lt;unistd.h&gt; and &lt;stdio.h&gt; and defines error reporting macros that are used throughout the examples in this book. We don't use the error reporting macros in this particular example, but consistency is nice, sometimes.</p>
<p class=book><b>9-26</b> 	The "baseline" version, alarm.c, is a synchronous alarm program with a single routine, main. Most of main is a loop, which processes simple commands until fgets returns a NULL (error or end of file). Each line is "parsed" with sscanf to separate the number of seconds to wait (%d, the first sequence of digits) from the message string to print (%64 [^\n], the rest of the line, up to 64 characters excluding newline).</p>
<p class=book>■ alarm.c</p>
<p class=book><CODE>1 #include "errors.h" 2</CODE></p>
<p class=book><CODE>3 int main (int argc, char *argv[])</CODE></p>
<p class=book><CODE>4 {</CODE></p>
<p class=book><CODE>5 int seconds;</CODE></p>
<p class=book><CODE>6 char line[128];</CODE></p>
<p class=book><CODE>7 char message[64]; 8</CODE></p>
<p class=book><CODE>9 while (1) {</CODE></p>
<p class=book><CODE>10 printf ("Alarm&gt; ");</CODE></p>
<p class=book><CODE>11 if (fgets (line, sizeof (line), stdin) == NULL) exit (0);</CODE></p>
<p class=book><CODE>12 if (strlen (line) &lt;= 1) continue; 13</CODE></p>
<p class=book><CODE>14 /*</CODE></p>
<p class=book><CODE>15 * Parse input line into seconds (%d) and a message</CODE></p>
<p class=book><CODE>16 * (%64[^\n]), consisting of up to 64 characters</CODE></p>
<p class=book><CODE>17 * separated from the seconds by whitespace.</CODE></p>
<p class=book><CODE>18 */</CODE></p>
<br>
<p class=book><CODE>19			if (sscanf (line, "%d %64[^\n]",</CODE></p>
<p class=book><CODE>20			&seconds, message) &lt; 2) {</CODE></p>
<p class=book><CODE>21			fprintf (stderr, "Bad command\n");</CODE></p>
<p class=book><CODE>22			} else {</CODE></p>
<p class=book><CODE>23			sleep (seconds);</CODE></p>
<p class=book><CODE>24			printf ("(%d) %s\n", seconds, message);</CODE></p>
<p class=book><CODE>25			}</CODE></p>
<p class=book><CODE>26		}	</CODE></p>
<p class=book><CODE>27	}		</CODE></p>
<p class=book>The problem with the program alarm.c is that only one alarm request can be active at a time. If you set an alarm to remind you to do something in 10 minutes (600 seconds), you can't decide to have it remind you of something else in 5 minutes. The program is doing something synchronously that you would probably like to be asynchronous.</p>


<a name=t22></a><h3 class=book>
1.5.2 A version using multiple processes
</h3>
<p class=book>There are lots of ways to make this program asynchronous; for example, you could run more than one copy of the program. One way to run multiple copies is to fork a child process for each command, as shown in alarm_fork.c. The new version is asynchronous—you can enter commands at any time, and they will be carried out independently. It isn't much more complicated than the original, which is nice.</p>
<p class=book><b>27-37 	</b>The main difference between alarm.c and alarm_fork.c is that instead of calling sleep directly, it uses fork to create a new child process, which then calls sleep (and, eventually, printf) <i>asynchronously,</i> while the parent process continues.</p>
<p class=book><b>42-46</b> 	The primary complication in this version is the need to "reap" any child processes that have terminated. If the program fails to do this, the system will save them all until the program terminates. The normal way to reap terminated child processes is to call one of the wait functions. In this case, we call waitpid, which allows the caller to specify the WNOHANG flag. The function will immediately reap one child process if any have terminated, or will immediately return with a process ID (pid) of 0. The parent process continues to reap terminated child processes until there are no more to reap. When the loop terminates, main loops back to line 13 to read a new command.</p>
<p class=book>■ <b>alarm_fork.c</b></p>
<p class=book><CODE>1 #include &lt;sys/types.h&gt;</CODE></p>
<p class=book><CODE>2 #include &lt;wait.h&gt;</CODE></p>
<p class=book><CODE>3 #include "errors.h"</CODE></p>
<p class=book><CODE>5 int main (int argc, char *argv[])</CODE></p>
<p class=book><CODE>6 {</CODE></p>
<p class=book><CODE>7 int status;</CODE></p>
<p class=book><CODE>8 char line[128];</CODE></p>
<p class=book><CODE>9 int seconds;</CODE></p>
<p class=book><CODE>10 pid_t pid;</CODE></p>
<p class=book><CODE>11 char message[64]; 12</CODE></p>
<p class=book><CODE>13 while (1) {</CODE></p>
<p class=book><CODE>14 printf ("Alarm&gt; " ) ;</CODE></p>
<p class=book><CODE>15 if (fgets (line, sizeof (line), stdin) == NULL) exit (0);</CODE></p>
<p class=book><CODE>16 if (strlen (line) &lt;= 1) continue;</CODE></p>
<p class=book><CODE>17</CODE></p>
<p class=book><CODE>18 /*</CODE></p>
<p class=book><CODE>19 * Parse input line into seconds (%d) and a message</CODE></p>
<p class=book><CODE>20 * (%64[^\n]), consisting of up to 64 characters</CODE></p>
<p class=book><CODE>21 * separated from the seconds by whitespace.</CODE></p>
<p class=book><CODE>22 */</CODE></p>
<p class=book><CODE>23 if (sscanf (line, "%d %64[^\n]",</CODE></p>
<p class=book><CODE>24 &seconds, message) &lt; 2) {</CODE></p>
<p class=book><CODE>25 fprintf (stderr, "Bad command\n");</CODE></p>
<p class=book><CODE>26 } else {</CODE></p>
<p class=book><CODE>27 pid = fork ( );</CODE></p>
<p class=book><CODE>28 if (pid == (pid_t)-l)</CODE></p>
<p class=book><CODE>29 errno_abort ("Fork");</CODE></p>
<p class=book><CODE>30 if (pid == (pid_t)0) {</CODE></p>
<p class=book><CODE>31 /*</CODE></p>
<p class=book><CODE>32 * In the child, wait and then print a message</CODE></p>
<p class=book><CODE>33 */</CODE></p>
<p class=book><CODE>34 sleep (seconds);</CODE></p>
<p class=book><CODE>35 printf ("(%d) %s\n", seconds, message);</CODE></p>
<p class=book><CODE>36 exit (0);</CODE></p>
<p class=book><CODE>37 } else {</CODE></p>
<p class=book><CODE>38 /*</CODE></p>
<p class=book><CODE>39 * In the parent, call waitpid() to collect children</CODE></p>
<p class=book><CODE>40 * that have already terminated.</CODE></p>
<p class=book><CODE>41 */</CODE></p>
<p class=book><CODE>42 do {</CODE></p>
<p class=book><CODE>43 pid = waitpid ((pid_t)-l, NULL, WNOHANG);</CODE></p>
<p class=book><CODE>44 if (pid == (pid_t)-l)</CODE></p>
<p class=book><CODE>45 errno_abort ("Wait for child");</CODE></p>
<p class=book><CODE>46 } while (pid != (pid_t)0);</CODE></p>
<p class=book><CODE>47 }</CODE></p>
<p class=book><CODE>48 }</CODE></p>
<p class=book><CODE>49 }</CODE></p>


<a name=t23></a><h3 class=book>
<b>1.5.3 A version using multiple threads</b>
</h3>
<p class=book>Now, let us try another alarm program, alarm_thread.c. It is much like the fork version in alarm_fork.c, except that it uses threads instead of child processes to create asynchronous alarms. Four Pthreads calls are used in this program:</p>
<p class=book>• pthread_create creates a thread running the routine specified in the third argument (alarm_thread), returning an identifier for the new thread to the variable referenced by thread.</p>
<p class=book>• pthread_detach allows Pthreads to reclaim the thread's resources as soon as it terminates.</p>
<p class=book>• pthread_exit terminates the calling thread.</p>
<p class=book>• pthread_self returns the calling thread's identifier.</p>
<p class=book><b>4-7</b> The alarm_t structure defines the information stored for each alarm command, the number of seconds until the alarm is due, and the message string that will be printed by the thread.</p>
<p class=book>■ alarm_thread.c part <b>1</b> definitions</p>
<p class=book><CODE>1 #include &lt;pthread.h&gt;</CODE></p>
<p class=book><CODE>2 #include "errors.h" 3</CODE></p>
<p class=book><CODE>4 typedef struct alarm_tag {</CODE></p>
<p class=book><CODE>5 int seconds;</CODE></p>
<p class=book><CODE>6 char message[64];</CODE></p>
<p class=book><CODE>7 } alarm_t;</CODE></p>
<p class=book><b>1-8</b> The alarm_thread function is the "alarm thread." That is, each alarm thread is created running this function, and when the function returns the thread terminates. The function's argument (void *arg) is the fourth argument that was passed to pthread_create, in this case, a pointer to the control packet (alarm_t) created for the alarm request that the thread is to satisfy. The thread starts by "mapping" the void * argument as a pointer to a control packet. The thread <i>detaches</i> itself by calling pthread_detach, which informs Pthreads that the application does not need to know when the thread terminates or its termination status.</p>
<p class=book><b>9-12</b> The thread sleeps for the number of seconds specified in its control packet, and then prints the message string. Finally, the thread frees the control packet and returns. When a thread returns from its initial routine, as it does here, the thread terminates. Normally, Pthreads would hold the thread's resources so that another thread could later determine that it had exited and retrieve a final result. Because the thread detached itself, none of that is necessary.</p>
<p class=book>■ alarm_thread.c part 2 alarm_thread</p>
<p class=book><CODE>1	void *alarm_thread (void *arg)</CODE></p>
<p class=book><CODE>2	{	</CODE></p>
<p class=book><CODE>3		alarm_t *alarm = (alarm_t*)arg;</CODE></p>
<p class=book><CODE>4		int status;</CODE></p>
<p class=book><CODE>5</CODE></p>
<p class=book><CODE>6		status = pthread_detach (pthread_self ());</CODE></p>
<p class=book><CODE>7		if (status != 0)</CODE></p>
<p class=book><CODE>8		err_abort (status, "Detach thread");</CODE></p>
<p class=book><CODE>9		sleep (alarm-&gt;seconds);</CODE></p>
<p class=book><CODE>10		printf ("(%d) %s\n", alarm-&gt;seconds, alarm-&gt;message);</CODE></p>
<p class=book><CODE>11		free (alarm);</CODE></p>
<p class=book><CODE>12		return NULL;</CODE></p>
<p class=book><CODE>13	}	</CODE></p>
<p class=book>The main program of alarm_thread.c is much the same as the other two variants. It loops, reading and interpreting command lines as long as it can read from stdin.</p>
<p class=book><b>12-25</b> In this variation, main allocates heap storage (alarm_t) for each alarm command. The alarm time and message are stored in this structure, so each thread can be given the appropriate information. If the sscanf call fails to "parse" a correct command, the heap storage is freed.</p>
<p class=book><b>26-29</b> An alarm thread is created, running function alarm_thread, with the alarm data (alarm_t) as the thread's argument.</p>
<p class=book>■ alarm_thread.c_ part 3 main</p>
<p class=book><CODE>1 int main (int argc, char *argv[])</CODE></p>
<p class=book><CODE>2 {</CODE></p>
<p class=book><CODE>3 int status;</CODE></p>
<p class=book><CODE>4 char line[128];</CODE></p>
<p class=book><CODE>5 alarm_t *alarm;</CODE></p>
<p class=book><CODE>6 pthread_t thread;</CODE></p>
<p class=book><CODE>7</CODE></p>
<p class=book><CODE>8 while (1) {</CODE></p>
<p class=book><CODE>9 printf ("Alarm&gt; ");</CODE></p>
<p class=book><CODE>10 if (fgets (line, sizeof (line), stdin) == NULL) exit (0);</CODE></p>
<p class=book><CODE>11 if (strlen (line) &lt;= 1) continue;</CODE></p>
<p class=book><CODE>12 alarm = (alarm_t*)malloc (sizeof (alarm_t));</CODE></p>
<p class=book><CODE>13 if (alarm == NULL)</CODE></p>
<p class=book><CODE>14 errno_abort ("Allocate alarm");</CODE></p>
<p class=book><CODE>15</CODE></p>
<p class=book><CODE>16 /*</CODE></p>
<p class=book><CODE>17 * Parse input line into seconds (%d) and a message</CODE></p>
<p class=book><CODE>18 * (%64[^\n]), consisting of up to 64 characters</CODE></p>
<p class=book><CODE>19 * separated from the seconds by whitespace.</CODE></p>
<p class=book><CODE>20 */</CODE></p>
<p class=book><CODE>21 if (sscanf (line, "%d %64[^\nJ",</CODE></p>
<p class=book><CODE>22 &alarm-&gt;seconds, alarm-&gt;message) &lt; 2) {</CODE></p>
<p class=book><CODE>23 fprintf (stderr, "Bad command\n");</CODE></p>
<p class=book><CODE>24 free (alarm);</CODE></p>
<p class=book><CODE>25 } else {</CODE></p>
<p class=book><CODE>2 6 status = pthread_create (</CODE></p>
<p class=book><CODE>27 &thread, NULL, alarm_thread, alarm);</CODE></p>
<p class=book><CODE>28 if (status != 0)</CODE></p>
<p class=book><CODE>29 err_abort (status, "Create alarm thread");</CODE></p>
<p class=book><CODE>30 }</CODE></p>
<p class=book><CODE>31 }</CODE></p>
<p class=book><CODE>32 }</CODE></p>


<a name=t24></a><h3 class=book>
<b>1.5.4 Summary</b>
</h3>
<p class=book>A good way to start thinking about threads is to compare the two asynchronous versions of the alarm program. First, in the fork version, each alarm has an independent address space, copied from the main program. That means we can put the seconds and message values into local variables—once the child has been created (when fork returns), the parent can change the values without affecting the alarm. In the threaded version, on the other hand, all threads share the same address space—so we call malloc to create a new structure for each alarm, which is passed to the new thread. The extra bookkeeping required introduces a little complexity into the threaded version.</p>
<p class=book>In the version using fork, the main program needs to tell the kernel to free resources used by each child process it creates, by calling <CODE>waitpid</CODE> or some other member of the wait "family." The alarm_fork.c program, for example, calls <CODE>waitpid</CODE> in a loop after each command, to collect all child processes that have completed. You do not need to wait for a thread unless you need the thread's return value — in alarm_thread.c, for example, each alarm thread <i>detaches</i> itself (at line 6, part 2) so that the resources held by the thread will be returned immediately when it terminates.</p>
<p class=book>In the threaded version, the "primary activities" (sleeping and printing the message) must be coded in a separate routine. In alarm.c and alarm_fork.c, those activities were performed without a call. In simple cases such as our alarm program, it is often easier to understand the program with all code in one place, so that might seem like an advantage for alarm_fork .c. In more complicated programs, though, it is rare that a program's "primary activities" are so simple that they can be performed in a single routine without resulting in total confusion.</p>
<p class=book>In a real alarm program, you wouldn't want to create a process for each alarm. You might easily have hundreds of alarms active, and the system probably wouldn't let you create that many processes. On the other hand, you probably can create hundreds of threads within a process. While there is no real need to maintain a stack and thread context for each alarm request, it is a perfectly viable design.</p>
<p class=book><i>A</i> more sophisticated version of alarm_thread.c might use only two threads: one to read input from the user, and another to wait for expiration of the next alarm—I'll show that version later, after we've worked through some more basic concepts. You could do the same thing with two processes, of course, but it would be more cumbersome. Passing information between two threads is easy and fast—no shared memory to map, no pipes to read or write, no concerns about whether you are passing addresses that may not mean the same thing in both processes. Threads share everything in their address space—any address that's valid in one thread is valid in all threads.</p>



<a name=t25></a><h3 class=book>
1.6 Benefits of threading
</h3>
<blockquote class="epigraph">
<p class=book>'"O Looking-Glass creatures,'quoth Alice, 'draw near!</p>
<p class=book>Tis an honour to see me, a favour to hear:</p>
<p class=book>'Tis a privilege high to have dinner and tea</p>
<p class=book>Along with the Red Queen, the White Queen, and me!'"</p>
<blockquote class=book><i>— <i>Lewis Carroll, Through the Looking-Glass</i></i></blockquote>
</blockquote>

<p class=book>Some advantages of the multithreaded programming model follow:</p>
<p class=book>1. Exploitation of program parallelism on multiprocessor hardware. Parallelism is the only benefit that requires special hardware. The others can help most programs without special hardware.</p>
<p class=book>2. More efficient exploitation of a program's natural concurrency, by allowing the program to perform computations while waiting for slow I/O operations to complete.</p>
<p class=book>3. A modular programming model that clearly expresses relationships between independent "events" within the program.</p>
<p class=book>These advantages are detailed in the following sections.</p>


<a name=t26></a><h3 class=book>
1.6.1 Parallelism
</h3>
<p class=book>On a multiprocessor system, threading allows a process to perform more than one independent computation at the same time. A computation-intensive threaded application running on two processors may achieve nearly twice the performance of a traditional single-threaded version. "Nearly twice" takes into account the fact that you'll always have some overhead due to creating the extra thread(s) and performing synchronization. This effect is often referred to as "scaling." A two-processor system may perform 1.95 times as fast as a single processor, a three-processor system 2.9 times as fast, a four-processor system 3.8 times as fast, and so forth. Scaling almost always falls off as the number of processors increases because there's more chance of lock and memory collisions, which cost time.</p>
<img border=0 style='spacing 9px;' src="img_2.png">
<br>
<p class=book><b>FIGURE 1.1</b> <i>Amdahl's law</i></p>
<p class=book>Scaling can be predicted by "Amdahl's law," which is shown in Figure 1.1. In the equation, <i>p</i> represents the ratio of "parallelizable code" over "total execution time," and n represents the number of processors the code can use. The total elapsed time for a parallel job is the sum of the elapsed time for the nonparallelizable work (1 - p) and the elapsed time for each processor executing the parallelizable work <i>(p/n).</i></p>
<p class=book>Amdahl's law is a simple relationship showing how parallelism is limited by the amount of serialization needed. When the program has no parallelizable code <i>(p</i> is 0), the speedup is 1. That is, it is not a parallel program. If the program requires no synchronization or other serial code (p is 1), then the speedup is n (the number of processors). As more synchronization is required, parallelism provides less benefit. To put it another way, you'll get better scaling with activities that are completely independent than with activities that are highly dependent: The independent activities need less synchronization.</p>
<p class=book>The diagram in Figure 1.2 shows the effect of Amdahl's law. "Clock time" progresses from left to right across the page, and the diagram shows the number of processors working in parallel at any moment. Areas where the diagram has only a single horizontal line show that the process is serialized. Areas that have several horizontal lines in parallel show where the process benefits from multiple processors. If you can apply multiple processors for only 10% of your program's execution time, and you have four processors, then Amdahl's law predicts a speedup of 1 / (0.9+( 0.1 /4)), or about 8%.</p>
<br>
<img border=0 style='spacing 9px;' src="img_3.png">
<p class=book><b>FIGURE 1.2</b> <i>Parallelism charted against time</i></p>
<br>
<p class=book>Operations on large matrices can often be "parallelized" by splitting the matrix into pieces. For example, each thread may be able to operate on a set of rows or columns without requiring any data written by threads operating on other slices. You still generally need to synchronize threads at the beginning and end of processing the matrix, frequently using a <i>barrier</i><sup><a name=r1><a href="#n1" title="
A barrier is a simple synchronization mechanism that blocks each thread until a certain number has reached the barrier; then all threads are unblocked. Barriers can be used, for example, to keep any thread from executing a parallel region of code until all threads are ready to execute the region. Section 7.1.1 describes barriers in more detail, and demonstrates the construction of a simple barrier package.
">[1]</sup></A><i>.</i> Amdahl's law shows that you'll get better performance by giving each thread a large and relatively independent "chunk" of work, requiring infrequent synchronization, than by giving them smaller chunks.</p>
<p class=book>Amdahl's law is an excellent thought exercise to help you understand scaling. It is not, however, a practical tool, because it is nearly impossible to accurately compute <i>p</i> for any program. To be accurate, you need to consider not only all serialized regions within your code, but also within the operating system kernel and even in hardware. Multiprocessor hardware must have some mechanism to synchronize access to the contents of memory. When each processor has a private data cache, the contents of those caches must be kept consistent with each other and with the data in memory. All of this serialization must be included in any accurate calculation.</p>


<a name=t27></a><h3 class=book>
1.6.2 Concurrency
</h3>
<p class=book>The threaded programming model allows the program to make computational progress while waiting for blocking operations like I/O. This is useful for network servers and clients, and it is the main reason that client/server systems (such as OSF DCE) use threads. While one thread waits for a long network read or write operation, that thread is blocked and other threads in your application can execute independently. Some systems support asynchronous I/O operations, which can give similar advantages; but most UNIX-based systems do not have asynchronous I/O.<sup><a name=r2><a href="#n2" title="
UNIX systems support &quot;nonblocking I/O,&quot; but this is not the same thing as asynchronous I/O. Nonblocking I/O allows the program to defer issuing an I/O operation until it can complete without blocking, but asynchronous I/O can proceed while the program does something else.
">[2]</sup></A> Furthermore, asynchronous I/O is generally a lot more complicated to use than threads.</p>
<p class=book>For example, you need to either handle asynchronous notification when the I/O completes, or poll for completion. If you issued an asynchronous I/O and then entered a polling loop, you would lose the advantage of asynchronous I/O— your application would just wait. If you poll elsewhere, or handle asynchronous notification, then <i>issuing</i> the I/O and <i>processing</i> the resulting data occur in different locations within your program. That makes the code more difficult to</p>
<p class=book>analyze and maintain. When you use synchronous I/O you just perform the I/O and then do whatever comes next. Synchronous I/O within multiple threads gives nearly all the advantages of asynchronous I/O. In most cases you will find it much easier to write complex asynchronous code using threads than using traditional asychronous programming techniques.</p>
<p class=book>You could write an <i>alarm</i> program, like those shown in Section 1.5, as an asynchronous program without using processes or threads, with timer signals for the alarms and asynchronous reads for input. Using timer signals is more complicated in many ways, since you are severely limited in what you can do within a signal handler. Asynchronous I/O does not allow you to take advantage of the convenience of <i>stdio</i> functions. The basic program function will be scattered through a series of signal handlers and functions, and will probably be harder to understand.</p>
<p class=book>Asynchronous I/O does have one advantage over threaded concurrency, though. Just as a thread is usually "cheaper" (in execution time and storage space) than a process, the context required for an asynchronous I/O operation is almost always cheaper than a thread. If you plan to have a lot of asynchronous I/O operations active at the same time, that might be important enough to justify using the more complicated programming model. But watch out—some "asynchronous I/O" packages just distribute your I/O requests across a pool of threads! Most of the time you will be better off using threads.</p>
<p class=book>Another method of coding an asynchronous application is for each action to be treated as an "event." Events are queued by some "hidden" process, and dispatched serially to be handled by the application, usually through "callback" routines registered with the dispatcher. Event dispatchers have been popularized by windowing interface systems such as the Apple Macintosh toolbox, Microsoft Windows, and X Windows on UNIX (used by Motif and CDE).</p>
<p class=book>The event mechanism alleviates much of the complication of using signals and asynchronous I/O, as long as the events are supported directly by the event dispatcher. All, for example, handle input from the keyboard or pointer device, and generally one can request a timer event to be inserted automatically at a desired time. Thus, the alarm program, written to an event interface, need only initialize the event dispatcher and enter a loop to process events. Input events would be dispatched to the parser, resulting in a request for a new timer event; and timer events would be dispatched to a function that would format and print the alarm message.</p>
<p class=book>For very simple applications (and the alarm program here is certainly one example), an event-based implementation may be simpler than the multiprocess or multithread variations I've shown — at least when the (often substantial) overhead of initializing the event dispatcher is removed. The limitations of events become more obvious when you build larger and more sophisticated applications—the problem is that the events are sequential.</p>
<p class=book>Events are not concurrent, and the program can do only one thing at a time. Your application receives an event, processes it, and then receives the next event. If processing an event takes a long time, for example, sorting a large database,</p>
<p class=book>the user interface may remain unresponsive for quite a while. If an event involves a long wait, for example, reading data over a slow network connection, then, again, the user must wait.</p>
<p class=book>The response problems can be minimized by liberally sprinkling extended operations with calls to the event dispatcher—but getting them in the right place, without substantially impacting the performance of the operation, can be difficult. Furthermore, you may not have that option, if the database sort is taking place in a shared library you bought from somebody else.</p>
<p class=book>On the other hand, one might code the application to create a new thread that runs the database sort, or reads from the slow network, leaving the "user interface" thread to immediately request another event. The application becomes responsive, while the slow operation continues to run. You can do this even if a database package, for example, cannot tolerate being run in multiple threads, by queuing a "sort" command to a server thread that runs database operations serially—while still retaining interface responsiveness.</p>


<a name=t28></a><h3 class=book>
1.6.3 Programming model
</h3>
<p class=book>It may be surprising that programming with threads is a good idea even if you know your code will never run on a multiprocessor. But it is true. Writing with threads forces you to think about and plan for the synchronization requirements of your program. You've always had to think about program dependencies, but threads help to move the requirements from comments into the executable structure of the program.</p>
<p class=book>Assembly language programs can use all the same sequential control structures (loops, conditional code) as programs written in a high-level language. However, it can be difficult to determine whether a branch instruction represents the top or bottom of a loop, a simple conditional, a "conditional goto," or something more exotic. Switching to a higher-level language that supports these sequential controls directly in source, for example, the C language do, while, for, if, and switch statements, makes these sequential programming constructs explicit in the source language. Making control structures explicit in the program source code means that more of your program's design is explicit in the source, and that makes it easier for someone else to understand.</p>
<p class=book>Similarly, a C language program (or even an assembler program) may use data encapsulation and polymorphism by adhering to programming conventions, and with luck those conventions may be carefully documented and the documentation kept updated. But if that same code is written in an object-oriented language, the encapsulation and polymorphism become explicit in the source language.</p>
<p class=book>In a sequential program, synchronization requirements are implicit in the ordering of operations. The true synchronization requirements, for example, that "a file must be opened before data can be read from the file," may be documented only by source comments, if at all. When you program using threads, sequential assumptions are (or at least should be) limited to small segments of contiguous</p>
<p class=book>code—for example, within a single function. More global assumptions, to be at all safe, must be protected by explicit synchronization constructs.</p>
<p class=book>In traditional serial programming you call function A to do one thing, then call another function B to do something else, even when those two functions don't require serialization. If a developer is trying to determine what the program is doing, perhaps to trace a bug, it often isn't obvious that there may be no need to follow both calls. Furthermore, the strictly serial model makes it easy for someone to inadvertently make function B dependent on some side effect of function A. If a later modification reverses the order of the calls, the program may break in ways that aren't obvious. Program dependencies may be documented using source code comment blocks, but comments are often ambiguous and may not be properly updated when code is changed.</p>
<p class=book>The threaded programming model isolates independent or loosely coupled functional execution streams (threads) in a clear way that's made explicit in the program's source code. If activities are designed as threads, each function must include explicit synchronization to enforce its dependencies. Because synchronization is executable code, it can't be ignored when dependencies are changed. The presence of synchronization constructs allows anyone reading the code to follow temporal dependencies within the code, which can make maintenance substantially easier, especially for large programs with a lot of independent code.</p>
<p class=book>An assembly language programmer can write better, more maintainable assembly code by understanding high-level language programming; a C language programmer can write better, more maintainable C code by understanding object-oriented programming. Even if you never write a threaded program, you may benefit from understanding the threaded programming model of independent functions with explicit dependencies. These are "mental models" (or that dreadfully overused word, "paradigms") that are more or less independent of the specific code sequences you write. Cleanly isolating functionally independent code may even make sequential programs easier to understand and maintain.</p>



<a name=t29></a><h3 class=book>
1.7 Costs of threading
</h3>
<blockquote class="epigraph">
<p class=book>All this time the Guard was looking at her, first through a telescope, then through a microscope, and then through an opera-glass. At last he said, "You're traveling the wrong way," and shut up the window, and went away.</p>
<blockquote class=book><i>— <i>Lewis Carroll, Through the Looking-Glass</i></i></blockquote>
</blockquote>

<p class=book>Of course there's always "the flip side." As I showed in the previous section, threads provide definite and powerful advantages, even on uniprocessor systems. They provide even more advantages on a multiprocessor.</p>
<p class=book>So why <i>wouldn't</i> you want to use threads? Everything has a cost, and threaded programming is no exception. In many cases the advantage exceeds the</p>
<p class=book>cost; in others it doesn't. To be fair, the following subsections discuss the cost of threaded programming.</p>


<a name=t30></a><h3 class=book>
1.7.1 Computing overhead
</h3>
<p class=book>Overhead costs in threaded code include direct effects such as the time it takes to synchronize your threads. Many clever algorithms are available for avoiding synchronization in some cases, but none of them is portable. You'll have to use some synchronization in just about any threaded code. It is easy to lose performance by using too much synchronization; for example, by separately protecting two variables that are always used together. Protecting each variable separately means you spend a lot more time on synchronization without gaining parallelism, since any thread that needs one variable will need the other as well.</p>
<p class=book>The overhead of threaded programming can also include more subtle effects. For example, threads that constantly write the same memory locations may spend a lot of time synchronizing the memory system on processors that support "read/ write ordering." Other processors may spend that time synchronizing only when you use special instructions such as a memory barrier, or a "multiprocessor atomic" operation like test-and-set. Section 3.4 says a lot more about these effects.</p>
<p class=book>Removing a bottleneck in your code, for example, by adding threads to perform multiple concurrent I/O operations, may end up revealing another bottleneck at a lower level—in the ANSI C library, the operating system, the file system, the device driver, the memory or I/O architecture, or the device controller. These effects are often difficult to predict, or measure, and are usually not well documented.</p>
<p class=book>A compute-bound thread, which rarely blocks for any external event, cannot effectively share a processor with other compute-bound threads. An I/O thread might interrupt it once in a while, but the I/O thread would block for another external event and the compute-bound thread would run again. When you create more compute-bound threads than there are available processors, you may gain better code structuring over a single-threaded implementation, but you will have worse performance. The performance suffers because the multithreaded implementation adds thread synchronization and scheduling overhead to the work you wanted to accomplish—and does it all using the same compute resources.</p>


<a name=t31></a><h3 class=book>
1.7.2 Programming discipline
</h3>
<p class=book>Despite the basic simplicity of the threaded programming model, writing real-world code is never trivial. Writing code that works well in multiple threads takes careful thought and planning. You have to keep track of synchronization protocols and program invariants. You have to avoid deadlocks, races, and priority inversions. I'll describe all of these things in later sections, show how to design code to avoid the problems, and how to find and repair them after the fact.</p>
<p class=book>You will almost certainly use Library code that you did not write. Some will be supplied with the operating system you use, and most of the more common libraries will likely be safe to use within multiple threads. POSIX guarantees that most functions specified by ANSI C and POSIX must be safe for use by multithreaded applications. However, a lot of "interesting" functions you will probably need are not included in that list. You will often need to call libraries that are not supplied with the operating system, for example, database software. Some of that code will not be thread-safe. I will discuss techniques to allow you to use most unsafe code, but they will not always work, and they can be ugly.</p>
<p class=book>All threads within a process share the same address space, and there's no protection boundary between the threads. If a thread writes to memory through an uninitialized pointer, it can wipe out another thread's stack, or heap memory being used by some other thread. The eventual failure will most likely occur in the innocent victim, possibly long after the perpetrator has gone on to other things. This can be especially important if arbitrary code is run within a thread. For example, in a library that supports callbacks to functions supplied by its caller, be sure that the callback, as well as the library, is thread-safe.</p>
<p class=book>The important points are that good sequential code is not necessarily good threaded code, and bad threaded code will break in ways that are more difficult to locate and repair. Thinking about real-life parallelism can help a lot, but programming requires a lot more detailed work than most things in real life.</p>


<a name=t32></a><h3 class=book>
1.7.3 Harder to debug
</h3>
<p class=book>You will learn more about debugging threaded code, and, more importantly, <i>not</i> debugging threaded code, in Chapter 8. You will see some of the tools you may encounter as well as some techniques you can use on your own. By then you will know all about mutexes and memory visibility, and you will be ready to deal with deadlocks and races. Don't worry about the details now—the point of this brief section is to demonstrate that you <i>will</i> have to learn about threaded debugging, and it is not as easy yet as anyone would like it to be. (So when was debugging <i>ever</i> easy?)</p>
<p class=book>Systems that support threads generally extend traditional sequential debugging tools to provide basic debugging support. The system may provide a debugger that allows you to see the call tree for all of your program's threads, for example, and set breakpoints that activate only in particular threads. The system may provide some form of performance analyzer that lets you measure the processor time accumulated within each function for a specific thread or across all threads.</p>
<p class=book>Unfortunately that's only the beginning of the problems when you're debugging asynchronous code. Debugging inevitably changes the timing of events. That doesn't matter much when you're debugging sequential code, but it is critical when you're debugging asynchronous code. If one thread runs even slightly slower than another because it had to process a debugger trap, the problem you're</p>
<p class=book>trying to track down may not happen. Every programmer has run into problems that won't reproduce under the debugger. You'll run into a lot more of them when you use threads.</p>
<p class=book>It is difficult to track down a memory corruptor, for example, a function that writes through an uninitialized pointer, in a sequential program. It is even harder in a threaded program. Did some other thread write to memory without using a mutex? Did it use the wrong mutex? Did it count on another thread setting up a pointer without explicit synchronization? Was it just an old fashioned sequential memory corruptor?</p>
<p class=book>Various additional tools are provided by some systems to help you. None of these is standard or widely available. Tools may check source code for obvious violations of locking protocol, given a definition of which variables are shared and how they should be locked. They may record thread interactions while the program runs, and allow you to analyze or even replay the interactions to determine what happened. They may record and measure synchronization contention and overhead. They may detect complicated deadlock conditions between a set of mutexes.</p>
<p class=book>Your most powerful and portable thread debugging tool is your mind, applied through the old fashioned manual human-powered code review. You'll probably spend a lot of time setting up a few breakpoints and examining lots of states to try to narrow the problem down a little and then carefully reading the code to find problems. It is best if you have someone available who didn't write the code, because a lot of the worst errors are embarrassingly obvious to someone who's not burdened with detailed knowledge of what the code was <i>supposed</i> to do.</p>



<a name=t33></a><h3 class=book>
1.8 To thread or not to thread?
</h3>
<blockquote class="epigraph">
<p class=book>"My poor client's fate now depends on your votes."</p>
<p class=book>Here the speaker sat down in his place,</p>
<p class=book>And directed the Judge to refer to his notes</p>
<p class=book>And briefly to sum up the case.</p>
<blockquote class=book><i>— <i>Lewis Carroll, The Hunting of the Snark</i></i></blockquote>
</blockquote>
<p class=book>Threads don't necessarily provide the best solution to every programming problem. They're not always easier to use, and they don't always result in better performance.</p>
<p class=book>A few problems are really "inherently nonconcurrent," and adding threads will only slow the program down and complicate it. If every step in your program depends directly on the result of the previous step, then using threads probably won't help. Each thread would have to wait for another thread to complete.</p>
<p class=book>The most obvious candidates for threaded coding are new applications that accomplish the following:</p>
<p class=book>1. Perform extensive computation that can be parallelized (or "decomposed") into multiple threads, and which is intended to run on multiprocessor hardware, or</p>
<p class=book>2. Perform substantial I/O which can be overlapped to improve throughput— many threads can wait for different I/O requests at the same time. Distributed server applications are good candidates, since they may have work to do in response to multiple clients, and they must also be prepared for unsolicited I/O over relatively slow network connections.</p>
<p class=book>Most programs have some natural concurrency, even if it is only reading a command from the input device while processing the previous command. Threaded applications are often faster, and usually more responsive, than sequential programs that do the same job. They are generally much easier to develop and maintain than nonthreaded asynchronous applications that do the same job.</p>
<p class=book>So should you use threads? You probably won't find them appropriate for every programming job you approach. But threaded programming is a technique that all software developers should understand.</p>


<a name=t34></a><h3 class=book>
1.9 POSIX thread concepts
</h3>
<blockquote class="epigraph">
<p class=book>"You seem very clever at explaining words, Sir," said Alice. "Would you kindly tell me the meaning of the poem called 'Jabberwocky'?"</p>
<p class=book>"Let's hear it," said Humpty Dumpty. "I can explain all the poems that ever were invented - and a good many that haven't been invented just yet."</p>
<blockquote class=book><i>— <i>Lewis Carroll, Through the Looking-Glass</i></i></blockquote>
</blockquote>

<p class=book>First of all, this book focuses on "POSIX threads." Technically, that means the thread "application programming interfaces" (API) specified by the international formal standard POSIX 1003.1c-1995. This standard was approved by the IEEE in June 1995. A new edition of POSIX 1003.1, called <i>ISO/IEC 9945-1:1996 (ANSI/ IEEE Std 1003.1, 1996 Edition)</i> is available from the IEEE.<sup><a name=r3><a href="#n3" title="
Contact the IEEE at l-800-678-IEEE. 9945-l:1996InfonnatiDnTechnology-PortabteOpera-ting System Interface (POSIX)—Part 1: System Application: Program Interface (API) [C Language], ISBN 1-55937-573-6, order number SH94352.
">[3]</sup></A> This new document includes 1003.1b-1993 (realtime), 1003.1c-1995 (threads), and 1003.1i-1995 (corrections to 1003.1b-1993). Unless you are writing an implementation of the standard, or are extremely curious, you probably don't want to bother buying the POSIX standard. For writing threaded code, you'll find books like this one much more useful, supplemented by the programming documentation for the operating system you're using.</p>
<p class=book>As I explained in the preface, I will use the informal term "Pthreads" to refer to "POSIX 1003.1c-1995." I will use the slightly more formal term "POSIX.1b" to refer to "POSIX 1003.1b-L993" in the text, "POSIX.14" to refer to the POSIX 1003.14 "Multiprocessor Profile," and similar abbreviated notation for other POSIX standards. I'll use the full names where precision is important, for example, to compare POSIX 1003.1-1990 and POSIX 1003.1-1996, and also in section titles and captions that appear in the table of contents.</p>


<a name=t35></a><h3 class=book>
1.9.1 Architectural overview
</h3>
<p class=book>You may remember from Section 1.2 that the three essential aspects of a thread system are execution context, scheduling, and synchronization. When you evaluate any thread system, or compare any two thread systems, start by categorizing the features into capabilities that support execution contexts, scheduling, and synchronization.</p>
<p class=book>With Pthreads, you create an execution context (thread) by calling pthread_ create. Creating a thread also schedules the thread for execution, and it will begin by calling a "thread start function" that you specified. Pthreads allows you to specify scheduling parameters either at the time you create the thread, or later on while the thread is running. A thread normally terminates when it calls pthread_exit, or returns from the thread start function, although we will encounter a few other possibilities later.</p>
<p class=book>The primary Pthreads synchronization model uses <i>mutexes</i> for protection and <i>condition variables</i> for communication. You can also use other synchronization mechanisms such as semaphores, pipes, and message queues. A mutex allows one thread to <i>lock</i> shared data while using it so that other threads cannot accidentally interfere. A condition variable allows a thread to wait for shared data to reach some desired state (such as "queue not empty" or "resource available").</p>


<a name=t36></a><h3 class=book>
1.9.2 Types and interfaces
</h3>
<p class=book>This section briefly outlines the Pthreads data types, and some of the rules for interpreting them. For a full description of the "object" represented by each type and how to create and use those objects in a program, see the appropriate sections later in this book, as shown in Table 1.2.</p>
<TABLE>
<TR>
<TD align = "left" ><b>Type</b></TD>
<TD align = "left" ><b>Section</b></TD>
<TD align = "left" ><b>Description</b></TD>
</TR>
<TR>
<TD align = "left" >pthread_t</TD>
<TD align = "left" >2</TD>
<TD align = "left" >thread identifier</TD>
</TR>
<TR>
<TD align = "left" >pthread_mutex_t</TD>
<TD align = "left" >3.2</TD>
<TD align = "left" >mutex</TD>
</TR>
<TR>
<TD align = "left" >pthread_cond_t</TD>
<TD align = "left" >3.3</TD>
<TD align = "left" >condition variable</TD>
</TR>
<TR>
<TD align = "left" >pthread_key_t</TD>
<TD align = "left" ><i>5.4</i></TD>
<TD align = "left" >"access key" for thread-specific data</TD>
</TR>
<TR>
<TD align = "left" >pthread_attr_t</TD>
<TD align = "left" >5.2.3</TD>
<TD align = "left" >thread attributes object</TD>
</TR>
<TR>
<TD align = "left" >pthread_mutexattr_t</TD>
<TD align = "left" >5.2.1</TD>
<TD align = "left" >mutex attributes object</TD>
</TR>
<TR>
<TD align = "left" >pthread_condattr_t</TD>
<TD align = "left" >5.2.2</TD>
<TD align = "left" >condition variable attributes object</TD>
</TR>
<TR>
<TD align = "left" >pthread_once_t</TD>
<TD></TD>
<TD align = "left" >"one time initialization" control context</TD>
</TR>
</TABLE>
<p class=book><b>TABLE 1.2</b> <i>POSIX threads types</i></p>
<p class=book>AII Pthreads types are "opaque." Portable code cannot make assumptions regarding the representation of these types.</p>
<p class=book>All of the "pthread" types listed in Table 1.2 are considered <i>opaque.</i> There is no public definition of these types' representation, and programmers should never assume anything about the representation. You should use them only in the manner specifically described by the standard. A thread identifier, for example, may be an integer, or a pointer, or a structure, and any code that uses a thread identifier in a way that is not compatible with all of those definitions is incorrect.</p>


<a name=t37></a><h3 class=book>
1.9.3 Checking for errors
</h3>
<p class=book>Pthreads introduces a new way to report errors,without using the <CODE>errno</CODE> variable.</p>
<p class=book>The Pthreads amendment is the first part of POSIX to depart from the ancient UNIX and C language conventions regarding error status. Traditionally, functions that succeed returned a useful value if appropriate, or otherwise indicated success by returning the value 0. On failure, they returned the special value -1, and set the global value <CODE>errno</CODE> to a code specifying the type of error.</p>
<p class=book>The old mechanism has a number of problems, including the fact that it is difficult to create a function that can both report an error <i>and</i> return a useful value of -1. There are even worse problems when you add multiple threads to a process. In traditional UNIX systems, and in the original POSIX.l-1990 standard, <CODE>errno</CODE> was an extern int variable. Since such a variable can have only one value at a time, it can support only a single stream of execution within the process.</p>
<p class=book>Pthreads functions don't set <CODE>errno</CODE> on errors! (But most other POSIX functions do.)</p>
<p class=book>New functions in the Pthreads standard reserve the return value for error status, and <CODE>errno</CODE> is not used. Pthreads functions return the value 0 on success, and include an extra output parameter to specify an address where "useful results" are stored. When a function cannot complete successfully, an error code from the &lt;errno.h&gt; header file is returned instead of 0 as the function value.</p>
<p class=book>Pthreads also provides a per-thread <CODE>errno</CODE>, which supports other code that uses <CODE>errno</CODE>. This means that when one thread calls some function that reports an error using <CODE>errno</CODE>, the value cannot be overwritten, or read, by any other thread— you may go on using <CODE>errno</CODE> just as you always have. But if you're designing new interfaces you should consider following the new Pthreads convention for reporting errors. Setting or reading the per-thread <CODE>errno</CODE> involves more overhead than reading or writing a memory location, or returning a value from a function.</p>
<p class=book>To wait for a thread, for example, and check for an error, you might use code like that shown in the following code example, thread_error.c. The <CODE>pthread_join</CODE> function, used to wait for a thread to terminate, will report an invalid thread identifier by returning the error code ESRCH. An uninitialized <CODE>pthread_t</CODE> is likely to be an invalid thread identifier on most implementations. The result of running this program should be a message such as "error 3: no such process."</p>
<p class=book>In the unlikely event that the uninitialized thread variable has a <CODE>pthread_t</CODE> value that is not invalid, it should be the ID of the initial thread (there are no other threads in this process). In this case, <CODE>pthread_join</CODE> should either fail with EDEADLK, if your implementation of Pthreads detects self-deadlock, or the thread will hang waiting for itself to exit.</p>
<p class=book>■ thread_error.c</p>
<p class=book><CODE>1 #include &lt;pthread.h&gt;</CODE></p>
<p class=book><CODE>2 #include &lt;stdio.h&gt;</CODE></p>
<p class=book><CODE>3 #include &lt;errno.h&gt; 4</CODE></p>
<p class=book><CODE>5 int main (int argc, char *argv[])</CODE></p>
<p class=book><CODE>6 {</CODE></p>
<p class=book><CODE>7 pthread_t thread;</CODE></p>
<p class=book><CODE>8 int status;</CODE></p>
<p class=book><CODE>9</CODE></p>
<p class=book><CODE>10 	/*</CODE></p>
<p class=book><CODE>11	* Attempt to join with an uninitialized thread ID. On most</CODE></p>
<p class=book><CODE>12	* implementations, this will return an ESRCH error code. If</CODE></p>
<p class=book><CODE>13	* the local (and uninitialized) pthread_t happens to be a valid</CODE></p>
<p class=book><CODE>14 	* thread ID, it is almost certainly that of the initial thread,</CODE></p>
<p class=book><CODE>15	* which is running main(). In that case, your Pthreads</CODE></p>
<p class=book><CODE>16	* implementation may either return EDEADLK (self-deadlock),</CODE></p>
<p class=book><CODE>17	* or it may hang. If it hangs, quit and try again. */</CODE></p>
<p class=book><CODE>18	*/</CODE></p>
<p class=book><CODE>19 status = pthread_join (thread, NULL);</CODE></p>
<p class=book><CODE>20 if (status != 0)</CODE></p>
<p class=book><CODE>21 	fprintf (stderr, "error %d: %s\n", status, strerror (status));</CODE> </p>
<p class=book><CODE>22 return status;</CODE></p>
<p class=book><CODE>23 }</CODE></p>
<p class=book>Note that there is no equivalent to the <CODE>perror</CODE> function to format and print an error value returned by the Pthreads interfaces. Instead, use <CODE>strerror</CODE> to get a string description of the error number, and print the string to the file stream <CODE>stderr</CODE>.</p>
<p class=book>To avoid cluttering each function call in the example programs with a block of code to report each error and call abort, I have built two error macros—<CODE>err_abort</CODE> detects a standard Pthreads error, and <CODE>errno_abort</CODE> is used when a value of -1 means that <CODE>errno</CODE> contains an error code. The following header file, called errors.h, shows these macros. The errors.h header file also includes several system header files, which would otherwise be required by most of the example programs—this helps to reduce the size of the examples.</p>
<p class=book>■ <b>errors.h</b></p>
<p class=book><CODE>1 #ifndef _errors_h</CODE></p>
<p class=book><CODE>2 #define _errors_h</CODE></p>
<p class=book><CODE>3</CODE></p>
<p class=book><CODE>4 #include &lt;unistd.h&gt;</CODE></p>
<p class=book><CODE>5 #include &lt;errno.h&gt;</CODE></p>
<p class=book><CODE>6 #include &lt;stdio.h&gt;</CODE></p>
<p class=book><CODE>7 #include &lt;stdlib.h&gt;</CODE></p>
<p class=book><CODE>8 #include &lt;string.h&gt;</CODE> </p>
<p class=book><CODE>9</CODE></p>
<p class=book><CODE>10 /*</CODE></p>
<p class=book><CODE>11 * Define a macro that can be used for diagnostic output from</CODE></p>
<p class=book><CODE>12 * examples. When compiled -DDEBUG, it results in calling printf</CODE></p>
<p class=book><CODE>13 * with the specified argument list. When DEBUG is not defined, it</CODE></p>
<p class=book><CODE>14 * expands to nothing.</CODE></p>
<p class=book><CODE>15 */</CODE></p>
<p class=book><CODE>16 #ifdef DEBUG</CODE></p>
<p class=book><CODE>17 # define DPRINTF(arg) printf arg</CODE></p>
<p class=book><CODE>18 #else</CODE></p>
<p class=book><CODE>19 # define DPRINTF(arg)</CODE></p>
<p class=book><CODE>20 #endif</CODE> </p>
<p class=book><CODE>21</CODE></p>
<p class=book><CODE>22 /*</CODE></p>
<p class=book><CODE>23 * NOTE: the "do {" ... "} while (0);" bracketing around the macros</CODE></p>
<p class=book><CODE>24 * allows the err_abort and errno_abort macros to be used as if they</CODE></p>
<p class=book><CODE>25 * were function calls, even in contexts where a trailing ";" would</CODE></p>
<p class=book><CODE>26 * generate a null statement. For example,</CODE></p>
<p class=book><CODE>27	*</CODE></p>
<p class=book><CODE>28	*	if (status != 0)</CODE></p>
<p class=book><CODE>29	*		err_abort (status, "message");</CODE></p>
<p class=book><CODE>30	*	else</CODE></p>
<p class=book><CODE>31	*		return status;</CODE></p>
<p class=book><CODE>32 *</CODE></p>
<p class=book><CODE>33 * will not compile if err_abort is a macro ending with "}", because</CODE></p>
<p class=book><CODE>34 * C does not expect a ";" to follow the "}". Because C does expect</CODE></p>
<p class=book><CODE>35 * a ";" following the ")" in the do...while construct, err_abort and</CODE></p>
<p class=book><CODE>36 * errno_abort can be used as if they were function calls.</CODE></p>
<p class=book><CODE>37 */</CODE></p>
<p class=book><CODE>38 #define err_abort(code,text) do { \</CODE></p>
<p class=book><CODE>39 	fprintf (stderr, "%s at \"%s\":%d: %s\n", \</CODE></p>
<p class=book><CODE>40 	text, _FILE_, _LINE_, strerror (code)); \</CODE></p>
<p class=book><CODE>41 	abort (); \</CODE></p>
<p class=book><CODE>42 } while (0)</CODE></p>
<p class=book><CODE>43 #define errno_abort(text) do { \</CODE></p>
<p class=book><CODE>44 	fprintf (stderr, "%s at \"%s\":%d: %s\n", \</CODE></p>
<p class=book><CODE>45 	text, _FILE_, _LINE_, strerror (errno)); \</CODE></p>
<p class=book><CODE>46 	abort ( ); \</CODE></p>
<p class=book><CODE>47 } while (0)</CODE> </p>
<p class=book><CODE>48</CODE></p>
<p class=book><CODE>49 #endif</CODE></p>
<p class=book>The one exception to the Pthreads error rules is <CODE>pthread_getspecific</CODE>, which returns the thread-specific data value of a shared "key." Section 5.4 describes thread-specific data in detail, but for now we're just concerned with error reporting. The capability of managing thread-specific data is critical to many applications, and the function has to be as fast as possible, so the pthread_ getspecific function doesn't report errors at all. If the pthread_key_t value is illegal, or if no value has been set in the thread, pthread_getspecific just returns the value NULL.</p>




<a name=t38></a><h3 class=book>
2 Threads
</h3>
<blockquote class="epigraph">
<p class=book><i><b>"lf seven maids with seven mops</b></i></p>
<p class=book><i><b>Swept it for half a year.</b></i></p>
<p class=book><b>D</b><i><b>o you suppose," the Walrus said,</b></i></p>
<p class=book><i><b>"That they could get it clear?"</b></i></p>
<p class=book><i><b>"I doubt it," said the Carpenter,</b></i></p>
<p class=book><i><b>And shed a bitter tear.</b></i></p>
<blockquote class=book><i>— <i>Lewis Carroll, Through the Looking-Glass</i></i></blockquote>
</blockquote>

<p class=book>Threads are (and perhaps this will come as no surprise) the essential basis of the style of programming that I am advocating. Although this chapter focuses on threads, you will never learn everything you need to know about threads by simply skipping to this chapter and reading it. Threads are a critical part of the landscape, but you can't do much with only threads. Nevertheless, one must start somewhere, and here we are.</p>
<p class=book>Section 2.1 describes the programming aspects of creating and managing threads in your program, that is, how to create threads, how they are represented in your program, and the most basic things you can do to them once you've created them.</p>
<p class=book>Section 2.2 describes the life cycle of a thread, from creation through "recycling," taking you through all the scheduling states threads can assume along the way.</p>


<a name=t39></a><h3 class=book>
2.1 Creating and using threads
</h3>
<blockquote class="epigraph">
<p class=book>"A loaf of bread," the Walrus said,</p>
<p class=book>"Is what we chiefly need:</p>
<p class=book>Pepper and vinegar besides</p>
<p class=book>Are very good indeed— </p>
<p class=book>ow, if you're ready, Oysters dear,</p>
<p class=book>We can begin to feed."</p>
<blockquote class=book><i>— <i>Lewis Carroll, Through the Looking-Glass</i></i></blockquote>
</blockquote>
<p class=book><b>pthread_t thread;</b></p>
<p class=book><b>int pthread_equal (pthread_t tl, pthread_t t2);</b> </p>
<p class=book><b>int pthread_create (pthread_t *thread,</b></p>
<p class=book><b>	const pthread_attr_t *attr,</b></p>
<p class=book><b>	void *(*start)(void *), void *arg);</b> </p>
<p class=book><b>pthread_t pthread_self (void);</b> </p>
<p class=book><b>int sched_yield (void);</b> </p>
<p class=book><b>int pthread_exit (void *value_ptr);</b> </p>
<p class=book><b>int pthread_detach (pthread_t thread);</b> </p>
<p class=book><b>int pthread_join (pthread_t thread, void **value_ptr);</b></p>
<p class=book>The introduction covered some of the basics of what a thread is, and what it means to the computer hardware. This section begins where the introduction left off. It explains how a thread is represented in your program, what it means to your program, and some of the operations you can perform on threads. If you haven't read the introduction, this would be a good time to skip back to it. (I'll wait for you here.)</p>
<p class=book>Within your program a thread is represented by a thread identifier, of the opaque type <CODE>pthread_t</CODE>. To create a thread, you must declare a variable of type <CODE>pthread_t</CODE> somewhere in your program. If the identifier is needed only within a function, or if the function won't return until the thread is done, you could declare the identifier with auto storage class. Most of the time, though, the identifier will be stored in a shared (static or extern) variable, or in a structure allocated from the heap.</p>
<p class=book>A Pthreads thread begins by calling some function that you provide. This "thread function" should expect a single argument of type void *, and should return a value of the same type. You create a thread by passing the thread function's address, and the argument value with which you want the function to be called, to <CODE>pthread_create</CODE>.</p>
<p class=book>When you create a thread, <CODE>pthread_create</CODE> returns an identifier, in the pthread_t value referred to by the thread argument, by which your code refers to the new thread. A thread can also get its own identifier using the <CODE>pthread_self</CODE> function. There is no way to find a thread's identifier unless either the creator or the thread itself stores the identifier somewhere. You need to have a thread's identifier to do anything to the thread. If you'll need to know when a thread completes, for example, you must keep the identifier somewhere.</p>
<p class=book>Pthreads provides the pthread_equal function to compare two thread identifiers. You can only test for equality. It doesn't make any sense to ask whether one thread identifier is "greater than" or "less than" another, because there is no ordering between threads. The pthread_equal function returns a nonzero value if the thread identifiers refer to the same thread, and the value 0 if they do not refer to the same thread.</p>
<p class=book>The initial thread (main) is special.</p>
<p class=book>When a C program runs, it begins in a special function named main. In a threaded program, this special stream of execution is called the "initial thread" or sometimes the "main thread." You can do anything within the initial thread that you can do within any other thread. It can determine its own thread identifier by calling pthread_self, for example, or terminate itself by calling pthread_exit. If the initial thread stores its thread identifier somewhere accessible to another thread, that thread can wait for the initial thread to terminate, or detach the initial thread.</p>
<p class=book>The initial thread is special because Pthreads retains traditional UNIX process behavior when the function main returns; that is, the process terminates without allowing other threads to complete. In general, you do not want to do this in a threaded program, but sometimes it can be convenient. In many of the programs in this book, for example, threads are created that have no effect on anything outside the process. It doesn't really matter what those threads are doing, then, if the process goes away. When the process exits, those threads, all their states, and anything they might accomplish, simply "evaporate"—there's no reason to clean up.</p>
<p class=book>Detaching a thread that is still running doesn't affect the thread in any way—it just informs the system that the thread's resources can be reclaimed when the thread eventually terminates.</p>
<p class=book>Although "thread evaporation" is sometimes useful, most of the time your process will outlive the individual threads you create. To be sure that resources used by terminated threads are available to the process, you should always detach each thread you create when you're finished with it. Threads that have terminated but are not detached may retain virtual memory, including their stacks, as well as other system resources. Detaching a thread tells the system that you no longer need that thread, and allows the system to reclaim the resources it has allocated to the thread.</p>
<p class=book>If you create a thread that you will never need to control, you can use an <i>attribute</i> to create the thread so that it is already detached. (We'll get to attributes later, in Section 5.2.3.) If you do not want to wait for a thread that you created, and you know that you will no longer need to control that thread, you can detach it at any time by calling pthread_detach. A thread may detach itself, or any other thread that knows its pthread_t identifier may detach it at any time. If you need to know a thread's return value, or if you need to know when a thread has completed, call pthread_join. The pthread_join function will block the caller until the thread you specify has terminated, and then, optionally, store the terminated thread's return value. Calling pthread_join <i>detaches</i> the specified thread automatically.</p>
<p class=book>As we've seen, threads within a process can execute different instructions, using different stacks, all at the same time. Although the threads execute independently of each other, they always share the same address space and file</p>
<p class=book>descriptors. The shared address space provides an important advantage of the threaded programming model by allowing threads to communicate efficiently.</p>
<p class=book>Some programs may create threads that perform unrelated activities, but most often a set of threads works together toward a common goal. For example, one set of threads may form an assembly line in which each performs some specific task on a shared data stream and then passes the data on to the next thread. A set of threads may form a work crew and divide independent parts of a common task. Or one "manager" thread may take control and divide work among a "crew" of worker threads. You can combine these models in a variety of ways; for example, a work crew might perform some complicated step in a pipeline, such as transforming a slice of an array.</p>
<p class=book>The following program, lifecycle.c, creates a thread. We'll refer to this simple example in the following sections about a thread's life cycle. </p>
<p class=book><b>7-10</b> The thread function, thread_routine, returns a value to satisfy the standard thread function prototype. In this example the thread returns its argument, and the value is always NULL. </p>
<p class=book><b>18-25</b> The program creates a thread by calling pthread_create, and then waits for it by calling pthread_join. You don't need to wait for a thread, but if you don't, you'll need to do something else to make sure the process runs until the thread completes. Returning from main will cause the process to terminate, along with all threads. You could, for example, code the main thread to terminate by calling pthread_exit, which would allow the process to continue until all threads have terminated.</p>
<p class=book><b>26-29</b> When the join completes, the program checks the thread's return value, to be sure that the thread returned the value it was given. The program exits with <b>0</b> (success) if the value is NULL, or with <b>1</b> otherwise.</p>
<p class=book>It is a good idea for all thread functions to return something, even if it is simply NULL. If you omit the return statement, pthread_join will still return some value—whatever happens to be in the place where the thread's start function would have stored a return value (probably a register).</p>
<p class=book>■ <b>lifecycle.c</b></p>
<p class=book><CODE>1 #include &lt;pthread.h&gt;</CODE></p>
<p class=book><CODE>2 #include "errors.h" 3</CODE></p>
<p class=book><CODE>4 /*</CODE></p>
<p class=book><CODE>5 * Thread start routine.</CODE></p>
<p class=book><CODE>6 */</CODE></p>
<p class=book><CODE>7 void *thread_routine (void *arg)</CODE></p>
<p class=book><CODE>8 {</CODE></p>
<p class=book><CODE>9 return arg; 10 }</CODE></p>
<p class=book><CODE>11</CODE></p>
<p class=book><CODE>12 main (int argc, char *argv[])</CODE></p>
<p class=book><CODE>13 {</CODE></p>
<p class=book><CODE>14 pthread_t thread_id;</CODE></p>
<p class=book><CODE>15 void *thread result;</CODE></p>
<p class=book><CODE>16 int status;</CODE></p>
<p class=book><CODE>17</CODE></p>
<p class=book><CODE>18 status = pthread_create (</CODE></p>
<p class=book><CODE>19 &thread_id, NULL, thread_routine, NULL);</CODE></p>
<p class=book><CODE>20 if (status != 0)</CODE></p>
<p class=book><CODE>21 	err_abort (status, "Create thread");</CODE> </p>
<p class=book><CODE>22</CODE></p>
<p class=book><CODE>23 status = pthread_join (thread_id, &thread_result);</CODE></p>
<p class=book><CODE>24 if (status != 0)</CODE></p>
<p class=book><CODE>25 	err_abort (status, "Join thread");</CODE></p>
<p class=book><CODE>26 if (thread_result == NULL)</CODE> </p>
<p class=book><CODE>27 	return 0;</CODE></p>
<p class=book><CODE>28 else</CODE></p>
<p class=book><CODE>29 	return 1;</CODE></p>
<p class=book><CODE>30 }</CODE></p>
<p class=book>If the "joining" thread doesn't care about the return value, or if it knows that the "joinee" (the thread with which it is joining) didn't return a value, then it can pass NULL instead of &retval in the call to <CODE>pthread_join</CODE>. The joinee's return value will be ignored.</p>
<p class=book>When the call to <CODE>pthread_join</CODE> returns, the joinee has been <i>detached</i> and you can't join with it again. In the rare cases where more than one thread might need to know when some particular thread has terminated, the threads should wait on a condition variable instead of calling <CODE>pthread_join</CODE>. The terminating thread would store its return value (or any other information) in some known location, and broadcast the condition variable to wake all threads that might be interested.</p>


<a name=t40></a><h3 class=book>
2.2 The life of a thread
</h3>
<blockquote class="epigraph">
<p class=book>Come, listen, my men, while I tell you again</p>
<p class=book>The five unmistakable marks</p>
<p class=book>By which you may know, wheresoever you go. </p>
<p class=book>The warranted genuine Snarks.</p>
<blockquote class=book><i>— <i>Lewis Carroll, The Hunting of the Snark</i></i></blockquote>
</blockquote>

<p class=book>At any instant, a thread is in one of the four basic states described in Table 2.1. In implementations, you may see additional "states" that distinguish between various reasons for entering the four basic states. Digital UNIX, for example, represents these finer distinctions as "substates," of which each state may have several. Whether they're called "substates" or additional states, "terminated" might be divided into "exited" and "cancelled"; "blocked" might be broken up into "blocked on condition variable," "blocked on mutex," "blocked in read," and so forth.</p>
<TABLE>
<TR>
<TD align = "left" ><b>State</b></TD>
<TD align = "left" ><b>Meaning</b></TD>
</TR>
<TR>
<TD align = "left" >Ready</TD>
<TD align = "left" >The thread is able to run, but is waiting for a processor. It may have just started, or just been unblocked, or preempted by another thread.</TD>
</TR>
<TR>
<TD align = "left" >Running</TD>
<TD align = "left" >The thread is currently running; on a multiprocessor there may be more than one running thread in the process.</TD>
</TR>
<TR>
<TD align = "left" >Blocked</TD>
<TD align = "left" >The thread is not able to run because it is waiting for something; for example, it may be waiting for a condition variable, or waiting to lock a mutex, or waiting for an I/O operation to complete.</TD>
</TR>
<TR>
<TD align = "left" >Terminated</TD>
<TD align = "left" >The thread has terminated by returning from its start function, calling pthread_exit, or having been cancelled and completing all cleanup handlers. It was not detached, and has not yet been joined. Once it is detached or joined, it will be recycled.</TD>
</TR>
</TABLE>
<p class=book><b>TABLE 2.1</b>  <i>Thread states</i></p>
<p class=book>These finer distinctions can be important in debugging and analyzing threaded programs. However, they do not add substantially to the basic understanding of thread scheduling, and we will not deal with them here.</p>
<p class=book>Threads begin in the <i>ready</i> state. When the new thread runs it calls your specified thread start function. It may be preempted by other threads, or block itself to wait for external events any number of times. Eventually it completes and either returns from the thread start function or calls the pthread_exit function. In either case it <i>terminates.</i> If the thread has been <i>detached,</i> it is immediately recycled. (Doesn't that sound nicer than "destroyed"—and most systems reuse the resources to make new threads.) Otherwise the thread remains in the <i>terminated</i> state until joined or detached. Figure 2.1 shows the relationships between these thread states, and the events that cause threads to move from one state to another.</p>


<a name=t41></a><h3 class=book>
2.2.1 Creation
</h3>
<p class=book>The "initial thread" of a process is created when the process is created. In a system that fully supports threaded programming, there's probably no way to execute any code without a thread. A thread is likely to be the only software context that includes the hardware state needed to execute code: registers, program counter, stack pointer, and so forth.</p>
<p class=book>Additional threads are created by explicit calls. The primary way to create threads on a Pthreads system is to call pthread_create. Threads may also be created when the process receives a POSIX signal if the process signal notify mechanism is set to SIGEV_THREAD. Your system may provide additional nonstandard mechanisms to create a thread.</p>
<img border=0 style='spacing 9px;' src="img_4.png">
<p class=book><b>FIGURE 2.1</b> <i>Thread state transitions</i></p>
<p class=book>When a new thread is created, its state is <i>ready.</i> Depending on scheduling constraints, it may remain in that state for a substantial period of time before executing. Section 5.5 contains more information on thread scheduling. Going back to lifecycle.c, the thread running thread_routine becomes <i>ready</i> during main's call to pthread_create, at line 18.</p>
<p class=book>The most important thing to remember about thread creation is that there is no synchronization between the creating thread's return from pthread_create and the scheduling of the new thread. That is, the thread may start before the creating thread returns. The thread may even run to completion and terminate before pthread_create returns. Refer to Section 8.1.1 for more information and warnings about what to expect when you create a thread.</p>


<a name=t42></a><h3 class=book>
2.2.2 Startup
</h3>
<p class=book>Once a thread has been created, it will eventually begin executing machine instructions. The initial sequence of instructions will lead to the execution of the <i>thread start function</i> that you specified to pthread_create. The thread start function is called with the argument value you specified when you created the thread. In lifecycle.c, for example, the thread begins executing user code at function thread_routine, with the formal parameter argument having a value of NULL.</p>
<p class=book>In the initial thread, the thread "start function" (main) is called from outside your program; for example, many UNIX systems link your program with a file called crt0.o, which initializes the process and then calls your main. This is a minor implementation distinction, but it is important to remember because there are a few ways in which the initial thread is different. For one thing, main is called with different arguments than a thread start function: the program's argument array (argc and argv) instead of a single void* argument. For another thing, when a thread start function returns, the thread terminates but other threads continue to run. When the function main returns in the initial thread, the process will be terminated immediately. If you want to terminate the initial thread while allowing other threads in the process to continue running, call pthread_exit instead of returning from main.</p>
<p class=book>Another important difference to remember is that on most systems, the initial thread runs on the default process stack, which can grow to a substantial size. "Thread" stacks may be much more limited on some implementations, and the program will fail with a segmentation fault or bus error if a thread overflows its stack.</p>


<a name=t43></a><h3 class=book>
2.2.3 Running and blocking
</h3>
<p class=book>Like us, threads usually can't stay awake their entire life. Most threads occasionally go to sleep. A thread can go to sleep because it needs a resource that is not available (it becomes "blocked") or because the system reassigned the processor on which it was running (it is "preempted"). A thread spends most of its active life in three states: <i>ready, running,</i> and <i>blocked.</i></p>
<p class=book><i>A</i> thread is <i>ready</i> when it is first created, and whenever it is unblocked so that it is once again eligible to run. <i>Ready</i> threads are waiting for a processor. Also, when a <i>running</i> thread is preempted, for example, if it is <i>timesliced</i> (because it has run too long), the thread immediately becomes <i>ready.</i></p>
<p class=book><i>A</i> thread becomes <i>running</i> when it was <i>ready</i> and a processor selects the thread for execution. Usually this means that some other thread has blocked, or has been preempted by a timeslice—the blocking (or preempted) thread saves its context and restores the context of the next ready thread to replace itself. On a multiprocessor, however, a previously unused processor may execute a readied thread without any other thread blocking.</p>
<p class=book>A thread becomes <i>blocked</i> when it attempts to lock a mutex that is currently locked, when it waits on a condition variable, when it calls sigwait for a signal that is not currently pending, or when it attempts an I/O operation that cannot be immediately completed. A thread may also become blocked for other system operations, such as a page fault.</p>
<p class=book>When a thread is unblocked after a wait for some event, it is made <i>ready</i> again. It may execute immediately, for example, if a processor is available. In lifecycle.c, the main thread blocks at line 23, in pthread_join, to wait for the thread it created to run. If the thread had not already run at this point, it would move from <i>ready</i> to <i>running</i> when main becomes <i>blocked.</i> As the thread runs to completion and returns, the main thread will be unblocked—returning to the <i>ready</i> state. When processor resources are available, either immediately or after the thread becomes <i>terminated,</i> main will again become <i>running,</i> and complete.</p>


<a name=t44></a><h3 class=book>
2.2.4 Termination
</h3>
<p class=book>A thread usually terminates by returning from its start function (the one you pass to the <CODE>pthread_create</CODE> function). The thread shown in lifecycle.c terminates by returning the value NULL, for example. Threads that call <CODE>pthread_exit</CODE> or that are canceled using <CODE>pthread_cancel</CODE> also terminate after calling each cleanup handler that the thread registered by calling <CODE>pthread_cleanup_push</CODE> and that hasn't yet been removed by calling pthread_cleanup_pop. Cleanup handlers are discussed in Section 5.3.3.</p>
<p class=book>Threads may have private "thread-specific data" values (thread-specific data is discussed in Section 5.4). If the thread has any non-NULL thread-specific data values, the associated destructor functions for those keys (if any) are called.</p>
<p class=book>If the thread was already detached it moves immediately to the next section, <i>recycling.</i> Otherwise, the thread becomes <i>terminated.</i> It will remain available for another thread to join with it using <CODE>pthread_join</CODE>. This is analogous to a UNIX process that's terminated but hasn't yet been "reaped" by a wait operation. Sometimes it is called a "zombie" because it still exists even though it is "dead." A zombie may retain most or all of the system resources that it used when running, so it is not a good idea to leave threads in this state for longer than necessary. Whenever you create a thread with which you won't need to join, you should use the <i>detachstate</i> attribute to create it "detached" (see Section 5.2.3).</p>
<p class=book>At a minimum, a terminated thread retains the identification (<CODE>pthread_t</CODE> value) and the <CODE>void*</CODE> return value that was returned from the thread's start function or specified in a call to <CODE>pthread_exit</CODE>. The only external difference between a thread that terminated "normally" by returning or calling <CODE>pthread_exit</CODE>, and one that terminated through cancellation, is that a cancelled thread's return value is always PTHREAD_CANCELLED. (This is why "cancelled" is not considered a distinct thread state.)</p>
<p class=book>If any other thread is waiting to join with the terminating thread, that thread is awakened. It will return from its call to <CODE>pthread_join</CODE> with the appropriate return value. Once <CODE>pthread_join</CODE> has extracted the return value, the terminated thread is detached by <CODE>pthread_join</CODE>, and may be recycled before the call to <CODE>pthread_join</CODE> returns. This means that, among other things, the returned value should never be a stack address associated with the terminated thread's stack— the value at that address could be overwritten by the time the caller could use it. In lifecycle. c, the main thread will return from the <CODE>pthread_join call</CODE> at line 23 with the value NULL.</p>
<p class=book>pthread_join is <i>a</i> convenience, not a rule.</p>
<p class=book>Even when you need a return value from a thread that you create, it is often at least as simple to create the thread detached and devise your own customized return mechanism as it is to use <CODE>pthread_join</CODE>. For example, if you pass information to a worker thread in some form of structure that another thread can find later, you might have the worker thread simply place the result in that same</p>
<p class=book>structure and broadcast a condition variable when done. The Pthreads context for the thread, including the thread identifier, can then be recycled immediately when the thread is done, and you still have the part you really need, the return value, where you can find it easily at any time.</p>
<p class=book>If pthread_join does exactly what you want, then by all means use it. But remember that it is nothing more than a convenience for the simplest and most limited model of communicating a thread's results. If it does not do exactly what you need, build your own return mechanism instead of warping your design to fit the limitations ofpthread_join.</p>


<a name=t45></a><h3 class=book>
2.2.5 Recycling
</h3>
<p class=book>If the thread was created with the <i>detachstate</i> attribute set to PTHREAD_ CREATE_DETACHED (see Section 5.2.3), or if the thread or some other thread has already called pthread_detach for the thread's identifier, then the thread is immediately recycled when it becomes terminated.</p>
<p class=book>If the thread has not been detached when it terminates, it remains in the <i>terminated</i> state until the thread's pthread_t identifier is passed to pthread_detach or pthread_join. When either function returns, the thread cannot be accessed again. In lifecycle.c, for example, the thread that had run thread_routine will be recycled by the time the main thread returns from the pthread_join call at line 23.</p>
<p class=book>Recycling releases any system or process resources that weren't released at termination. That includes the storage used for the thread's return value, the stack, memory used to store register state, and so forth. Some of these resources may have been released at termination; it is important to remember that none of it should be accessed from any other thread after termination. For example, if a thread passes a pointer to its stack storage to another thread through shared data, you should treat that information as obsolete from the time the thread that owns the stack terminates.</p>




<a name=t46></a><h3 class=book>
3 Synchronization
</h3>
<blockquote class="epigraph">
<p class=book>"That's right!" said the Tiger-lily. "The daisies are worst of all. When one speaks, they all begin together, and it's enough to make one wither to hear the way they go on!"</p>
<blockquote class=book><i>— <i>Lewis Carroll, Through the Looking-Glass</i></i></blockquote>
</blockquote>

<p class=book>To write a program of any complexity using threads, you'll need to share data between threads, or cause various actions to be performed in some coherent order across multiple threads. To do this, you need to <i>synchronize</i> the activity of your threads.</p>
<p class=book>Section 3.1 describes a few of the basic terms we'll be using to talk about thread synchronization: <i>critical section</i> and <i>invariant.</i></p>
<p class=book>Section 3.2 describes the basic Pthreads synchronization mechanism, the mutex.</p>
<p class=book>Section 3.3 describes the <i>condition variable,</i> a mechanism that your code can use to communicate changes to the state of <i>invariants</i> protected by a mutex.</p>
<p class=book>Section 3.4 completes this chapter on synchronization with some important information about threads and how they view the computer's memory.</p>


<a name=t47></a><h3 class=book>
3.1 Invariants, critical sections,and predicates
</h3>
<blockquote class="epigraph">
<p class=book>"I know what you're thinking about,"</p>
<p class=book>said Tweedledum; "but it isn't so, nohow."</p>
<p class=book>"Contrariwise," continued Tweedledee,</p>
<p class=book>"if it was so, it might be; and if it were so, it would be;</p>
<p class=book>but as it isn't, it ain't. That's logic."</p>
<blockquote class=book><i>— <i>Lewis Carroll, Through the Looking-Glass</i></i></blockquote>
</blockquote>
<p class=book><i>Invariants</i> are assumptions made by a program, especially assumptions about the relationships between sets of variables. When you build a queue package, for example, you need certain data. Each queue has a queue header, which is a pointer to the first queued data element. Each data element includes a pointer to the next data element. But the data isn't all that's important—your queue package relies on relationships between that data. The queue header, for example, must either be NULL or contain a pointer to the first queued data element. Each data element must contain a pointer to the next data element, or NULL if it is the last. Those relationships are the <i>invariants</i> of your queue package.</p>
<p class=book>It is hard to write a program that doesn't have invariants, though many of them are subtle. When a program encounters a broken invariant, for example, if it dereferences a queue header containing a pointer to something that is not a valid data element, the program will probably produce incorrect results or fail immediately.</p>
<p class=book><i>Critical sections</i> (also sometimes called "serial regions") are areas of code that affect a shared state. Since most programmers are trained to think about program <i>functions</i> instead of program <i>data,</i> you may well find it easier to recognize critical sections than data invariants. However, a critical section can almost always be translated into a data invariant, and vice versa. When you remove an element from a queue, for example, you can see the code performing the removal as a critical section, or you can see the state of the queue as an invariant. Which you see first may depend on how you're thinking about that aspect of your design.</p>
<p class=book>Most invariants can be "broken," and are routinely broken, during isolated areas of code. The trick is to be sure that broken invariants are always repaired before "unsuspecting" code can encounter them. That is a large part of what "synchronization" is all about in an asynchronous program. Synchronization protects your program from broken invariants. If your code locks a mutex whenever it must (temporarily) break an invariant, then other threads that rely on the invariant, and which also lock the mutex, will be delayed until the mutex is unlocked— when the invariant has been restored.</p>
<p class=book>Synchronization is voluntary, and the participants must cooperate for the system to work. The programmers must agree not to fight for (or against) possession of the bailing bucket. The bucket itself does not somehow magically ensure that one and only one programmer bails at any time. Rather, the bucket is a reliable shared token that, if used properly, can allow the programmers to manage their resources effectively.</p>
<p class=book>"Predicates" are logical expressions that describe the state of invariants needed by your code. In English, predicates can be expressed as statements like "the queue is empty" or "the resource is available." A predicate may be a boolean variable with a TRUE or FALSE value, or it may be the result of testing whether a pointer is NULL. A predicate may also be a more complicated expression, such as determining whether a counter is greater than some threshold. A predicate may even be a value returned from some function. For example, you might call select or poll to determine whether a file is ready for input.</p>


<a name=t48></a><h3 class=book>
3.2 Mutexes
</h3>
<blockquote class="epigraph">
<p class=book><i><b>"How are you getting on?" said the Cat, as soon as there was mouth enough for it to speak with. Alice waited till the eyes appeared, and then nodded. "It's no use speaking to it,"she thought, "till its ears have come, or at least one of them."</b></i> </p>
<blockquote class=book><i>— <i>Lewis Carroll, Alice's Adventures in Wonderland</i></i></blockquote>
</blockquote>

<p class=book>Most threaded programs need to share some data between threads. There may be trouble if two threads try to access shared data at the same time, because one thread may be in the midst of modifying some data invariant while another acts on the data as if it were consistent. This section is all about protecting the program from that sort of trouble.</p>
<p class=book>The most common and general way to synchronize between threads is to ensure that all memory accesses to the same (or related) data are "mutually exclusive." That means that only one thread is allowed to write at a time—others must wait for their turn. Pthreads provides mutual exclusion using a special form of Edsger Dijkstra's semaphore <i>[Dijkstra, 1968a],</i> called a <i>mutex.</i> The word <i>mutex</i> is a clever combination of "mut" from the word "mutual" and "ex" from the word "exclusion."</p>
<p class=book>Experience has shown that it is easier to use mutexes correctly than it is to use other synchronization models such as a more general semaphore. It is also easy to build any synchronization models using mutexes in combination with condition variables (we'll meet them at the next corner, in Section 3.3). Mutexes are simple, flexible, and can be implemented efficiently.</p>
<p class=book>The programmers' bailing bucket is something like a mutex (Figure 3.1). Both are "tokens" that can be handed around, and used to preserve the integrity of the concurrent system. The bucket can be thought of as protecting the bailing critical section—each programmer accepts the responsibility of bailing while holding the bucket, and of avoiding interference with the current bailer while not holding the bucket. Or, the bucket can be thought of as protecting the invariant that water can be removed by only one programmer at any time.</p>
<p class=book>Synchronization isn't important just when you modify data. You also need synchronization when a thread needs to read data that was written by another thread, if the order in which the data was written matters. As we'll see a little later, in Section 3.4, many hardware systems don't guarantee that one processor will see shared memory accesses in the same order as another processor without a "nudge" from software.</p>
<img border=0 style='spacing 9px;' src="img_5.png">
<br>
<p class=book><b>FIGURE 3.1</b> <i>Mutex analogy</i></p>
<p class=book>Consider, for example, a thread that writes new data to an element in an array, and then updates a max_index variable to indicate that the array element is valid. Now consider another thread, running simultaneously on another processor, that steps through the array performing some computation on each valid element. If the second thread "sees" the new value of max_index before it sees the new value of the array element, the computation would be incorrect. This may seem irrational, but memory systems that work this way can be substantially faster than memory systems that guarantee predictable ordering of memory accesses. A mutex is one general solution to this sort of problem. If each thread locks a mutex around the section of code that's using shared data, only one thread will be able to enter the section at a time.</p>
<p class=book>Figure 3.2 shows a timing diagram of three threads sharing a mutex. Sections of the lines that are above the rounded box labeled "mutex" show where the associated thread does not own the mutex. Sections of the lines that are below the center line of the box show where the associated thread owns the mutex, and sections of the lines hovering above the center line show where the thread is waiting to own the mutex.</p>
<p class=book>Initially, the mutex is unlocked. Thread 1 locks the mutex and, because there is no contention, it succeeds immediately—thread l's line moves below the center</p>
<img border=0 style='spacing 9px;' src="img_6.png">
<p class=book><b>FIGURE 3.2</b> <i>Mutex operation</i></p>
<p class=book>of the box. Thread 2 then attempts to lock the mutex and, because the mutex is already locked, thread 2 blocks, its line remaining above the center line. Thread 1 unlocks the mutex, unblocking thread 2, which then succeeds in locking the mutex. Slightly later, thread 3 attempts to lock the mutex, and blocks. Thread 1 calls pthread_mutex_trylock to try to lock the mutex and, because the mutex is locked, returns immediately with EBUSY status. Thread 2 unlocks the mutex, which unblocks thread 3 so that it can lock the mutex. Finally, thread 3 unlocks the mutex to complete our example.</p>


<a name=t49></a><h3 class=book>
3.2.1 Creating and destroying a mutex
</h3>
<p class=book><b>pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER; int pthread_mutex_init (</b></p>
<p class=book><b>pthread_mutex_t *mutex, pthread_mutexattr_t *attr); int pthread_mutex_destroy (pthread_mutex_t *mutex);</b></p>
<p class=book>A mutex is represented in your program by a variable of type pthread_mutex_t. You should never make a copy of a mutex, because the result of using a copied mutex is undefined. You can, however, freely copy a pointer to a mutex so that various functions and threads can use it for synchronization.</p>
<br>
<p class=book>Most of the time you'll probably declare mutexes using extern or static storage class, at "file scope," that is, outside of any function. They should have "normal" (extern) storage class if they are used by other files, or static storage class if used only within the file that declares the variable. When you declare a static mutex that has default attributes, you should use the PTHREAD_MUTEX_ INITIALIZER macro, as shown in the mutex_static.c program shown next. (You can build and run this program, but don't expect anything interesting to happen, since main is empty.)</p>
<p class=book>■ <b>mutex_static.c</b></p>
<p class=book><CODE>1 #include &lt;pthread.h&gt;</CODE></p>
<p class=book><CODE>2 #include "errors.h"</CODE></p>
<p class=book><CODE>3</CODE></p>
<p class=book><CODE>4 /*</CODE></p>
<p class=book><CODE>5 * Declare a structure, with a mutex, statically initialized. This</CODE></p>
<p class=book><CODE>6 * is the same as using pthread_mutex_init, with the default</CODE></p>
<p class=book><CODE>7 * attributes.</CODE></p>
<p class=book><CODE>8 */</CODE></p>
<p class=book><CODE>9 typedef struct my_struct_tag {</CODE></p>
<p class=book><CODE>10 pthread_mutex_t  mutex; /* Protects access to value */</CODE></p>
<p class=book><CODE>11 int       value; /* Access protected by mutex */</CODE></p>
<p class=book><CODE>12 } my_struct_t; 13</CODE></p>
<p class=book><CODE>14 my_struct_t data = {PTHREAD_MUTEX_INITIALIZER, 0}<b>;</b></CODE></p>
<p class=book><CODE>15</CODE></p>
<p class=book><CODE>16 int main (int argc, char *argv[])</CODE></p>
<p class=book><CODE>17 {</CODE></p>
<p class=book><CODE>18 return 0;</CODE></p>
<p class=book><CODE>19 }</CODE></p>
<p class=book>Often you cannot initialize a mutex statically, for example, when you use malloc to create a structure that contains a mutex. Then you will need to call pthread_mutex_init to initialize the mutex dynamically, as shown in mutex_ dynamic.c, the next program. You can also dynamically initialize a mutex that you declare statically—but you must ensure that each mutex is initialized before it is used, and that each is initialized only once. You may initialize it before creating any threads, for example, or by calling pthread_once (Section 5.1). Also, if you need to initialize a mutex with nondefault attributes, you must use dynamic initialization (see Section 5.2.1).</p>
<p class=book>■ <b>mutex_dynamic.c</b></p>
<p class=book><CODE>1 #include &lt;pthread.h&gt;</CODE></p>
<p class=book><CODE>2 #include "errors.h" 3</CODE></p>
<p class=book><CODE>4 /*</CODE></p>
<p class=book><CODE>5 * Define a structure, with a mutex.</CODE></p>
<p class=book><CODE>6 */</CODE></p>
<p class=book><CODE>7 typedef struct my_struct_tag {</CODE></p>
<p class=book><CODE>8 pthread_mutex_t mutex; /* Protects access to value */</CODE></p>
<p class=book><CODE>9 int value; /* Access protected by mutex */ 10 } my_struct_t;</CODE></p>
<p class=book><CODE>11</CODE></p>
<p class=book><CODE>12 int main (int argc, char *argv[])</CODE></p>
<p class=book><CODE>13 {</CODE></p>
<p class=book><CODE>14 my_struct_t *data;</CODE></p>
<p class=book><CODE>15 int status;</CODE></p>
<p class=book><CODE>16</CODE></p>
<p class=book><CODE>17 data = malloc (sizeof (my_struct_t));</CODE></p>
<p class=book><CODE>18 if (data == NULL)</CODE></p>
<p class=book><CODE>19 errno_abort ("Allocate structure");</CODE></p>
<p class=book><CODE>20 status = pthread_mutex_init (&data-&gt;mutex, NULL);</CODE></p>
<p class=book><CODE>21 if (status != 0)</CODE></p>
<p class=book><CODE>22 err_abort (status, "Init mutex");</CODE></p>
<p class=book><CODE>23 status = pthread_mutex_destroy (&data-&gt;mutex);</CODE></p>
<p class=book><CODE>24 if (status != 0)</CODE></p>
<p class=book><CODE>25 err_abort (status, "Destroy mutex");</CODE></p>
<p class=book><CODE>26 (void)free (data);</CODE></p>
<p class=book><CODE>27 return status;</CODE></p>
<p class=book><CODE>28 }</CODE></p>
<p class=book>It is a good idea to associate a mutex clearly with the data it protects, if possible, by keeping the definition of the mutex and data together. In mutex_static.c and mutex_dynamic.c for example, the mutex and the data it protects are defined in the same structure, and line comments document the association.</p>
<p class=book>When you no longer need a mutex that you dynamically initialized by calling pthread_mutex_init, you should destroy the mutex by calling pthread_mutex_ destroy. You do not need to destroy a mutex that was statically initialized using</p>
<p class=book>the PTHREAD_MUTEX_INITIALIZER macro.</p>
<p class=book>You can destroy a mutex as soon as you are sure no threads are blocked on the mutex.</p>
<p class=book>It is safe to destroy a mutex when you know that no threads can be blocked on the mutex, and no additional threads will try to lock the mutex. The best way to know this is usually within a thread that has just unlocked the mutex, when program logic ensures that no threads will try to lock the mutex later. When a thread locks a mutex within some heap data structure to remove the structure from a list and free the storage, for example, it is safe (and a good idea) to unlock and destroy the mutex before freeing the storage that the mutex occupies.</p>


<a name=t50></a><h3 class=book>
3.2.2 Locking and unlocking a mutex
</h3>

<p class=book><b>int pthread_mutex_lock (pthread_mutex_t *mutex);</b></p>
<p class=book><b>int pthread_mutex_trylock (pthread_mutex_t *mutex);</b></p>
<p class=book><b>int pthread_mutex_unlock (pthread_mutex_t *mutex);</b></p>
<p class=book>In the simplest case, using a mutex is easy. You lock the mutex by calling either pthread_mutex_lock or pthread_mutex_trylock, do something with the shared data, and then unlock the mutex by calling pthread_mutex_unlock. To make sure that a thread can read consistent values for a series of variables, you need to lock your mutex around any section of code that reads or writes those variables.</p>
<p class=book>You cannot lock a mutex when the calling thread already has that mutex locked. The result of attempting to do so may be an error return, or it may be a self-deadlock, with the unfortunate thread waiting forever for itself to unlock the mutex. (If you have access to a system supporting the UNLX98 thread extensions, you can create mutexes of various types, including recursive mutexes, which allow a thread to relock a mutex it already owns. The mutex type attribute is discussed in Section 10.1.2.)</p>
<p class=book>The following program, alarm_mutex.c, is an improved version of alarm_ thread.c (from Chapter 1). It lines up multiple alarm requests in a single "alarm server" thread.</p>
<p class=book><b>12-17</b> The alarm_t structure now contains an absolute time, as a standard UNIX time_t, which is the number of seconds from the UNIX Epoch (Jan 1 1970 00:00) to the expiration time. This is necessary so that alarm_t structures can be sorted by "expiration time" instead of merely by the requested number of seconds. In addition, there is a link member to connect the list of alarms.</p>
<p class=book><b>19-20</b> The alarm_mutex mutex coordinates access to the list head for alarm requests, called alarm_list. The mutex is statically initialized using default attributes, with the PTHREAD_MUTEX_INITIALIZER macro. The list head is initialized to NULL, or empty.</p>
<p class=book>■ <b>alarm_mutex.c</b> <b>part 1 definitions</b></p>
<p class=book><CODE>1 #include &lt;pthread.h&gt;</CODE></p>
<p class=book><CODE>2 #include &lt;time.h&gt;</CODE></p>
<p class=book><CODE>3 #include "errors.h" 4</CODE></p>
<p class=book><CODE>5 /*</CODE></p>
<p class=book><CODE>6 * The "alarm" structure now contains the time_t (time since the</CODE></p>
<p class=book><CODE>7 * Epoch, in seconds) for each alarm, so that they can be</CODE></p>
<p class=book><CODE>8 * sorted. Storing the requested number of seconds would not be</CODE></p>
<p class=book><CODE>9 * enough, since the "alarm thread" cannot tell how long it has</CODE></p>
<p class=book><CODE>10 * been on the list.</CODE></p>
<p class=book><CODE>11 */</CODE></p>
<p class=book><CODE>12 typedef struct alarm_tag {</CODE></p>
<p class=book><CODE>13 struct alarm_tag *link;</CODE></p>
<p class=book><CODE>14 int seconds;</CODE></p>
<p class=book><CODE>15 time_t time; /* seconds from EPOCH */</CODE></p>
<p class=book><CODE>16 char message[64];</CODE></p>
<p class=book><CODE>17 } alarm_t;</CODE></p>
<p class=book><CODE>18</CODE></p>
<p class=book><CODE>19 pthread_mutex_t alarm_mutex = PTHREAD_MUTEX_INITIALIZER;</CODE></p>
<p class=book><CODE>20 alarm_t *alarm_list = NULL;</CODE></p>
<p class=book>The code for the alarm_thread function follows. This function is run as a thread, and processes each alarm request in order from the list alarm_list. The thread never terminates—when main returns, the thread simply "evaporates." The only consequence of this is that any remaining alarms will not be delivered— the thread maintains no state that can be seen outside the process.</p>
<p class=book>If you would prefer that the program process all outstanding alarm requests before exiting, you can easily modify the program to accomplish this. The main thread must notify alarm_thread, by some means, that it should terminate when it finds the alarm_list empty. You could, for example, have main set a new global variable alarm_done and then terminate using pthread_exit rather than exit. When alarm_thread finds alarm_list empty and alarm_done set, it would immediately call pthread_exit rather than waiting for a new entry.</p>
<p class=book><b>29-30</b> If there are no alarms on the list, alarm_thread needs to block itself, with the mutex unlocked, at least for a short time, so that main will be able to add a new alarm. It does this by setting sleep_time to one second.</p>
<p class=book><b>31-42</b> If an alarm is found, it is removed from the list. The current time is retrieved by calling the time function, and it is compared to the requested time for the alarm. If the alarm has already expired, then alarm_thread will set sleep_time to 0. If the alarm has not expired, alarm_thread computes the difference between the current time and the alarm expiration time, and sets sleep_time to that number of seconds.</p>
<p class=book><b>52-58</b> The mutex is always unlocked before sleeping or yielding. If the mutex remained locked, then main would be unable to insert a new alarm on the list. That would make the program behave synchronously—the user would have to wait until the alarm expired before doing anything else. (The user would be able to enter a single command, but would not receive another prompt until the next alarm expired.) Calling sleep blocks alarm_thread for the required period of time—it cannot run until the timer expires.</p>
<p class=book>Calling sched_yield instead is slightly different. We'll describe sched_yield in detail later (in Section 5.5.2)—for now, just remember that calling sched_yield will yield the processor to a thread that is ready to run, but will return immediately if there are no <i>ready</i> threads. In this case, it means that the main thread will be allowed to process a user command if there's input waiting—but if the user hasn't entered a command, sched_yield will return immediately.</p>
<p class=book><b>64-67</b> If the alarm pointer is not NULL, that is, if an alarm was processed from alarm_list, the function prints a message indicating that the alarm has expired. After printing the message, it frees the alarm structure. The thread is now ready to process another alarm.</p>
<p class=book>■ <b>alarm_mutex.c part 2 alarm_thread</b></p>
<p class=book><CODE>1 /*</CODE></p>
<p class=book><CODE>2 * The alarm thread's start routine.</CODE></p>
<p class=book><CODE>3 */</CODE></p>
<p class=book><CODE>4 void *alarm_thread (void *arg)</CODE></p>
<p class=book><CODE>5 {</CODE></p>
<p class=book><CODE>6 alarm_t *alarm;</CODE></p>
<p class=book><CODE>7 int sleep_time;</CODE></p>
<p class=book><CODE>8 time_t now;</CODE></p>
<p class=book><CODE>9 int status; 10</CODE></p>
<p class=book><CODE>11 /*</CODE></p>
<p class=book><CODE>12 * Loop forever, processing commands. The alarm thread will</CODE></p>
<p class=book><CODE>13 * be disintegrated when the process exits.</CODE></p>
<p class=book><CODE>14 */</CODE></p>
<p class=book><CODE>15 while (1) {</CODE></p>
<p class=book><CODE>16 status = pthread_mutex_lock (&alarm_mutex);</CODE></p>
<p class=book><CODE>17 if (status != 0)</CODE></p>
<p class=book><CODE>18 err_abort (status, "Lock mutex");</CODE></p>
<p class=book><CODE>19 alarm = alarm_list; 20</CODE></p>
<p class=book><CODE>21 /*</CODE></p>
<p class=book><CODE>22 * If the alarm list is empty, wait for one second. This</CODE></p>
<p class=book><CODE>23 * allows the main thread to run, and read another</CODE></p>
<p class=book><CODE>24 * command. If the list is not empty, remove the first</CODE></p>
<p class=book><CODE>25 * item. Compute the number of seconds to wait — if the</CODE></p>
<p class=book><CODE>26 * result is less than 0 (the time has passed), then set</CODE></p>
<p class=book><CODE>27 * the sleep_time to 0.</CODE></p>
<p class=book><CODE>28 */</CODE></p>
<p class=book><CODE>29 if (alarm == NULL)</CODE></p>
<p class=book><CODE>30 sleep_time = 1;</CODE></p>
<p class=book><CODE>31 else {</CODE></p>
<p class=book><CODE>32 alarm_list = alarm-&gt;link;</CODE></p>
<p class=book><CODE>33 now = time (NULL);</CODE></p>
<p class=book><CODE>34 if (alarm-&gt;time &lt;= now)</CODE></p>
<p class=book><CODE>35 	sleep_time = 0;</CODE></p>
<p class=book><CODE>36 else</CODE></p>
<p class=book><CODE>37 	sleep_time = alarm-&gt;time - now;</CODE></p>
<p class=book><CODE>38 #ifdef DEBUG</CODE></p>
<p class=book><CODE>39 printf ("[waiting: %d(%d)\"%s\"]\n", alarm-&gt;time,</CODE></p>
<p class=book><CODE>40 sleep_time, alarm-&gt;message);</CODE></p>
<p class=book><CODE>41 #endif</CODE></p>
<p class=book><CODE>42 }</CODE></p>
<p class=book><CODE>43</CODE></p>
<p class=book><CODE>44 /*</CODE></p>
<p class=book><CODE>45 * Unlock the mutex before waiting, so that the main</CODE></p>
<p class=book><CODE>46 * thread can lock it to insert a new alarm request. If</CODE></p>
<p class=book><CODE>47 * the sleep_time is 0, then call sched_yield, giving</CODE></p>
<p class=book><CODE>48 * the main thread a chance to run if it has been</CODE></p>
<p class=book><CODE>49 * readied by user input, without delaying the message</CODE></p>
<p class=book><CODE>50 * if there's no input.</CODE></p>
<p class=book><CODE>51 */</CODE></p>
<p class=book><CODE>52 status = pthread_mutex_unlock (&alarm_mutex);</CODE></p>
<p class=book><CODE>53 if (status != 0)</CODE></p>
<p class=book><CODE>54 	err_abort (status, "Unlock mutex");</CODE></p>
<p class=book><CODE>55 if (sleep_time &gt; 0)</CODE></p>
<p class=book><CODE>56 	sleep (sleep_time);</CODE></p>
<p class=book><CODE>57 else</CODE></p>
<p class=book><CODE>58 	sched_yield ();</CODE> </p>
<p class=book><CODE>59</CODE></p>
<p class=book><CODE>60 /*</CODE></p>
<p class=book><CODE>61 * If a timer expired, print the message and free the</CODE></p>
<p class=book><CODE>62 * structure.</CODE></p>
<p class=book><CODE>63 */</CODE></p>
<p class=book><CODE>64 if (alarm != NULL) {</CODE></p>
<p class=book><CODE>65 	printf ("(%d) %s\n", alarm-&gt;seconds, alarm-&gt;message);</CODE></p>
<p class=book><CODE>66 	free (alarm);</CODE></p>
<p class=book><CODE>67 }</CODE></p>
<p class=book><CODE>68 }</CODE></p>
<p class=book><CODE>69 }</CODE></p>
<p class=book>And finally, the code for the main program for alarm_mutex.c. The basic structure is the same as all of the other versions of the alarm program that we've developed—a loop, reading simple commands from stdin and processing each in turn. This time, instead of waiting synchronously as in alarm.c, or creating a new asynchronous entity to process each alarm command as in alarm_fork.c and alarm_thread.c, each request is queued to a server thread, alarm_thread. As soon as main has queued the request, it is free to read the next command. </p>
<p class=book><b>8-11</b> Create the server thread that will process all alarm requests. Although we don't use it, the thread's ID is returned in local variable thread. </p>
<p class=book><b>13-28</b> Read and process a command, much as in any of the other versions of our alarm program. As in alarm_thread.c, the data is stored in a heap structure allocated by malloc.</p>
<p class=book><b>30-32</b> The program needs to add the alarm request to alarm_list, which is shared by both alarm_thread and main. So we start by locking the mutex that synchronizes access to the shared data, alarm_mutex. </p>
<p class=book><b>33</b> Because alarm_thread processes queued requests, serially, it has no way of knowing how much time has elapsed between reading the command and processing it. Therefore, the alarm structure includes the absolute time of the alarm expiration, which we calculate by adding the alarm interval, in seconds, to the</p>
<p class=book>current number of seconds since the UNIX Epoch, as returned by the time function.</p>
<p class=book><b>39-49</b> The alarms are sorted in order of expiration time on the alarm_list queue. The insertion code searches the queue until it finds the first entry with a time greater than or equal to the new alarm's time. The new entry is inserted preceding the located entry. Because alarm_list is a simple linked list, the traversal maintains a current entry pointer (this) and a pointer to the previous entry's link member, or to the alarm_list head pointer (last).</p>
<p class=book><b>56-59</b> If no alarm with a time greater than or equal to the new alarm's time is found, then the new alarm is inserted at the end of the list. That is, if the alarm pointer is NULL on exit from the search loop (the last entry on the list always has a link pointer of NULL), the previous entry (or queue head) is made to point to the new entry.</p>
<p class=book>■ <b>alarm_mutex.c</b> <b>part 3 main</b></p>
<p class=book><CODE>1 int main (int argc, char *argv[])</CODE></p>
<p class=book><CODE>2 {</CODE></p>
<p class=book><CODE>3 int status;</CODE></p>
<p class=book><CODE>4 char line[128];</CODE></p>
<p class=book><CODE>5 alarm_t *alarm, **last, *next;</CODE></p>
<p class=book><CODE>6 pthread_t thread;</CODE></p>
<p class=book><CODE>7</CODE></p>
<p class=book><CODE>8 status = pthread_create (</CODE></p>
<p class=book><CODE>9 &thread, NULL, alarm_thread, NULL);</CODE></p>
<p class=book><CODE>10 if (status != 0)</CODE></p>
<p class=book><CODE>11 err_abort (status, "Create alarm thread");</CODE></p>
<p class=book><CODE>12 while (1) {</CODE></p>
<p class=book><CODE>13 	printf ("alarm&gt; ");</CODE></p>
<p class=book><CODE>14 	if (fgets (line, sizeof (line), stdin) == NULL) exit (0);</CODE></p>
<p class=book><CODE>15 	if (strlen (line) &lt;= 1) continue;</CODE></p>
<p class=book><CODE>16 	alarm = (alarm_t*)malloc (sizeof (alarm_t));</CODE></p>
<p class=book><CODE>17 	if (alarm == NULL)</CODE></p>
<p class=book><CODE>18 		errno_abort ("Allocate alarm");</CODE> </p>
<p class=book><CODE>19</CODE></p>
<p class=book><CODE>20 /*</CODE></p>
<p class=book><CODE>21 * Parse input line into seconds (%d) and a message</CODE></p>
<p class=book><CODE>22 * (%64[^\n]), consisting of up to 64 characters</CODE></p>
<p class=book><CODE>23 * separated from the seconds by whitespace.</CODE></p>
<p class=book><CODE>24 */</CODE></p>
<p class=book><CODE>25 	if (sscanf (line, "%d %64[^\n]",</CODE></p>
<p class=book><CODE>26 		&alarm-&gt;seconds, alarm-&gt;message) &lt; 2) {</CODE></p>
<p class=book><CODE>27 		fprintf (stderr, "Bad command\n");</CODE></p>
<p class=book><CODE>28 		free (alarm);</CODE></p>
<p class=book><CODE>29 	} else {</CODE></p>
<p class=book><CODE>30 		status = pthread_mutex_lock (&alarm_mutex);</CODE></p>
<p class=book><CODE>31 		if (status != 0)</CODE></p>
<p class=book><CODE>32 			err_abort (status, "Lock mutex");</CODE></p>
<p class=book><CODE>33 		alarm-&gt;time = time (NULL) + alarm-&gt;seconds;</CODE> </p>
<p class=book><CODE>34</CODE></p>
<p class=book><CODE>35 /*</CODE></p>
<p class=book><CODE>36 * Insert the new alarm into the list of alarms,</CODE></p>
<p class=book><CODE>37 * sorted by expiration time.</CODE></p>
<p class=book><CODE>38 */</CODE></p>
<p class=book><CODE>39 		last = &alarm_list;</CODE></p>
<p class=book><CODE>40 		next = *last;</CODE></p>
<p class=book><CODE>41 		while (next != NULL) {</CODE></p>
<p class=book><CODE>42 			if (next-&gt;time &gt;= alarm-&gt;time) {</CODE></p>
<p class=book><CODE>43 				alarm-&gt;link = next;</CODE></p>
<p class=book><CODE>44 				*last = alarm;</CODE></p>
<p class=book><CODE>45 				break;</CODE></p>
<p class=book><CODE>46 			}</CODE></p>
<p class=book><CODE>47 			last = &next-&gt;link;</CODE></p>
<p class=book><CODE>48 			next = next-&gt;link;</CODE></p>
<p class=book><CODE>49 		}</CODE></p>
<p class=book><CODE>50 /*</CODE></p>
<p class=book><CODE>51 * If we reached the end of the list, insert the new</CODE></p>
<p class=book><CODE>52 * alarm there, ("next" is NULL, and "last" points</CODE></p>
<p class=book><CODE>53 * to the link field of the last item, or to the</CODE></p>
<p class=book><CODE>54 * list header).</CODE></p>
<p class=book><CODE>55 */</CODE></p>
<p class=book><CODE>56 		if (next == NULL) {</CODE></p>
<p class=book><CODE>57 			*last = alarm;</CODE></p>
<p class=book><CODE>58 			alarm-&gt;link = NULL;</CODE></p>
<p class=book><CODE>59 		}</CODE></p>
<p class=book><CODE>60 #ifdef DEBUG</CODE></p>
<p class=book><CODE>61 		printf ("[list: ");</CODE></p>
<p class=book><CODE>62 		for (next = alarm_list; next != NULL; next = next-&gt;link)</CODE></p>
<p class=book><CODE>63 			printf ("%d(%d)[\"%s\"] ", next-&gt;time,</CODE></p>
<p class=book><CODE>64 		next-&gt;time - time (NULL), next-&gt;message);</CODE></p>
<p class=book><CODE>65 		printf ("]\n");</CODE></p>
<p class=book><CODE>66 #endif</CODE></p>
<p class=book><CODE>67 		status = pthread_mutex_unlock (&alarm_mutex);</CODE></p>
<p class=book><CODE>68 		if (status != 0)</CODE></p>
<p class=book><CODE>69 			err_abort (status, "Unlock mutex");</CODE></p>
<p class=book><CODE>70 		}</CODE></p>
<p class=book><CODE>71 	}</CODE></p>
<p class=book><CODE>72 }</CODE></p>
<p class=book>This simple program has a few severe failings. Although it has the advantage, compared to alarm_fork. c or alarm_thread.c, of using fewer resources, it is less responsive. Once alarm_thread has accepted an alarm request from the queue, it</p>
<p class=book>sleeps until that alarm expires. When it fails to find an alarm request on the list, it sleeps for a second anyway, to allow main to accept another alarm command. During all this sleeping, it will fail to notice any alarm requests added to the head of the queue by main, until it returns from sleep.</p>
<p class=book>This problem could be addressed in various ways. The simplest, of course, would be to go back to alarm_thread.c, where a thread was created for each alarm request. That wasn't so bad, since threads are relatively cheap. They're still not as cheap as the alarm_t data structure, however, and we'd like to make efficient programs—not just responsive programs. The best solution is to make use of condition variables for signaling changes in the state of shared data, so it shouldn't be a surprise that you'll be seeing one final version of the alarm program, alarm_cond.c, in Section 3.3.4.</p>


<a name=t51></a><h3 class=book>
3.2.2.1 Nonblocking mutex locks
</h3>
<p class=book>When you lock a mutex by calling pthread_mutex_lock, the calling thread will block if the mutex is already locked. Normally, that's what you want. But occasionally you want your code to take some alternate path if the mutex is locked. Your program may be able to do useful work instead of waiting. Pthreads provides the pthread_mutex_trylock function, which will return an error status (EBUSY) instead of blocking if the mutex is already locked.</p>
<p class=book>When you use a nonblocking mutex lock, be careful to <i>unlock</i> the mutex only if pthread_mutex_trylock returned with success status. Only the thread that owns a mutex may unlock it. An erroneous call to pthread_mutex_unlock may return an error, or it may unlock the mutex while some other thread relies on having it locked—and that will probably cause your program to break in ways that may be very difficult to debug.</p>
<p class=book>The following program, trylock.c, uses pthread_mutex_trylock to occasionally report the value of a counter—but only when its access does not conflict with the counting thread.</p>
<p class=book><b>4</b> This definition controls how long counter_thread holds the mutex while updating the counter. Making this number larger increases the chance that the pthread_mutex_trylock in monitor_thread will occasionally return EBUSY. </p>
<p class=book><b>14-39</b> The counter_thread wakes up approximately each second, locks the mutex, and spins for a while, incrementing counter. The counter is therefore increased by SPIN each second.</p>
<p class=book><b>46-72</b> The monitor_thread wakes up every three seconds, and tries to lock the mutex. If the attempt fails with EBUSY, monitor_thread counts the failure and waits another three seconds. If the pthread_mutex_trylock succeeds, then monitor_thread prints the current value of counter (scaled by SPIN).</p>
<p class=book><b>80-88</b> On Solaris 2.5, call thr_setconcurrency to set the thread concurrency level to 2. This allows the counter_thread and monitor_thread to run concurrently on a uniprocessor. Otherwise, monitor_thread would not run until counter_ thread terminated.</p>
<p class=book>■ <b>trylock.c</b></p>
<p class=book><CODE>1 #include &lt;pthread.h&gt;</CODE></p>
<p class=book><CODE>2 #include "errors.h" 3</CODE></p>
<p class=book><CODE>4 #define SPIN 10000000 5</CODE></p>
<p class=book><CODE>6 pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;</CODE></p>
<p class=book><CODE>7 long counter;</CODE></p>
<p class=book><CODE>8 time_t end_time;</CODE> </p>
<p class=book><CODE>9</CODE></p>
<p class=book><CODE>10 /*</CODE></p>
<p class=book><CODE>11 * Thread start routine that repeatedly locks a mutex and</CODE></p>
<p class=book><CODE>12 * increments a counter.</CODE></p>
<p class=book><CODE>13 */</CODE></p>
<p class=book><CODE>14 void *counter_thread (void *arg)</CODE></p>
<p class=book><CODE>15 {</CODE></p>
<p class=book><CODE>16 int status;</CODE></p>
<p class=book><CODE>17 int spin;</CODE> </p>
<p class=book><CODE>18</CODE></p>
<p class=book><CODE>19 /*</CODE></p>
<p class=book><CODE>20 * Until end_time, increment the counter each second. Instead of</CODE></p>
<p class=book><CODE>21 * just incrementing the counter, it sleeps for another second</CODE></p>
<p class=book><CODE>22 * with the mutex locked, to give monitor_thread a reasonable</CODE></p>
<p class=book><CODE>23 * chance of running.</CODE></p>
<p class=book><CODE>24 */</CODE></p>
<p class=book><CODE>25 while (time (NULL) &lt; end_time)</CODE></p>
<p class=book><CODE>26 {</CODE></p>
<p class=book><CODE>27 	status = pthread_mutex_lock (&mutex);</CODE></p>
<p class=book><CODE>28 	if (status != 0)</CODE></p>
<p class=book><CODE>29 		err_abort (status, "Lock mutex");</CODE></p>
<p class=book><CODE>30 	for (spin = 0; spin &lt; SPIN; spin++)</CODE></p>
<p class=book><CODE>31 		counter++;</CODE></p>
<p class=book><CODE>32 	status = pthread_mutex_unlock (&mutex);</CODE></p>
<p class=book><CODE>33 	if (status != 0)</CODE></p>
<p class=book><CODE>34 		err_abort (status, "Unlock mutex");</CODE></p>
<p class=book><CODE>35 	sleep (1);</CODE></p>
<p class=book><CODE>36 }</CODE></p>
<p class=book><CODE>37 printf ("Counter is %#lx\n", counter);</CODE></p>
<p class=book><CODE>38 return NULL;</CODE></p>
<p class=book><CODE>39 }</CODE> </p>
<p class=book><CODE>40</CODE></p>
<p class=book><CODE>41 /*</CODE></p>
<p class=book><CODE>42 * Thread start routine to "monitor" the counter. Every 3</CODE></p>
<p class=book><CODE>43 * seconds, try to lock the mutex and read the counter. If the</CODE></p>
<p class=book><CODE>44 * trylock fails, skip this cycle.</CODE></p>
<p class=book><CODE>45 */</CODE></p>
<p class=book><CODE>46 void *monitor_thread (void *arg)</CODE></p>
<p class=book><CODE>47 {</CODE></p>
<p class=book><CODE>48 int status;</CODE></p>
<p class=book><CODE>49 int misses = 0;</CODE> </p>
<p class=book><CODE>50</CODE></p>
<p class=book><CODE>51</CODE></p>
<p class=book><CODE>52 /*</CODE></p>
<p class=book><CODE>53 * Loop until end_time, checking the counter every 3 seconds.</CODE></p>
<p class=book><CODE>54 */</CODE></p>
<p class=book><CODE>55 while (time (NULL) &lt; end_time)</CODE></p>
<p class=book><CODE>56 {</CODE></p>
<p class=book><CODE>57 	sleep (3);</CODE></p>
<p class=book><CODE>58 	status = pthread_mutex_trylock (&mutex);</CODE></p>
<p class=book><CODE>59 	if (status != EBUSY)</CODE></p>
<p class=book><CODE>60 	{</CODE></p>
<p class=book><CODE>61 		if (status != 0)</CODE></p>
<p class=book><CODE>62 				err_abort (status, "Trylock mutex");</CODE></p>
<p class=book><CODE>63 		printf ("Counter is %ld\n", counter/SPIN);</CODE></p>
<p class=book><CODE>64 		status = pthread_mutex_unlock (&mutex);</CODE></p>
<p class=book><CODE>65 		if (status != 0)</CODE></p>
<p class=book><CODE>66 			err_abort (status, "Unlock mutex");</CODE></p>
<p class=book><CODE>67 	} else</CODE></p>
<p class=book><CODE>68 		misses++; /* Count "misses" on the lock */</CODE></p>
<p class=book><CODE>69 	}</CODE></p>
<p class=book><CODE>70 	printf ("Monitor thread missed update %d times.\n", misses);</CODE></p>
<p class=book><CODE>71 return NULL;</CODE></p>
<p class=book><CODE>72 }</CODE></p>
<p class=book><CODE>73</CODE></p>
<p class=book><CODE>74 int main (int argc, char *argv[])</CODE></p>
<p class=book><CODE>75 {</CODE></p>
<p class=book><CODE>76 int status;</CODE></p>
<p class=book><CODE>77 pthread_t counter_thread_id;</CODE></p>
<p class=book><CODE>78 pthread_t monitor_thread_id; 79</CODE></p>
<p class=book><CODE>80 #ifdef sun</CODE></p>
<p class=book><CODE>81 /*</CODE></p>
<p class=book><CODE>82 * On Solaris 2.5, threads are not timesliced. To ensure</CODE></p>
<p class=book><CODE>83 * that our threads can run concurrently, we need to</CODE></p>
<p class=book><CODE>84 * increase the concurrency level to 2.</CODE></p>
<p class=book><CODE>85 */</CODE></p>
<p class=book><CODE>86 DPRINTF (("Setting concurrency level to 2\n"));</CODE></p>
<p class=book><CODE>87 thr_setconcurrency (2);</CODE></p>
<p class=book><CODE>88 #endif 89</CODE></p>
<p class=book><CODE>90 end_time = time (NULL) + 60; /* Run for 1 minute */</CODE></p>
<p class=book><CODE>91 status = pthread_create (</CODE></p>
<p class=book><CODE>92 	&counter_thread_id, NULL, counter_thread, NULL);</CODE></p>
<p class=book><CODE>93 if (status != 0)</CODE></p>
<p class=book><CODE>94 	err_abort (status, "Create counter thread");</CODE></p>
<p class=book><CODE>95 status = pthread_create (</CODE></p>
<p class=book><CODE>96 	&monitor_thread_id, NULL, monitor_thread, NULL);</CODE></p>
<p class=book><CODE>97 if (status != 0)</CODE></p>
<p class=book><CODE>98 	err_abort (status, "Create monitor thread");</CODE></p>
<p class=book><CODE>99 status = pthread_join (counter_thread_id, NULL);</CODE></p>
<p class=book><CODE>100 if (status != 0)</CODE></p>
<p class=book><CODE>101 	err_abort (status, "Join counter thread");</CODE></p>
<p class=book><CODE>102 status = pthread_join (monitor_thread_id, NULL);</CODE></p>
<p class=book><CODE>103 if (status != 0)</CODE></p>
<p class=book><CODE>104 	err_abort (status, "Join monitor thread");</CODE></p>
<p class=book><CODE>105 return 0;</CODE></p>
<p class=book><CODE>106 }</CODE></p>



<a name=t52></a><h3 class=book>
<b>3.2.3 Using mutexes for atomicity</b>
</h3>
<p class=book>Invariants, as we saw in Section 3.1, are statements about your program that must always be true. But we also saw that invariants probably aren't always true, and many can't be. To be always true, data composing an invariant must be modified atomically. Yet it is rarely possible to make multiple changes to a program state atomically. It may not even be possible to guarantee that a single change is made atomically, without substantial knowledge of the hardware and architecture and control over the executed instructions.</p>
<p class=book>"Atomic" means indivisible. But most of the time,we just mean that threads don't see things that would confuse them.</p>
<p class=book>Although some hardware will allow you to set an array element and increment the array index in a single instruction that cannot be interrupted, most won't. Most compilers don't let you control the code to that level of detail even if the hardware can do it, and who wants to write in assembler unless it is <i>really</i> important? And, more importantly, most interesting invariants are more complicated than that.</p>
<p class=book>By "atomic," we really mean only that other threads can't accidentally find invariants broken (in intermediate and inconsistent states), even when the threads are running simultaneously on separate processors. There are two basic ways to do that when the hardware doesn't support making the operation indivisible and noninterruptable. One is to detect that you're looking at a broken invariant and try again, or reconstruct the original state. That's hard to do reliably unless you know a lot about the processor architecture and are willing to design nonportable code.</p>
<p class=book>When there is no way to enlist true atomicity in your cause, you need to create your own synchronization. Atomicity is nice, but synchronization will do just as well in most cases. So when you need to update an array element and the index variable atomically, just perform the operation while a mutex is locked.</p>
<p class=book>Whether or not the store and increment operations are performed indivisibly and noninterruptably by the hardware, you know that no cooperating thread can peek until you're done. The transaction is, for all practical purposes, "atomic." The key, of course, is the word "cooperating." Any thread that is sensitive to the invariant must use the same mutex before modifying or examining the state of the invariant.</p>


<a name=t53></a><h3 class=book>
3.2.4 Sizing a mutex to fit the job
</h3>
<p class=book>How big is a mutex? No, I don't mean the amount of memory consumed by a pthread_mutex_t structure. I'm talking about a colloquial and completely inaccurate meaning that happens to make sense to most people. This colorful usage became common during discussions about modifying existing nonthreaded code to be thread-safe. One relatively simple way to make a library thread-safe is to create a single mutex, lock it on each entry to the library, and unlock it on each exit from the library. The library becomes a single serial region, preventing any conflict between threads. The mutex protecting this big serial region came to be referred to as a "big" mutex, clearly larger in some metaphysical sense than a mutex that protects only a few lines of code.</p>
<p class=book>By irrelevant but inevitable extension, a mutex that protects two variables must be "bigger" than a mutex protecting only a single variable. So we can ask, "How big should a mutex be?" And we can answer only, "As big as necessary, but no bigger."</p>
<p class=book>When you need to protect two shared variables, you have two basic strategies: You can assign a small mutex to each variable, or assign a single larger mutex to both variables. Which is better will depend on a lot of factors. Furthermore, the factors will probably change during development, depending on how many threads need the data and how they use it.</p>
<p class=book>These are the main design factors:</p>
<p class=book>1. Mutexes aren't free. It takes time to lock them, and time to unlock them. Therefore, code that locks fewer mutexes will usually run faster than code that locks more mutexes. So use as few as practical, each protecting as much as makes sense.</p>
<p class=book>2. Mutexes, by their nature, serialize execution. If a lot of threads frequently need to lock a single mutex, the threads will spend most of their time waiting. That's bad for performance. If the pieces of data (or code) protected by the mutex are unrelated, you can often improve performance by splitting the big mutex into several smaller mutexes. Fewer threads will need the smaller mutexes at any time, so they'll spend less time waiting. So use as many as makes sense, each protecting as little as is practical.</p>
<p class=book>3. Items 1 and 2 conflict. But that's nothing new or unique, and you can deal with it once you understand what's going on.</p>
<p class=book>In a complicated program it will usually take some experimentation to get the right balance. Your code will be <i>simpler</i> in most cases if you start with large mutexes and then work toward smaller mutexes as experience and performance data show where the heavy contention happens. Simple is good. Don't spend too much time optimizing until you know there's a problem.</p>
<p class=book>On the other hand, in cases where you can tell from the beginning that the algorithms will make heavy contention inevitable, don't oversimplify. Your job will be a lot easier if you start with the necessary mutexes and data structure design rather than adding them later. You will get it wrong sometimes, because, especially when you are working on your first major threaded project, your intuition will not always be correct. Wisdom, as they say, comes from experience, and experience comes from lack of wisdom.</p>


<a name=t54></a><h3 class=book>
3.2.5 Using more than one mutex
</h3>

<p class=book>Sometimes one mutex isn't enough. This happens when your code "crosses over" some boundary within the software architecture. For example, when multiple threads will access a queue data structure at the same time, you may need a mutex to protect the queue header and another to protect data within a queue element. When you build a tree structure for threaded programming, you may need a mutex for each node in the tree.</p>
<p class=book>Complications can arise when using more than one mutex at the same time. The worst is deadlock—when each of two threads holds one mutex and needs the other to continue. More subtle problems such as priority inversion can occur when you combine mutexes with priority scheduling. For more information on deadlock, priority inversion, and other synchronization problems, refer to Section 8.1.</p>


<a name=t55></a><h3 class=book>
3.2.5.1 Lock hierarchy
</h3>
<p class=book>If you can apply two separate mutexes to completely independent data, do it. You'll almost always win in the end by reducing the time when a thread has to wait for another thread to finish with data that this thread doesn't even need. And if the data is independent you're unlikely to run into many cases where a given function will need to lock both mutexes.</p>
<p class=book>The complications arise when data isn't completely independent. If you have some program invariant—even one that's rarely changed or referenced—that affects data protected by two mutexes, sooner or later you'll need to write code that must lock <i>both</i> mutexes at the same time to ensure the integrity of that invariant. If one thread locks mutex_a and then locks mutex_b, while another thread locks mutex_b and then mutex_a, you've coded a classic deadlock, as shown in Table 3.1.</p>
<TABLE>
<TR>
<TD align = "left" ><b>First thread</b></TD>
<TD align = "left" ><b>Second thread</b></TD>
</TR>
<TR>
<TD align = "left" >pthread_mutex_lock (&mutex_a);</TD>
<TD align = "left" >pthread_mutex_lock (&mutex_b);</TD>
</TR>
<TR>
<TD align = "left" >pthread_mutex_lock (&mutex_b);</TD>
<TD align = "left" >pthread_mutex_lock (&mutex_a);</TD>
</TR>
</TABLE>
<p class=book><b>TABLE 3.1</b> <i>Mutex deadlock</i></p>
<p class=book>Both of the threads shown in Table 3.1 may complete the first step about the same time. Even on a uniprocessor, a thread might complete the first step and then be timesliced (preempted by the system), allowing the second thread to complete its first step. Once this has happened, neither of them can ever complete the second step because each thread needs a mutex that is already locked by the other thread.</p>
<p class=book>Consider these two common solutions to this type of deadlock:</p>
<p class=book>• <b>Fixed locking hierarchy:</b> All code that needs both mutex_a and mutex_b must <i>always</i> lock mutex_a first and then mutex_b.</p>
<p class=book>• <b>Try and back off:</b> After locking the first mutex of some set (which can be allowed to block), use pthread_mutex_trylock to lock additional mutexes in the set. If an attempt fails, release all mutexes in the set and start again.</p>
<p class=book>There are any number of ways to define a fixed locking hierarchy. Sometimes there's an obvious hierarchical order to the mutexes anyway, for example, if one mutex controls a queue header and one controls an element on the queue, you'll probably have to have the queue header locked by the time you need to lock the queue element anyway.</p>
<p class=book>When there's no obvious logical hierarchy, you can create an arbitrary hierarchy; for example, you could create a generic "lock a set of mutexes" function that sorts a list of mutexes in order of their identifier address and locks them in that order. Or you could assign them names and lock them in alphabetical order, or integer sequence numbers and lock them in numerical order.</p>
<p class=book>To some extent, the order doesn't really matter as long as it is always the same. On the other hand, you will rarely need to lock "a set of mutexes" at one time. Function A will need to lock mutex 1, and then call function B, which needs to also lock mutex 2. If the code was designed with a functional locking hierarchy, you will usually find that mutex 1 and mutex 2 are being locked in the proper order, that is, mutex 1 is locked first and then mutex 2. If the code was designed with an arbitrary locking order, especially an order not directly controlled by the code, such as sorting pointers to mutexes initialized in heap structures, you may find that mutex 2 should have been locked before mutex 1.</p>
<p class=book>If the code invariants permit you to unlock mutex 1 safely at this point, you would do better to avoid owning both mutexes at the same time. That is, unlock mutex 1, and then lock mutex 2. If there is a broken invariant that requires mutex 1 to be owned, then mutex 1 cannot be released until the invariant is restored. If this situation is possible, you should consider using a backoff (or "try and back off") algorithm.</p>
<p class=book>"Backoff means that you lock the first mutex normally, but any additional mutexes in the set that are required by the thread are locked conditionally by</p>
<p class=book>calling pthread_mutex_trylock. If pthread_mutex_trylock returns EBUSY, indicating that the mutex is already locked, you must unlock <i>all</i> of the mutexes in the set and start over.</p>
<p class=book>The backoff solution is less efficient than a fixed hierarchy. You may waste a lot of time trying and backing off. On the other hand, you don't need to define and follow strict locking hierarchy conventions, which makes backoff more flexible. You can use the two techniques in combination to minimize the cost of backing off. Follow some fixed hierarchy for well-defined areas of code, but apply a backoff algorithm where a function needs to be more flexible.</p>
<p class=book>The program below, backoff.c, demonstrates how to avoid mutex deadlocks by applying a backoff algorithm. The program creates two threads, one running function lock_forward and the other running function lock_backward. The two threads loop ITERATIONS times, each iteration attempting to lock all of three mutexes in sequence. The lock_forward thread locks mutex 0, then mutex 1, then mutex 2, while lock_backward locks the three mutexes in the opposite order. Without special precautions, this design will always deadlock quickly (except on a uniprocessor system with a sufficiently long timeslice that either thread can complete before the other has a chance to run).</p>
<p class=book><b>15</b> You can see the deadlock by running the program as backoff 0. The first argument is used to set the backoff variable. If backoff is 0, the two threads will use pthread_mutex_lock to lock each mutex. Because the two threads are starting from opposite ends, they will crash in the middle, and the program will hang. When backoff is nonzero (which it is unless you specify an argument), the threads use pthread_mutex_trylock, which enables the backoff algorithm. When the mutex lock fails with EBUSY, the thread will release all mutexes it currently owns, and start over.</p>
<p class=book><b>16</b> It is possible that, on some systems, you may not see any mutex collisions, because one thread is always able to lock all mutexes before the other thread has a chance to lock any. You can resolve that problem by setting the yield_flag variable, which you do by running the program with a second argument, for example, backoff 1 1. When yield_flag is 0, which it is unless you specify a second argument, each thread's mutex locking loop may run uninterrupted, preventing a deadlock (at least, on a uniprocessor). When yield_flag has a value greater than 0, however, the threads will call sched_yield after locking each mutex, ensuring that the other thread has a chance to run. And if you set yield_ flag to a value less than 0, the threads will sleep for one second after locking each mutex, to be <i>really</i> sure the other thread has a chance to run.</p>
<p class=book><b>70-75</b> After locking all of the three mutexes, each thread reports success, and tells how many times it had to back off before succeeding. On a multiprocessor, or when you've set yield_flag to a nonzero value, you'll usually see a lot more nonzero backoff counts. The thread unlocks all three mutexes, in the reverse order of locking, which helps to avoid unnecessary backoffs in other threads. Calling sched_yield at the end of each iteration "mixes things up" a little so one thread doesn't always start each iteration first. The sched_yield function is described in Section 5.5.2.</p>
<p class=book>■ backoff.c</p>
<p class=book><CODE>1 #include &lt;pthread.h&gt;</CODE></p>
<p class=book><CODE>2 #include "errors.h" 3</CODE></p>
<p class=book><CODE>4 #define ITERATIONS 10 5</CODE></p>
<p class=book><CODE>6 /*</CODE></p>
<p class=book><CODE>7 * Initialize a static array of 3 mutexes.</CODE></p>
<p class=book><CODE>8 */</CODE></p>
<p class=book><CODE>9 pthread_mutex_t mutex[3] = {</CODE></p>
<p class=book><CODE>10 PTHREAD_MUTEX_INITIALIZER,</CODE></p>
<p class=book><CODE>11 PTHREAD_MUTEX_INITIALIZER,</CODE></p>
<p class=book><CODE>12 PTHREAD_MUTEX_INITIALIZER</CODE></p>
<p class=book><CODE>13 }; 14</CODE></p>
<p class=book><CODE>15 int backoff = 1; /* Whether to backoff or deadlock */</CODE></p>
<p class=book><CODE>16 int yield_flag = 0; /* 0: no yield, &gt;0: yield, &lt;0: sleep */ 17</CODE></p>
<p class=book><CODE>18 /*</CODE></p>
<p class=book><CODE>19 * This is a thread start routine that locks all mutexes in</CODE></p>
<p class=book><CODE>20 * order, to ensure a conflict with lock reverse, which does the</CODE></p>
<p class=book><CODE>21 * opposite.</CODE></p>
<p class=book><CODE>22 */</CODE></p>
<p class=book><CODE>23 void *lock_forward (void *arg)</CODE></p>
<p class=book><CODE>24 {</CODE></p>
<p class=book><CODE>25 int i, iterate, backoffs;</CODE></p>
<p class=book><CODE>26 int status;</CODE> </p>
<p class=book><CODE>27</CODE></p>
<p class=book><CODE>28 for (iterate = 0; iterate &lt; ITERATIONS; iterate++) {</CODE></p>
<p class=book><CODE>29 backoffs = 0;</CODE></p>
<p class=book><CODE>30 for (i = 0; i &lt; 3; i++) {</CODE></p>
<p class=book><CODE>31 if (i == 0) {</CODE></p>
<p class=book><CODE>32 status = pthread_mutex_lock (&mutex[i]);</CODE></p>
<p class=book><CODE>33 if (status != 0)</CODE></p>
<p class=book><CODE>34 err_abort (status, "First lock");</CODE></p>
<p class=book><CODE>35 } else {</CODE></p>
<p class=book><CODE>36 if (backoff)</CODE></p>
<p class=book><CODE>37 status = pthread_mutex_trylock (&mutex[i]);</CODE></p>
<p class=book><CODE>38 else</CODE></p>
<p class=book><CODE>39 status = pthread_mutex_lock (&mutex[i]);</CODE></p>
<p class=book><CODE>40 if (status == EBUSY) {</CODE></p>
<p class=book><CODE>41 backoffs++;</CODE></p>
<p class=book><CODE>42 DPRINTF ((</CODE></p>
<p class=book><CODE>43 " [forward locker backing off at %d]\n",</CODE></p>
<p class=book><CODE>44 i));</CODE></p>
<p class=book><CODE>45 for (; i &gt;= 0; i--) {</CODE></p>
<p class=book><CODE>46 status = pthread_mutex_unlock (&mutex[i]);</CODE></p>
<p class=book><CODE>47 if (status != 0)</CODE></p>
<p class=book><CODE>48 err_abort (status, "Backoff");</CODE></p>
<p class=book><CODE>49 }</CODE></p>
<p class=book><CODE>50 } else {</CODE></p>
<p class=book><CODE>51 if (status != 0)</CODE></p>
<p class=book><CODE>52 err_abort (status, "Lock mutex");</CODE></p>
<p class=book><CODE>53 DPRINTF ((" forward locker got %d\n", i));</CODE></p>
<p class=book><CODE>54 }</CODE></p>
<p class=book><CODE>55 }</CODE></p>
<p class=book><CODE>56 /*</CODE></p>
<p class=book><CODE>57 * Yield processor, if needed to be sure locks get</CODE></p>
<p class=book><CODE>58 * interleaved on a uniprocessor.</CODE></p>
<p class=book><CODE>59 */</CODE></p>
<p class=book><CODE>60 if (yield_flag) {</CODE></p>
<p class=book><CODE>61 if (yield_flag &gt; 0)</CODE></p>
<p class=book><CODE>62 sched_yield ();</CODE></p>
<p class=book><CODE>63 else</CODE></p>
<p class=book><CODE>64 sleep (1);</CODE></p>
<p class=book><CODE>65 }</CODE></p>
<p class=book><CODE>66 }</CODE></p>
<p class=book><CODE>67 /*</CODE></p>
<p class=book><CODE>68 * Report that we got 'em, and unlock to try again.</CODE></p>
<p class=book><CODE>69 */</CODE></p>
<p class=book><CODE>70 printf (</CODE></p>
<p class=book><CODE>71 "lock forward got all locks, %d backoffs\n", backoffs);</CODE></p>
<p class=book><CODE>72 pthread_mutex_unlock (&mutex[2]);</CODE></p>
<p class=book><CODE>73 pthread_mutex_unlock (&mutex[1]);</CODE></p>
<p class=book><CODE>74 pthread_mutex_unlock (&mutex[0]);</CODE></p>
<p class=book><CODE>75 sched_yield ();</CODE></p>
<p class=book><CODE>76 }</CODE></p>
<p class=book><CODE>77 return NULL;</CODE></p>
<p class=book><CODE>78 }</CODE> </p>
<p class=book><CODE>79</CODE></p>
<p class=book><CODE>80 /*</CODE></p>
<p class=book><CODE>81 * This is a thread start routine that locks all mutexes in</CODE></p>
<p class=book><CODE>82 * reverse order, to ensure a conflict with lock_forward, which</CODE></p>
<p class=book><CODE>83 * does the opposite.</CODE></p>
<p class=book><CODE>84 */</CODE></p>
<p class=book><CODE>85 void *lock_backward (void *arg)</CODE></p>
<p class=book><CODE>86 {</CODE></p>
<p class=book><CODE>87 int i, iterate, backoffs;</CODE></p>
<p class=book><CODE>88 int status;</CODE> </p>
<p class=book><CODE>89</CODE></p>
<p class=book><CODE>90 for (iterate = 0; iterate &lt; ITERATIONS; iterate++) {</CODE></p>
<p class=book><CODE>91 backoffs = 0;</CODE></p>
<p class=book><CODE>92 for (i = 2; i &gt;= 0; i--) {</CODE></p>
<p class=book><CODE>93 if (i == 2) {</CODE></p>
<p class=book><CODE>94 status = pthread_mutex_lock (&mutex[i]);</CODE></p>
<p class=book><CODE>95 if (status != 0)</CODE></p>
<p class=book><CODE>96 err_abort (status, "First lock");</CODE></p>
<p class=book><CODE>97 } else {</CODE></p>
<p class=book><CODE>98 if (backoff)</CODE></p>
<p class=book><CODE>99 status = pthread_mutex_trylock (&mutex[i]);</CODE></p>
<p class=book><CODE>100 else</CODE></p>
<p class=book><CODE>101 status = pthread_mutex_lock (&mutex[i]);</CODE></p>
<p class=book><CODE>102 if (status == EBUSY) {</CODE></p>
<p class=book><CODE>103 backoffs++;</CODE></p>
<p class=book><CODE>104 DPRINTF ((</CODE></p>
<p class=book><CODE>105 " [backward locker backing off at %d]\n",</CODE></p>
<p class=book><CODE>106 i));</CODE></p>
<p class=book><CODE>107 for (; i &lt; 3; i++) {</CODE></p>
<p class=book><CODE>108 status = pthread_mutex_unlock (&mutex[i]);</CODE></p>
<p class=book><CODE>109 if (status != 0)</CODE></p>
<p class=book><CODE>110 err_abort (status, "Backoff");</CODE></p>
<p class=book><CODE>111 }</CODE></p>
<p class=book><CODE>112 } else {</CODE></p>
<p class=book><CODE>113 if (status != 0)</CODE></p>
<p class=book><CODE>114 err_abort (status, "Lock mutex");</CODE></p>
<p class=book><CODE>115 DPRINTF ((" backward locker got %d\n", i));</CODE></p>
<p class=book><CODE>116 }</CODE></p>
<p class=book><CODE>117 }</CODE></p>
<p class=book><CODE>118 /*</CODE></p>
<p class=book><CODE>119 * Yield processor, if needed to be sure locks get</CODE></p>
<p class=book><CODE>120 * interleaved on a uniprocessor.</CODE></p>
<p class=book><CODE>121 */</CODE></p>
<p class=book><CODE>122 if (yield_flag) {</CODE></p>
<p class=book><CODE>123 if (yield_flag &gt; 0)</CODE></p>
<p class=book><CODE>124 sched_yield ();</CODE></p>
<p class=book><CODE>125 else</CODE></p>
<p class=book><CODE>126 sleep (1);</CODE></p>
<p class=book><CODE>127 }</CODE></p>
<p class=book><CODE>128 }</CODE></p>
<p class=book><CODE>129 /*</CODE></p>
<p class=book><CODE>130 * Report that we got 'em, and unlock to try again.</CODE></p>
<p class=book><CODE>131 */</CODE></p>
<p class=book><CODE>132 printf (</CODE></p>
<p class=book><CODE>133 "lock backward got all locks, %d backoffs\n", backoffs);</CODE></p>
<p class=book><CODE>134 pthread_mutex_unlock (&mutex[0]);</CODE></p>
<p class=book><CODE>135 pthread_mutex_unlock (&mutex[l]);</CODE></p>
<p class=book><CODE>136 pthread_mutex_unlock (&mutex[2]);</CODE></p>
<p class=book><CODE>137 sched_yield ();</CODE></p>
<p class=book><CODE>138 }</CODE></p>
<p class=book><CODE>139 return NULL;</CODE></p>
<p class=book><CODE>140 } 141</CODE></p>
<p class=book><CODE>142 int main (int argc, char *argv[])</CODE></p>
<p class=book><CODE>143 {</CODE></p>
<p class=book><CODE>144 pthread_t forward, backward;</CODE></p>
<p class=book><CODE>145 int status;</CODE> </p>
<p class=book><CODE>146</CODE></p>
<p class=book><CODE>147 #ifdef sun</CODE></p>
<p class=book><CODE>148 /*</CODE></p>
<p class=book><CODE>149 * On Solaris 2.5, threads are not timesliced. To ensure</CODE></p>
<p class=book><CODE>150 * that our threads can run concurrently, we need to</CODE></p>
<p class=book><CODE>151 * increase the concurrency level.</CODE></p>
<p class=book><CODE>152 */</CODE></p>
<p class=book><CODE>153 DPRINTF (("Setting concurrency level to 2\n"));</CODE></p>
<p class=book><CODE>154 thr_setconcurrency (2);</CODE></p>
<p class=book><CODE>155 #endif</CODE> </p>
<p class=book><CODE>156</CODE></p>
<p class=book><CODE>157 /*</CODE></p>
<p class=book><CODE>158 * If the first argument is absent, or nonzero, a backoff</CODE></p>
<p class=book><CODE>159 * algorithm will be used to avoid deadlock. If the first</CODE></p>
<p class=book><CODE>160 * argument is zero, the program will deadlock on a lock</CODE></p>
<p class=book><CODE>161 * "collision."</CODE></p>
<p class=book><CODE>162 */</CODE></p>
<p class=book><CODE>163 if (argc &gt; 1)</CODE></p>
<p class=book><CODE>164 backoff = atoi (argv[l]);</CODE> </p>
<p class=book><CODE>165</CODE></p>
<p class=book><CODE>166 /*</CODE></p>
<p class=book><CODE>167 * If the second argument is absent, or zero, the two threads</CODE></p>
<p class=book><CODE>168 * run "at speed." On some systems, especially uniprocessors,</CODE></p>
<p class=book><CODE>169 * one thread may complete before the other has a chance to run,</CODE></p>
<p class=book><CODE>170 * and you won't see a deadlock or backoffs. In that case, try</CODE></p>
<p class=book><CODE>171 * running with the argument set to a positive number to cause</CODE></p>
<p class=book><CODE>172 * the threads to call sched_yield() at each lock; or, to make</CODE></p>
<p class=book><CODE>173 * it even more obvious, set to a negative number to cause the</CODE></p>
<p class=book><CODE>174 * threads to call sleep(l) instead.</CODE></p>
<p class=book><CODE>175 */</CODE></p>
<p class=book><CODE>176 if (argc &gt; 2)</CODE></p>
<p class=book><CODE>177 yield_flag = atoi (argv[2]);</CODE></p>
<p class=book><CODE>178 status = pthread_create (</CODE></p>
<p class=book><CODE>179 &forward, NULL, lock_forward, NULL);</CODE></p>
<p class=book><CODE>180 if (status != 0)</CODE></p>
<p class=book><CODE>181 err_abort (status, "Create forward");</CODE></p>
<p class=book><CODE>182 status = pthread_create (</CODE></p>
<p class=book><CODE>183 &backward, NULL, lock_backward, NULL);</CODE></p>
<p class=book><CODE>184 if (status != 0)</CODE></p>
<p class=book><CODE>185 err_abort (status, "Create backward");</CODE></p>
<p class=book><CODE>186 pthread_exit (NULL);</CODE></p>
<p class=book><CODE>187 }</CODE></p>
<p class=book>Whatever type of hierarchy you choose, <i>document it,</i> carefully, completely, and often. Document it in each function that uses any of the mutexes. Document it where the mutexes are defined. Document it where they are declared in a project</p>
<p class=book>header file. Document it in the project design notes. Write it on your whiteboard. And then tie a string around your finger to be sure that you do not forget.</p>
<p class=book>You are free to unlock the mutexes in whatever order makes the most sense. Unlocking mutexes cannot result in deadlock. In the next section, I will talk about a sort of "overlapping hierarchy" of mutexes, called a "lock chain," where the normal mode of operation is to lock one mutex, lock the next, unlock the first, and so on. If you use a "try and back off algorithm, however, you should always try to release the mutexes in reverse order. That is, if you lock mutex 1, mutex 2, and then mutex 3, you should unlock mutex 3, then mutex 2, and finally mutex 1. If you unlock mutex 1 and mutex 2 while mutex 3 is still locked, another thread may have to lock both mutex 1 and mutex 2 before finding it cannot lock the entire hierarchy, at which point it will have to unlock mutex 2 and mutex 1, and then retry. Unlocking in reverse order reduces the chance that another thread will need to back off.</p>


<a name=t56></a><h3 class=book>
3.2.5.2 Lock chaining
</h3>
<p class=book>"Chaining" is a special case of locking hierarchy, where the scope of two locks overlap. With one mutex locked, the code enters a region where another mutex is required. After successfully locking that second mutex, the first is no longer needed, and can be released. This technique can be very valuable in traversing data structures such as trees or linked lists. Instead of locking the entire data structure with a single mutex, and thereby preventing any parallel access, each node or link has a unique mutex. The traversal code would first lock the queue head, or tree root, find the desired node, lock it, and then release the root or queue head mutex.</p>
<p class=book>Because chaining is a special form of hierarchy, the two techniques are compatible, if you apply them carefully. You might use hierarchical locking when balancing or pruning a tree, for example, and chaining when searching for a specific node.</p>
<p class=book>Apply lock chaining with caution, however. It is exceptionally easy to write code that spends most of its time locking and unlocking mutexes that never exhibit any contention, and that is wasted processor time. Use lock chaining only when multiple threads will almost always be active within different parts of the hierarchy.</p>




<a name=t57></a><h3 class=book>
3.3 Condition variables
</h3>
<blockquote class="epigraph">
<p class=book>"There's no sort of use in knocking," said the Footman, "and that for two reasons. First, because I'm on the same side of the door as you are: secondly, because they're making such a noise inside, no one could possibly hear you."</p>
<blockquote class=book><i>— <i>Lewis Carroll, Alice's Adventures in Wonderland</i></i></blockquote>
</blockquote>

<img border=0 style='spacing 9px;' src="img_7.png">
<br>
<p class=book><b>FIGURE 3.3</b> <i>Condition variable analogy</i></p>
<p class=book>A condition variable is used for communicating information about the state of shared data. You would use a condition variable to signal that a queue was no longer empty, or that it had become empty, or that anything else needs to be done or can be done within the shared data manipulated by threads in your program.</p>
<p class=book>Our seafaring programmers use a mechanism much like condition variables to communicate (Figure 3.3). When the rower nudges a sleeping programmer to signal that the sleeping programmer should wake up and start rowing, the original rower "signals a condition." When the exhausted ex-rower sinks into a deep slumber, secure that another programmer will wake him at the appropriate time, he is "waiting on a condition." When the horrified bailer discovers that water is seeping into the boat faster than he can remove it, and he yells for help, he is "broadcasting a condition."</p>
<p class=book>When a thread has mutually exclusive access to some shared state, it may find that there is no more it can do until some other thread changes the state. The state may be correct, and consistent—that is, no invariants are broken—but the current state just doesn't happen to be of interest to the thread. If a thread servicing a queue finds the queue empty, for example, the thread must wait until an entry is added to the queue.</p>
<p class=book>The shared data, for example, the queue, is protected by a mutex. A thread must lock the mutex to determine the current state of the queue, for example, to determine that it is empty. The thread must unlock the mutex before waiting (or</p>
<p class=book>no other thread would be able to insert an entry onto the queue), and then it must wait for the state to change. The thread might, for example, by some means block itself so that a thread inserting a new queue entry can find its identifier and awaken it. There is a problem here, though—the thread is running between unlocking and blocking.</p>
<p class=book>If the thread is still running while another thread locks the mutex and inserts an entry onto the queue, that other thread cannot determine that a thread is waiting for the new entry. The waiting thread has already looked at the queue and found it empty, and has unlocked the mutex, so it will now block itself without knowing that the queue is no longer empty. Worse, it may not yet have recorded the fact that it intends to wait, so it may wait forever because the other thread cannot find its identifier. The unlock and wait operations must be atomic, so that no other thread can lock the mutex before the waiter has become blocked, and is in a state where another thread can awaken it.</p>
<p class=book> A condition variable wait always returns with the mutex locked.</p>
<p class=book>That's why <i>condition variables</i> exist. A condition variable is a "signaling mechanism" associated with a mutex and by extension is also associated with the shared data protected by the mutex. <i>Waiting</i> on a condition variable atomically releases the associated mutex and waits until another thread <i>signals</i> (to wake one waiter) or <i>broadcasts</i> (to wake all waiters) the condition variable. The mutex must always be locked when you wait on a condition variable and, when a thread wakes up from a condition variable wait, it always resumes with the mutex locked.</p>
<p class=book>The shared data associated with a condition variable, for example, the queue "full" and "empty" conditions, are the <i>predicates</i> we talked about in Section 3.1. A condition variable is the mechanism your program uses to wait for a predicate to become true, and to communicate to other threads that it might be true. In other words, a condition variable allows threads using the queue to exchange information about the changes to the queue state.</p>
<p class=book><b>I</b> Condition variables are for <i>signaling<b>,</b></i> not for mutual exclusion.</p>
<p class=book>Condition variables do not provide mutual exclusion. You need a mutex to synchronize access to the shared data, including the predicate for which you wait. That is why you must specify a mutex when you wait on a condition variable. By making the unlock atomic with the wait, the Pthreads system ensures that no thread can change the predicate after you have unlocked the mutex but before your thread is waiting on the condition variable.</p>
<p class=book>Why isn't the mutex created as part of the condition variable? First, mutexes are used separately from any condition variable as often as they're used with condition variables. Second, it is common for one mutex to have more than one associated condition variable. For example, a queue may be "full" or "empty." Although you may have two condition variables to allow threads to wait for either condition, you must have one and only one mutex to synchronize <i>all</i> access to the queue header.</p>
<p class=book>A condition variable should be associated with a single predicate. If you try to share one condition variable between several predicates, or use several condition variables for a single predicate, you're risking deadlock or race problems. There's nothing wrong with doing either, as long as you're careful—but it is easy to confuse your program (computers aren't very smart) and it is usually not worth the risk. I will expound on the details later, but the rules are as follows: First, when you share a condition variable between multiple predicates, you must always <i>broadcast,</i> never <i>signal;</i> and second, <i>signal</i> is more efficient than <i>broadcast.</i></p>
<p class=book>Both the condition variable and the predicate are shared data in your program; they are used by multiple threads, possibly at the same time. Because you're thinking of the condition variable and predicate as being locked together, it is easy to remember that they're always controlled using the same mutex. It is possible (and legal, and often even reasonable) to <i>signal</i> or <i>broadcast</i> a condition variable without having the mutex locked, but it is safer to have it locked.</p>
<p class=book>Figure 3.4 is a timing diagram showing how three threads, thread 1, thread 2, and thread 3, interact with a condition variable. The rounded box represents the condition variable, and the three lines represent the actions of the three threads.</p>
<p class=book><b>FIGURE 3.4</b> <i>Condition variable operation</i></p>
<img border=0 style='spacing 9px;' src="img_8.png">
<br>
<p class=book>When a line goes within the box, it is "doing something" with the condition variable. When a thread's line stops before reaching below the middle line through the box, it is waiting on the condition variable; and when a thread's line reaches below the middle line, it is signaling or broadcasting to awaken waiters.</p>
<p class=book>Thread 1 signals the condition variable, which has no effect since there are no waiters. Thread 1 then waits on the condition variable. Thread 2 also blocks on the condition variable and, shortly thereafter, thread 3 signals the condition variable. Thread 3's signal unblocks thread 1. Thread 3 then waits on the condition variable. Thread 1 broadcasts the condition variable, unblocking both thread 2 and thread 3. Thread 3 waits on the condition variable shortly thereafter, with a timed wait. Some time later, thread 3's wait times out, and the thread awakens.</p>


<a name=t58></a><h3 class=book>
3.3.1 Creating and destroying a condition variable
</h3>
<p class=book><b>pthread_cond_t cond = PTHREAD_COND_INITIALIZER;</b> </p>
<p class=book><b>int pthread_cond_init (pthread_cond_t *cond,</b></p>
<p class=book><b>	pthread_condattr_t *condattr);</b> </p>
<p class=book><b>int pthread_cond_destroy (pthread_cond_t *cond);</b></p>
<p class=book>A condition variable is represented in your program by a variable of type pthread_cond_t. You should never make a copy of a condition variable, because the result of using a copied condition variable is undefined. It would be like telephoning a disconnected number and expecting an answer. One thread could, for example, wait on one copy of the condition variable, while another thread signaled or broadcast the other copy of the condition variable—the waiting thread would not be awakened. You can, however, freely pass pointers to a condition variable so that various functions and threads can use it for synchronization.</p>
<p class=book>Most of the time you'll probably declare condition variables using the extern or static storage class at file scope, that is, outside of any function. They should have normal (extern) storage class if they are used by other files, or static storage class if used only within the file that declares the variable. When you declare a static condition variable that has default attributes, you should use the PTHREAD_COND_INITIALIZER initialization macro, as shown in the following example, cond_static.c.</p>
<p class=book>■ <b>cond_static.c</b></p>
<p class=book><CODE>1 #include &lt;pthread.h&gt;</CODE></p>
<p class=book><CODE>2 #include "errors.h"</CODE></p>
<p class=book><CODE>3</CODE></p>
<p class=book><CODE>4 /*</CODE></p>
<p class=book><CODE>5 * Declare a structure, with a mutex and condition variable,</CODE></p>
<p class=book><CODE>6 * statically initialized. This is the same as using</CODE></p>
<p class=book><CODE>7 * pthread_mutex_init and pthread_cond_init, with the default</CODE></p>
<p class=book><CODE>8 * attributes.</CODE></p>
<p class=book><CODE>9 */</CODE></p>
<p class=book><CODE>10 typedef struct my_struct_tag {</CODE></p>
<p class=book><CODE>11 	pthread_mutex_t mutex; /* Protects access to value */</CODE></p>
<p class=book><CODE>12 	pthread_cond_t cond; /* Signals change to value */</CODE></p>
<p class=book><CODE>13 	int value; /* Access protected by mutex */</CODE></p>
<p class=book><CODE>14 } my_struct_t;</CODE> </p>
<p class=book><CODE>15</CODE></p>
<p class=book><CODE>16 my_struct_t data = {</CODE></p>
<p class=book><CODE>17 	PTHREAD_MUTEX_INITIALIZER, PTHREAD_COND_INITIALIZER, 0};</CODE> </p>
<p class=book><CODE>18</CODE></p>
<p class=book><CODE>19 int main (int argc, char *argv[])</CODE></p>
<p class=book><CODE>20 {</CODE></p>
<p class=book><CODE>21 	return 0 ;</CODE></p>
<p class=book><CODE>22 }</CODE></p>
<p class=book>Condition variables and their predicates are "linked"—for best results, treat them that way!</p>
<p class=book>When you declare a condition variable, remember that a condition variable and the associated predicate are "locked together." You may save yourself (or your successor) some confusion by always declaring the condition variable and predicate together, if possible. I recommend that you try to encapsulate a set of invariants and predicates with its mutex and one or more condition variables as members in a structure, and carefully document the association.</p>
<p class=book>Sometimes you cannot initialize a condition variable statically; for example, when you use malloc to create a structure that contains a condition variable. Then you will need to call pthread_cond_init to initialize the condition variable dynamically, as shown in the following example, cond_dynamic.c. You can also dynamically initialize condition variables that you declare statically—but you must ensure that each condition variable is initialized before it is used, and that each is initialized only once. You may initialize it before creating any threads, for example, or by using pthread_once (Section 5.1). If you need to initialize a condition variable with nondefault attributes, you must use dynamic initialization (see Section 5.2.2).</p>
<p class=book>■ <b>cond_dynamic.c</b></p>
<p class=book><CODE>1 #include &lt;pthread.h&gt;</CODE></p>
<p class=book><CODE>2 #include "errors.h" 3</CODE></p>
<p class=book><CODE>4 /*</CODE></p>
<p class=book><CODE>5 * Define a structure, with a mutex and condition variable.</CODE></p>
<p class=book><CODE>6 */</CODE></p>
<p class=book><CODE>7 typedef struct my_struct_tag {</CODE></p>
<p class=book><CODE>8 pthread_mutex_t mutex; /* Protects access to value */</CODE></p>
<p class=book><CODE>9 pthread_cond_t cond; /* Signals change to value */</CODE></p>
<p class=book><CODE>10 int value; /* Access protected by mutex */</CODE></p>
<p class=book><CODE>11 } my_struct_t;</CODE> </p>
<p class=book><CODE>12</CODE></p>
<p class=book><CODE>13 int main (int argc, char *argv[])</CODE></p>
<p class=book><CODE>14 {</CODE></p>
<p class=book><CODE>15 my_struct_t *data;</CODE></p>
<p class=book><CODE>16 int status;</CODE> </p>
<p class=book><CODE>17</CODE></p>
<p class=book><CODE>18 data = malloc (sizeof (my_struct_t));</CODE></p>
<p class=book><CODE>19 if (data == NULL)</CODE></p>
<p class=book><CODE>20 	errno_abort ("Allocate structure");</CODE></p>
<p class=book><CODE>21 status = pthread_mutex_init (&data-&gt;mutex, NULL);</CODE></p>
<p class=book><CODE>22 if (status != 0)</CODE></p>
<p class=book><CODE>23 	err_abort (status, "Init mutex");</CODE></p>
<p class=book><CODE>24 status = pthread_cond_init (&data-&gt;cond, NULL);</CODE></p>
<p class=book><CODE>25 if (status != 0)</CODE></p>
<p class=book><CODE>26 err_abort (status, "Init condition");</CODE></p>
<p class=book><CODE>27 status = pthread_cond_destroy (&data-&gt;cond);</CODE></p>
<p class=book><CODE>28 if (status != 0)</CODE></p>
<p class=book><CODE>29 	err_abort (status, "Destroy condition");</CODE></p>
<p class=book><CODE>30 status = pthread_mutex_destroy (&data-&gt;mutex);</CODE></p>
<p class=book><CODE>31 if (status != 0)</CODE></p>
<p class=book><CODE>32 	err_abort (status, "Destroy mutex");</CODE></p>
<p class=book><CODE>33 (void)free (data);</CODE></p>
<p class=book><CODE>34 return status;</CODE></p>
<p class=book><CODE>35 }</CODE></p>
<p class=book>When you dynamically initialize a condition variable, you should destroy the condition variable when you no longer need it, by calling pthread_cond_destroy. You do not need to destroy a condition variable that was statically initialized using the PTHREAD_COND_INITIALIZER macro.</p>
<p class=book>It is safe to destroy a condition variable when you know that no threads can be blocked on the condition variable, and no additional threads will try to wait on, signal, or broadcast the condition variable. The best way to determine this is usually within a thread that has just successfully broadcast to unblock all waiters, when program logic ensures that no threads will try to use the condition variable later.</p>
<p class=book>When a thread removes a structure containing a condition variable from a list, for example, and then broadcasts to awaken any waiters, it is safe (and also a very good idea) to destroy the condition variable before freeing the storage that the condition variable occupies. The awakened threads should check their wait predicate when they resume, so you must make sure that you don't free resources required for the predicate before they've done so—this may require additional synchronization.</p>


<a name=t59></a><h3 class=book>
3.3.2 Waiting on a condition variable
</h3>
<p class=book><b>int pthread_cond_wait (pthread_cond_t *cond,</b></p>
<p class=book><b>	pthread_mutex_t *mutex);</b> </p>
<p class=book><b>int pthread_cond_timedwait (pthread_cond_t *cond,</b></p>
<p class=book><b>	pthread_mutex_t *mutex,</b></p>
<p class=book><b>	struct timespec *expiration);</b></p>
<p class=book>Each condition variable must be associated with a specific mutex, and with a predicate condition. When a thread waits on a condition variable it must always have the associated mutex locked. Remember that the condition variable wait operation will <i>unlock</i> the mutex for you before blocking the thread, and it will <i>relock</i> the mutex before returning to your code.</p>
<p class=book>All threads that wait on any one condition variable concurrently (at the same time) must specify the <i>same</i> associated mutex. Pthreads does not allow thread 1, for example, to wait on condition variable A specifying mutex A while thread 2 waits on condition variable A specifying mutex B. It is, however, perfectly reasonable for thread 1 to wait on condition variable A specifying mutex A while thread 2 waits on condition variable B specifying mutex A. That is, each condition variable must be associated, at any given time, with only one mutex—but a mutex may have any number of condition variables associated with it.</p>
<p class=book>It is important that you test the predicate after locking the appropriate mutex and before waiting on the condition variable. If a thread signals or broadcasts a condition variable while no threads are waiting, nothing happens. If some other thread calls pthread_cond_wait right after that, it will keep waiting regardless of the fact that the condition variable was just signaled, which means that if a thread waits when it doesn't have to, it may never wake up. Because the mutex remains locked until the thread is blocked on the condition variable, the predicate cannot become set between the predicate test and the wait—the mutex is locked and no other thread can change the shared data, including the predicate.</p>
<p class=book>Always test your predicate; and then test it again!</p>
<p class=book>It is equally important that you test the predicate again when the thread wakes up. You should always wait for a condition variable in a loop, to protect against program errors, multiprocessor races, and spurious wakeups. The following short program, cond.c, shows how to wait on a condition variable. Proper predicate loops are also shown in all of the examples in this book that use condition variables, for example, alarm_cond.c in Section 3.3.4.</p>
<p class=book><b>20-37</b> The wait_thread sleeps for a short time to allow the main thread to reach its condition wait before waking it, sets the shared predicate (data.value), and then signals the condition variable. The amount of time for which wait_thread will sleep is controlled by the hibernation variable, which defaults to one second.</p>
<p class=book><b>51-52</b> If the program was run with an argument, interpret the argument as an integer value, which is stored in hibernation. This controls the amount of time for which wait.thread will sleep before signaling the condition variable.</p>
<p class=book><b>68-83</b> The main thread calls pthread_cond_timedwait to wait for up to two seconds (from the current time). If hibernation has been set to a value of greater than two seconds, the condition wait will time out, returning ETIMEDOUT. If hibernation has been set to two, the main thread and wait_thread race, and, in principle, the result could differ each time you run the program. If hibernation is set to a value less than two, the condition wait should not time out.</p>
<p class=book>■ <b>cond.c</b></p>
<p class=book><CODE>1 #include &lt;pthread.h&gt;</CODE></p>
<p class=book><CODE>2 #include &lt;time.h&gt;</CODE></p>
<p class=book><CODE>3 #include "errors.h" 4</CODE></p>
<p class=book><CODE>5 typedef struct my_struct_tag {</CODE></p>
<p class=book><CODE>6 	pthread_mutex_t mutex;</CODE></p>
<p class=book><CODE>7 	pthread_cond_t cond;</CODE></p>
<p class=book><CODE>8 	int value;</CODE></p>
<p class=book><CODE>9 } my_struct_t;</CODE> </p>
<p class=book><CODE>10</CODE></p>
<p class=book><CODE>11 my_struct_t data = {</CODE></p>
<p class=book><CODE>12 	PTHREAD_MUTEX_INITIALIZER, PTHREAD_COND_INITIALIZER, 0};</CODE></p>
<p class=book><CODE>13</CODE></p>
<p class=book><CODE>14 int hibernation = 1; /* Default to 1 second */</CODE></p>
<p class=book><CODE>15</CODE></p>
<p class=book><CODE>16 /*</CODE></p>
<p class=book><CODE>17 * Thread start routine. It will set the main thread's predicate</CODE></p>
<p class=book><CODE>18 * and signal the condition variable.</CODE></p>
<p class=book><CODE>19 */</CODE></p>
<p class=book><CODE>20 void *</CODE></p>
<p class=book><CODE>21 wait_thread (void *arg)</CODE></p>
<p class=book><CODE>22 {</CODE></p>
<p class=book><CODE>23 int status;</CODE> </p>
<p class=book><CODE>24</CODE></p>
<p class=book><CODE>25 sleep (hibernation);</CODE></p>
<p class=book><CODE>26 status = pthread_mutex_lock (&data.mutex);</CODE></p>
<p class=book><CODE>27 if (status != 0)</CODE></p>
<p class=book><CODE>28 	err_abort (status, "Lock mutex");</CODE></p>
<p class=book><CODE>29 data.value = 1; /* Set predicate */</CODE></p>
<p class=book><CODE>30 status = pthread_cond_signal (&data.cond);</CODE></p>
<p class=book><CODE>31 if (status != 0)</CODE></p>
<p class=book><CODE>32 	err_abort (status, "Signal condition");</CODE></p>
<p class=book><CODE>33 status = pthread_mutex_unlock (&data.mutex);</CODE></p>
<p class=book><CODE>34 if (status != 0)</CODE></p>
<p class=book><CODE>35 	err_abort (status, "Unlock mutex");</CODE></p>
<p class=book><CODE>36 return NULL;</CODE></p>
<p class=book><CODE>37 }</CODE></p>
<p class=book><CODE>/* Protects access to value */ /* Signals change to value */ /* Access protected by mutex */</CODE></p>
<p class=book><CODE>38</CODE></p>
<p class=book><CODE>39 int main (int argc, char *argv[])</CODE></p>
<p class=book><CODE>40 {</CODE></p>
<p class=book><CODE>41 int status;</CODE></p>
<p class=book><CODE>42 pthread_t wait_thread_id;</CODE></p>
<p class=book><CODE>43 struct timespec timeout;</CODE> </p>
<p class=book><CODE>44</CODE></p>
<p class=book><CODE>45 /*</CODE></p>
<p class=book><CODE>46 * If an argument is specified, interpret it as the number</CODE></p>
<p class=book><CODE>47 * of seconds for wait_thread to sleep before signaling the</CODE></p>
<p class=book><CODE>48 * condition variable. You can play with this to see the</CODE></p>
<p class=book><CODE>49 * condition wait below time out or wake normally.</CODE></p>
<p class=book><CODE>50 */</CODE></p>
<p class=book><CODE>51 if (argc &gt; 1)</CODE></p>
<p class=book><CODE>52 	hibernation = atoi (argv[l]);</CODE> </p>
<p class=book><CODE>53</CODE></p>
<p class=book><CODE>54 /*</CODE></p>
<p class=book><CODE>55 * Create wait_thread.</CODE></p>
<p class=book><CODE>56 */</CODE></p>
<p class=book><CODE>57 status = pthread_create (</CODE></p>
<p class=book><CODE>58 	&wait_thread_id, NULL, wait_thread, NULL);</CODE></p>
<p class=book><CODE>59 if (status != 0)</CODE></p>
<p class=book><CODE>60 	err_abort (status, "Create wait thread");</CODE> </p>
<p class=book><CODE>61</CODE></p>
<p class=book><CODE>62 /*</CODE></p>
<p class=book><CODE>63 * Wait on the condition variable for 2 seconds, or until</CODE></p>
<p class=book><CODE>64 * signaled by the wait_thread. Normally, wait_thread</CODE></p>
<p class=book><CODE>65 * should signal. If you raise "hibernation" above 2</CODE></p>
<p class=book><CODE>66 * seconds, it will time out.</CODE></p>
<p class=book><CODE>67 */</CODE></p>
<p class=book><CODE>68 timeout.tv_sec = time (NULL) + 2;</CODE></p>
<p class=book><CODE>69 timeout.tv_nsec = 0;</CODE></p>
<p class=book><CODE>70 status = pthread_mutex_lock (&data.mutex);</CODE></p>
<p class=book><CODE>71 if (status != 0)</CODE></p>
<p class=book><CODE>72 err_abort (status, "Lock mutex");</CODE></p>
<p class=book><CODE>73</CODE></p>
<p class=book><CODE>74 while (data.value == 0) { </CODE></p>
<p class=book><CODE>75 	status = pthread_cond_timedwait (</CODE></p>
<p class=book><CODE>76 	&data.cond, &data.mutex, &timeout);</CODE></p>
<p class=book><CODE>77 if (status == ETIMEDOUT) {</CODE></p>
<p class=book><CODE>78 printf ("Condition wait timed out.\n");</CODE></p>
<p class=book><CODE>79 break;</CODE></p>
<p class=book><CODE>80 }</CODE></p>
<p class=book><CODE>81 else if (status != 0)</CODE></p>
<p class=book><CODE>82 err_abort (status, "Wait on condition");</CODE></p>
<p class=book><CODE>83 }</CODE> </p>
<p class=book><CODE>84</CODE></p>
<p class=book><CODE>85 if (data.value != 0)</CODE></p>
<p class=book><CODE>86 	printf ("Condition was signaled.\n");</CODE></p>
<p class=book><CODE>87 status = pthread_mutex_unlock (&data.mutex);</CODE></p>
<p class=book><CODE>88 if (status != 0)</CODE></p>
<p class=book><CODE>89 	err_abort (status, "Unlock mutex");</CODE></p>
<p class=book><CODE>90 return 0;</CODE></p>
<p class=book><CODE>91 }</CODE></p>
<p class=book>There are a lot of reasons why it is a good idea to write code that does not assume the predicate is always true on wakeup, but here are a few of the main reasons:</p>
<p class=book><b>Intercepted wakeups:</b> Remember that threads are asynchronous. Waking up from a condition variable wait involves locking the associated mutex. But what if some other thread acquires the mutex first? It may, for example, be checking the predicate before waiting itself. It doesn't have to wait, since the predicate is now true. If the predicate is "work available," it will accept the work. When it unlocks the mutex there may be no more work. It would be expensive, and usually counterproductive, to ensure that the latest awakened thread got the work.</p>
<p class=book><b>Loose predicates:</b> For a lot of reasons it is often easy and convenient to use approximations of actual state. For example, "there may be work" instead of "there is work." It is often much easier to signal or broadcast based on "loose predicates" than on the real "tight predicates." If you always test the tight predicates before and after waiting on a condition variable, you're free to signal based on the loose approximations when that makes sense. And your code will be much more robust when a condition variable is signaled or broadcast accidentally. Use of loose predicates or accidental wakeups may turn out to be a performance issue; but in many cases it won't make a difference.</p>
<p class=book><b>Spurious wakeups:</b> This means that when you wait on a condition variable, the wait may (occasionally) return when no thread specifically broadcast or signaled that condition variable. Spurious wakeups may sound strange, but on some multiprocessor systems, making condition wakeup completely predictable might substantially slow all condition variable operations. The race conditions that cause spurious wakeups should be considered rare.</p>
<p class=book>It usually takes only a few instructions to retest your predicate, and it is a good programming discipline. Continuing without retesting the predicate could lead to serious application errors that might be difficult to track down later. So don't make assumptions: Always wait for a condition variable in a while loop testing the predicate.</p>
<p class=book>You can also use the pthread_cond_timedwait function, which causes the wait to end with an ETIMEDOUT status after a certain time is reached. The time is an absolute clock time, using the POSIX.1b struct timespec format. The timeout is absolute rather than an interval (or "delta time") so that once you've computed the timeout it remains valid regardless of spurious or intercepted</p>
<p class=book>wakeups. Although it might seem easier to use an interval time, you'd have to recompute it every time the thread wakes up, before waiting again—which would require determining how long it had already waited.</p>
<p class=book>When a timed condition wait returns with the ETIMEDOUT error, you should test your predicate before treating the return as an error. If the condition for which you were waiting is true, the fact that it may have taken too long usually isn't important. Remember that a thread always relocks the mutex before returning from a condition wait, even when the wait times out. Waiting for a locked mutex after timeout can cause the timed wait to appear to have taken a lot longer than the time you requested.</p>


<a name=t60></a><h3 class=book>
3.3.3 Waking condition variable waiters
</h3>
<p class=book><b>int pthread_cond_signal (pthread_cond_t *cond);</b></p>
<p class=book><b>int pthread_cond_broadcast (pthread_cond_t *cond);</b></p>
<p class=book>Once you've got a thread waiting on a condition variable for some predicate, you'll probably want to wake it up. Pthreads provides two ways to wake a condition variable waiter. One is called "signal" and the other is called "broadcast." A signal operation wakes up a single thread waiting on the condition variable, while broadcast wakes up all threads waiting on the condition variable.</p>
<p class=book>The term "signal" is easily confused with the "POSIX signal" mechanisms that allow you to define "signal actions," manipulate "signal masks," and so forth. However, the term "signal," as we use it here, had independently become well established in threading literature, and even in commercial implementations, and the Pthreads working group decided not to change the term. Luckily, there are few situations where we might be tempted to use both terms together—it is a very good idea to avoid using signals in threaded programs when at all possible. If we are careful to say "signal a condition variable" or "POSIX signal" (or "UNIX signal") where there is any ambiguity, we are unlikely to cause anyone severe discomfort.</p>
<p class=book>It is easy to think of "broadcast" as a generalization of "signal," but it is more accurate to think of signal as an optimization of broadcast. Remember that it is never wrong to use broadcast instead of signal since waiters have to account for intercepted and spurious wakes. The only difference, in fact, is efficiency: A broadcast will wake additional threads that will have to test their predicate and resume waiting. But, in general, you can't replace a broadcast with a signal. "When in doubt, broadcast."</p>
<p class=book>Use signal when only one thread needs to wake up to process the changed state, and when any waiting thread can do so. If you use one condition variable for several program predicate conditions, you can't use the signal operation: you couldn't tell whether it would awaken a thread waiting for that predicate, or for</p>
<p class=book>another predicate. Don't try to get around that by resignaling the condition variable when you find the predicate isn't true. That might not pass on the signal as you expect; a spurious or intercepted wakeup could result in a series of pointless resignals.</p>
<p class=book>If you add a single item to a queue, and only threads waiting for an item to appear are blocked on the condition variable, then you should probably use a signal. That'll wake up a single thread to check the queue and let the others sleep undisturbed, avoiding unnecessary context switches. On the other hand, if you add more than one item to the queue, you will probably need to broadcast. For examples of both broadcast and signal operations on condition variables, check out the "read/write lock" package in Section 7.1.2.</p>
<p class=book>Although you must have the associated mutex locked to wait on a condition variable, you can signal (or broadcast) a condition variable with the associated mutex unlocked if that is more convenient. The advantage of doing so is that, on many systems, this may be more efficient. When a waiting thread awakens, it must first lock the mutex. If the thread awakens while the signaling thread holds the mutex, then the awakened thread must immediately block on the mutex— you've gone through two context switches to get back where you started.</p>
<p class=book>Weighing on the other side is the fact that, if the mutex is not locked, any thread (not only the one being awakened) can lock the mutex prior to the thread being awakened. This race is one source of intercepted wakeups. A lower-priority thread, for example, might lock the mutex while another thread was about to awaken a very high-priority thread, delaying scheduling of the high-priority thread. If the mutex remains locked while signaling, this cannot happen—the high-priority waiter will be placed before the lower-priority waiter on the mutex, and will be scheduled first.</p>


<a name=t61></a><h3 class=book>
3.3.4 One final alarm program
</h3>
<p class=book>It is time for one final version of our simple alarm program. In alarm_ mutex.c, we reduced resource utilization by eliminating the use of a separate execution context (thread or process) for each alarm. Instead of separate execution contexts, we used a single thread that processed a list of alarms. There was one problem, however, with that approach—it was not responsive to new alarm commands. It had to finish waiting for one alarm before it could detect that another had been entered onto the list with an earlier expiration time, for example, if one entered the commands "10 message 1" followed by "5 message 2."</p>
<p class=book>*There is an optimization, which I've called "wait morphing," that moves a thread directly from the condition variable wait queue to the mutex wait queue in this case, without a context switch, when the mutex is locked. This optimization can produce a substantial performance benefit for many applications.</p>
<p class=book>Now that we have added condition variables to our arsenal of threaded programming tools, we will solve that problem. The new version, creatively named alarm_cond.c uses a timed condition wait rather than sleep to wait for an alarm expiration time. When main inserts a new entry at the head of the list, it signals the condition variable to awaken alarm_thread immediately. The alarm_thread then requeues the alarm on which it was waiting, to sort it properly with respect to the new entry, and tries again.</p>
<p class=book><b>20,22</b> Part 1 shows the declarations for alarm_cond.c. There are two additions to this section, compared to alarm_mutex.c: a condition variable called alarm_cond and the current_alarm variable, which allows main to determine the expiration time of the alarm on which alarm_thread is currently waiting. The current_alarm variable is an optimization—main does not need to awaken alarm_thread unless it is either idle, or waiting for an alarm later than the one main has just inserted.</p>
<p class=book>■ <b>alarm_cond.c</b> <b>part 1 declarations</b></p>
<p class=book><CODE>1 #include &lt;pthread.h&gt;</CODE></p>
<p class=book><CODE>2 #include &lt;time.h&gt;</CODE></p>
<p class=book><CODE>3 #include "errors.h"</CODE></p>
<p class=book><CODE>4</CODE></p>
<p class=book><CODE>5 /*</CODE></p>
<p class=book><CODE>6 * The "alarm" structure now contains the time_t (time since the</CODE></p>
<p class=book><CODE>7 * Epoch, in seconds) for each alarm, so that they can be</CODE></p>
<p class=book><CODE>8 * sorted. Storing the requested number of seconds would not be</CODE></p>
<p class=book><CODE>9 * enough, since the "alarm thread" cannot tell how long it has</CODE></p>
<p class=book><CODE>10 * been on the list.</CODE></p>
<p class=book><CODE>11 */</CODE></p>
<p class=book><CODE>12 typedef struct alarm_tag {</CODE></p>
<p class=book><CODE>13 struct alarm_tag *link;</CODE></p>
<p class=book><CODE>14 	int seconds;</CODE></p>
<p class=book><CODE>15 	time_t time; /* seconds from EPOCH */</CODE></p>
<p class=book><CODE>16 	char message[64];</CODE></p>
<p class=book><CODE>17 } alarm_t;</CODE> </p>
<p class=book><CODE>18</CODE></p>
<p class=book><CODE>19 pthread_mutex_t alarm_mutex = PTHREAD_MUTEX_INITIALIZER;</CODE></p>
<p class=book><CODE>20 pthread_cond_t alarm_cond = PTHREAD_COND_INITIALIZER;</CODE></p>
<p class=book><CODE>21 alarm_t *alarm_list = NULL;</CODE></p>
<p class=book><CODE>22 time_t current_alarm = 0;</CODE></p>
<p class=book>Part 2 shows the new function alarm_insert. This function is nearly the same as the list insertion code from alarm_mutex.c, except that it signals the condition variable alarm_cond when necessary. I made alarm_insert a separate function because now it needs to be called from two places—once by main to insert a new alarm, and now also by alarm_thread to reinsert an alarm that has been "preempted" by a new earlier alarm.</p>
<p class=book><b>9-14</b> I have recommended that mutex locking protocols be documented, and here is an example: The alarm_insert function points out explicitly that it must be called with the alarm_mutex locked.</p>
<p class=book><b>48-53</b> If current_alarm (the time of the next alarm expiration) is 0. then the alarm_ thread is not aware of any outstanding alarm requests, and is waiting for new work. If current_alarm has a time greater than the expiration time of the new alarm, then alarm_thread is not planning to look for new work soon enough to handle the new alarm. In either case, signal the alarm_cond condition variable so that alarm_thread will wake up and process the new alarm.</p>
<p class=book>■ <b>alarm_cond.c part 2 alarm_insert</b></p>
<p class=book><CODE>1 /*</CODE></p>
<p class=book><CODE>2 * Insert alarm entry on list, in order.</CODE></p>
<p class=book><CODE>3 */</CODE></p>
<p class=book><CODE>4 void alarm_insert (alarm_t *alarm)</CODE></p>
<p class=book><CODE>5 {</CODE></p>
<p class=book><CODE>6 int status;</CODE></p>
<p class=book><CODE>7 alarm_t **last, *next;</CODE> </p>
<p class=book><CODE>8</CODE></p>
<p class=book><CODE>9 /*</CODE></p>
<p class=book><CODE>10 * LOCKING PROTOCOL:</CODE></p>
<p class=book><CODE>11 *</CODE></p>
<p class=book><CODE>12 * This routine requires that the caller have locked the</CODE></p>
<p class=book><CODE>13 * alarm_mutex!</CODE></p>
<p class=book><CODE>14 */</CODE></p>
<p class=book><CODE>15 last = &alarm_list;</CODE></p>
<p class=book><CODE>16 next = *last;</CODE></p>
<p class=book><CODE>17 while (next != NULL) {</CODE></p>
<p class=book><CODE>18 if (next-&gt;time &gt;= alarm-&gt;time) {</CODE></p>
<p class=book><CODE>19 	alarm-&gt;link = next;</CODE></p>
<p class=book><CODE>20 	*last = alarm;</CODE></p>
<p class=book><CODE>21 	break;</CODE></p>
<p class=book><CODE>22 }</CODE></p>
<p class=book><CODE>23 last = &next-&gt;link;</CODE></p>
<p class=book><CODE>24 next = next-&gt;link;</CODE></p>
<p class=book><CODE>25 }</CODE></p>
<p class=book><CODE>26 /*</CODE></p>
<p class=book><CODE>27 * If we reached the end of the list, insert the new alarm</CODE></p>
<p class=book><CODE>28 * there. ("next" is NULL, and "last" points to the link</CODE></p>
<p class=book><CODE>29 * field of the last item, or to the list header.)</CODE></p>
<p class=book><CODE>30 */</CODE></p>
<p class=book><CODE>31 if (next == NULL) {</CODE></p>
<p class=book><CODE>32 	*last = alarm;</CODE></p>
<p class=book><CODE>33 	alarm-&gt;link = NULL;</CODE></p>
<p class=book><CODE>34 }</CODE></p>
<p class=book><CODE>35 #ifdef DEBUG</CODE></p>
<p class=book><CODE>36 printf ("[list: ");</CODE></p>
<p class=book><CODE>37 for (next = alarm_list; next != NULL; next = next-&gt;link)</CODE></p>
<p class=book><CODE>38 printf ("%d(%d)[\"%s\"] ", next-&gt;time,</CODE></p>
<p class=book><CODE>39 next-&gt;time - time (NULL), next-&gt;message);</CODE></p>
<p class=book><CODE>40 printf ("]\n");</CODE></p>
<p class=book><CODE>41 #endif</CODE></p>
<p class=book><CODE>42 /*</CODE></p>
<p class=book><CODE>43 * Wake the alarm thread if it is not busy (that is, if</CODE></p>
<p class=book><CODE>44 * current_alarm is 0, signifying that it's waiting for</CODE></p>
<p class=book><CODE>45 * work), or if the new alarm comes before the one on</CODE></p>
<p class=book><CODE>46 * which the alarm thread is waiting.</CODE></p>
<p class=book><CODE>47 */</CODE></p>
<p class=book><CODE>48 if (current_alarm == 0 || alarm-&gt;time &lt; current_alarm) {</CODE></p>
<p class=book><CODE>49 current_alarm = alarm-&gt;time;</CODE></p>
<p class=book><CODE>50 status = pthread_cond_signal (&alarm_cond);</CODE></p>
<p class=book><CODE>51 if (status != 0)</CODE></p>
<p class=book><CODE>52 err_abort (status, "Signal cond");</CODE></p>
<p class=book><CODE>53 }</CODE></p>
<p class=book><CODE>54 }</CODE></p>
<p class=book>Part 3 shows the alarm_thread function, the start function for the "alarm server" thread. The general structure of alarm_thread is very much like the alarm_thread in alarm_mutex.c. The differences are due to the addition of the condition variable.</p>
<p class=book><b>26-31</b> If the alarm_list is empty, alarm_mutex.c could do nothing but sleep anyway, so that main would be able to process a new command. The result was that it could not see a new alarm request for at least a full second. Now, alarm_thread instead waits on the alarm_cond condition variable, with no timeout. It will "sleep" until you enter a new alarm command, and then main will be able to awaken it immediately. Setting current_alarm to 0 tells main that alarm_thread is idle. Remember that pthread_cond_wait unlocks the mutex before waiting, and relocks the mutex before returning to the caller.</p>
<p class=book><b>35</b> The new variable expired is initialized to 0; it will be set to 1 later if the timed condition wait expires. This makes it a little easier to decide whether to print the current alarm's message at the bottom of the loop.</p>
<p class=book><b>36-42</b> If the alarm we've just removed from the list hasn't already expired, then we need to wait for it. Because we're using a timed condition wait, which requires a POSIX.1b struct timespec, rather than the simple integer time required by sleep, we convert the expiration time. This is easy, because a struct timespec has two members—tv_sec is the number of seconds since the Epoch, which is exactly what we already have from the time function, and tv_nsec is an additional count of nanoseconds. We will just set tv_nsec to 0, since we have no need of the greater resolution.</p>
<p class=book><b>43</b> Record the expiration time in the current_alarm variable so that main can determine whether to signal alarm_cond when a new alarm is added.</p>
<p class=book><b>44-53</b> Wait until either the current alarm has expired, or main requests that alarm_ thread look for a new, earlier alarm. Notice that the predicate test is split here, for convenience. The expression in the while statement is only half the predicate, detecting that main has changed current_alarm by inserting an earlier timer. When the timed wait returns ETIMEDOUT, indicating that the current alarm has expired, we exit the while loop with a break statement at line 49.</p>
<p class=book><b>54-55</b> If the while loop exited when the current alarm had not expired, main must have asked alarm_thread to process an earlier alarm. Make sure the current alarm isn't lost by reinserting it onto the list.</p>
<p class=book><b>57</b> If we remove from alarm_list an alarm that has already expired, just set the expired variable to 1 to ensure that the message is printed.</p>
<p class=book>■ <b>alarm_cond.c part 3 alarm_routine</b></p>
<p class=book><CODE>1 /*</CODE></p>
<p class=book><CODE>2 * The alarm thread's start routine.</CODE></p>
<p class=book><CODE>3 */</CODE></p>
<p class=book><CODE>4 void *alarm_thread (void *arg)</CODE></p>
<p class=book><CODE>5 {</CODE></p>
<p class=book><CODE>6 alarm_t *alarm;</CODE></p>
<p class=book><CODE>7 struct timespec cond_time;</CODE></p>
<p class=book><CODE>8 time_t now;</CODE></p>
<p class=book><CODE>9 int status, expired;</CODE></p>
<p class=book><CODE>10</CODE></p>
<p class=book><CODE>11 /*</CODE></p>
<p class=book><CODE>12 * Loop forever, processing commands. The alarm thread will</CODE></p>
<p class=book><CODE>13 * be disintegrated when the process exits. Lock the mutex</CODE></p>
<p class=book><CODE>14 * at the start — it will be unlocked during condition</CODE></p>
<p class=book><CODE>15 * waits, so the main thread can insert alarms.</CODE></p>
<p class=book><CODE>16 */</CODE></p>
<p class=book><CODE>17 status = pthread_mutex_lock (&alarm_mutex);</CODE></p>
<p class=book><CODE>18 if (status != 0<b>)</b></CODE></p>
<p class=book><CODE>19 	err_abort (status, "Lock mutex");</CODE></p>
<p class=book><CODE>20 while (1) {</CODE></p>
<p class=book><CODE>21 /*</CODE></p>
<p class=book><CODE>22 * If the alarm list is empty, wait until an alarm is</CODE></p>
<p class=book><CODE>23 * added. Setting current_alarm to 0 informs the insert</CODE></p>
<p class=book><CODE>24 * routine that the thread is not busy.</CODE></p>
<p class=book><CODE>25 */</CODE></p>
<p class=book><CODE>26 	current_alarm = 0;</CODE></p>
<p class=book><CODE>27 	while (alarm_list == NULL) {</CODE></p>
<p class=book><CODE>28 		status = pthread_cond_wait (&alarm_cond, &alarm_mutex);</CODE></p>
<p class=book><CODE>29 		if (status != 0)</CODE></p>
<p class=book><CODE>30 			err_abort (status, "Wait on cond");</CODE></p>
<p class=book><CODE>31 	}</CODE></p>
<p class=book><CODE>32 	alarm = alarm_list;</CODE></p>
<p class=book><CODE>33 	alarm_list = alarm-&gt;link;</CODE></p>
<p class=book><CODE>34 	now = time (NULL);</CODE></p>
<p class=book><CODE>35 	expired = 0;</CODE></p>
<p class=book><CODE>36 	if (alarm-&gt;time &gt; now) {</CODE></p>
<p class=book><CODE>37 #ifdef DEBUG</CODE></p>
<p class=book><CODE>38 		printf ("[waiting: %d(%d)\"%s\"]\n", alarm-&gt;time,</CODE></p>
<p class=book><CODE>39 			alarm-&gt;time - time (NULL), alarm-&gt;message);</CODE></p>
<p class=book><CODE>40 #endif</CODE></p>
<p class=book><CODE>41 		cond_time.tv_sec = alarm-&gt;time;</CODE></p>
<p class=book><CODE>42 		cond_time.tv_nsec = 0;</CODE></p>
<p class=book><CODE>43 		current_alarm = alarm-&gt;time;</CODE></p>
<p class=book><CODE>44 		while (current_alarm == alarm-&gt;time) {</CODE></p>
<p class=book><CODE>45 			status = pthread_cond_timedwait (</CODE></p>
<p class=book><CODE>46 				&alarm_cond, &alarm_mutex, &cond_time);</CODE></p>
<p class=book><CODE>47 			if (Status == ETIMEDOUT) {</CODE></p>
<p class=book><CODE>48 				expired = 1;</CODE></p>
<p class=book><CODE>49 				break;</CODE></p>
<p class=book><CODE>50 			}</CODE></p>
<p class=book><CODE>51 			if (status != 0)</CODE></p>
<p class=book><CODE>52 				err_abort (status, "Cond timedwait");</CODE></p>
<p class=book><CODE>53 		}</CODE></p>
<p class=book><CODE>54 		if (!expired)</CODE></p>
<p class=book><CODE>55 			alarm_insert (alarm);</CODE></p>
<p class=book><CODE>56 	} else</CODE></p>
<p class=book><CODE>57 		expired = 1;</CODE></p>
<p class=book><CODE>58 	if (expired) {</CODE></p>
<p class=book><CODE>59 		printf ("(%d) %s\n", alarm-&gt;seconds, alarm-&gt;message);</CODE></p>
<p class=book><CODE>60 		free (alarm);</CODE></p>
<p class=book><CODE>61 	}</CODE></p>
<p class=book><CODE>62 }</CODE></p>
<p class=book><CODE>63 }</CODE></p>
<p class=book>Part 4 shows the final section of alarm_cond.c, the main program. It is nearly identical to the main function from alarm_mutex.c. </p>
<p class=book><b>38</b> Because the condition variable signal operation is built into the new alarm_ insert function, we call alarm_insert rather than inserting a new alarm directly.</p>
<p class=book>■ <b>alarm_cond.c part 4 main</b></p>
<p class=book><CODE>1 int main (int argc, char *argv[])</CODE></p>
<p class=book><CODE>2 {</CODE></p>
<p class=book><CODE>3 int status;</CODE></p>
<p class=book><CODE>4 char line[128];</CODE></p>
<p class=book><CODE>5 alarm_t *alarm;</CODE></p>
<p class=book><CODE>6 pthread_t thread; 7</CODE></p>
<p class=book><CODE>8 status = pthread_create (</CODE></p>
<p class=book><CODE>9 &thread, NULL, alarm thread, NULL);</CODE></p>
<p class=book><CODE>10 if (status != 0)</CODE></p>
<p class=book><CODE>11 	err_abort (status, "Create alarm thread");</CODE></p>
<p class=book><CODE>12 while (1) {</CODE></p>
<p class=book><CODE>13 	printf ("Alarm&gt; ");</CODE></p>
<p class=book><CODE>14 	if (fgets (line, sizeof (line), stdin) == NULL) exit (0);</CODE></p>
<p class=book><CODE>15 	if (strlen (line) &lt;= 1) continue;</CODE></p>
<p class=book><CODE>16 	alarm = (alarm_t*)malloc (sizeof (alarm_t));</CODE></p>
<p class=book><CODE>17 	if (alarm == NULL)</CODE></p>
<p class=book><CODE>18 		errno_abort ("Allocate alarm");</CODE> </p>
<p class=book><CODE>19</CODE></p>
<p class=book><CODE>20 /*</CODE></p>
<p class=book><CODE>21 * Parse input line into seconds (%d) and a message</CODE></p>
<p class=book><CODE>22 * (%64[^\n]), consisting of up to 64 characters</CODE></p>
<p class=book><CODE>23 * separated from the seconds by whitespace.</CODE></p>
<p class=book><CODE>24 */</CODE></p>
<p class=book><CODE>25 	if (sscanf (line, "%d %64[^\n]",</CODE></p>
<p class=book><CODE>26 		&alarm-&gt;seconds, alarm-&gt;message) &lt; 2) {</CODE></p>
<p class=book><CODE>27 		fprintf (stderr, "Bad command\n");</CODE></p>
<p class=book><CODE>28 		free (alarm);</CODE></p>
<p class=book><CODE>29 	} else {</CODE></p>
<p class=book><CODE>30 		status = pthread_mutex_lock (&alarm_mutex);</CODE></p>
<p class=book><CODE>31 		if (status != 0)</CODE></p>
<p class=book><CODE>32 			err_abort (status, "Lock mutex");</CODE></p>
<p class=book><CODE>33 		alarm-&gt;time = time (NULL) + alarm-&gt;seconds;</CODE></p>
<p class=book><CODE>34 /*</CODE></p>
<p class=book><CODE>35 * Insert the new alarm into the list of alarms,</CODE></p>
<p class=book><CODE>36 * sorted by expiration time.</CODE></p>
<p class=book><CODE>37 */</CODE></p>
<p class=book><CODE>38 		alarm_insert (alarm);</CODE></p>
<p class=book><CODE>39 		status = pthread_mutex_unlock (&alarm_mutex);</CODE></p>
<p class=book><CODE>40 		if (status != 0)</CODE></p>
<p class=book><CODE>41 			err_abort (status, "Unlock mutex");</CODE></p>
<p class=book><CODE>42 	}</CODE></p>
<p class=book><CODE>43 }</CODE></p>
<p class=book><CODE>44 }</CODE></p>



<a name=t62></a><h3 class=book>
3.4 Memory visibility between threads
</h3>
<blockquote class="epigraph">
<p class=book>The moment Alice appeared, she was appealed to by all three to settle the question, and they repeated their arguments to her, though, as they all spoke at once, she found it very hard to make out exactly what they said.</p>
<blockquote class=book><i>— <i>Lewis Carroll, Alice's Adventures in Wonderland</i></i></blockquote>
</blockquote>
<p class=book>In this chapter we have seen how you should use mutexes and condition variables to synchronize (or "coordinate") thread activities. Now we'll journey off on a tangent, for just a few pages, and see what is really meant by "synchronization" in the world of threads. It is more than making sure two threads don't write to the same location at the same time, although that's part of it. As the title of this section implies, it is about how threads see the computer's memory.</p>
<p class=book>Pthreads provides a few basic rules about memory visibility. You can count on all implementations of the standard to follow these rules:</p>
<p class=book>1. Whatever memory values a thread can see when it calls pthread_create can also be seen by the new thread when it starts. Any data written to memory after the call to pthread_create may not necessarily be seen by the new thread, even if the write occurs before the thread starts.</p>
<p class=book>2. Whatever memory values a thread can see when it unlocks a mutex, either directly or by waiting on a condition variable, can also be seen by any thread that later locks the same mutex. Again, data written after the mutex is unlocked may not necessarily be seen by the thread that locks the mutex, even if the write occurs before the lock.</p>
<p class=book>3. Whatever memory values a thread can see when it terminates, either by cancellation, returning from its start function, or by calling pthread_exit, can also be seen by the thread that joins with the terminated thread by calling pthread_join. And, of course, data written after the thread terminates may not necessarily be seen by the thread that joins, even if the write occurs before the join.</p>
<p class=book>4. Whatever memory values a thread can see when it signals or broadcasts a condition variable can also be seen by any thread that is awakened by that signal or broadcast. And, one more time, data written after the signal or broadcast may not necessarily be seen by the thread that wakes up, even if the write occurs before it awakens.</p>
<p class=book>Figures 3.5 and 3.6 demonstrate some of the consequences. So what should you, as a programmer, do?</p>
<p class=book>First, where possible make sure that only one thread will ever access a piece of data. A thread's registers can't be modified by another thread. A thread's stack and heap memory a thread allocates is private unless the thread communicates pointers to that memory to other threads. Any data you put in register or auto variables can therefore be read at a later time with no more complication than in a completely synchronous program. Each thread <i>is</i> synchronous with itself. The less data you share between threads, the less work you have to do.</p>
<p class=book>Second, any time two threads need to access the same data, you have to apply one of the Pthreads memory visibility rules, which, in most cases, means using a mutex. This is not only to protect against multiple writes—even when a thread only reads data it must use a mutex to ensure that it sees the most recent value of the data written while the mutex was locked.</p>
<p class=book>This example does everything correctly. The left-hand code (running in thread A) sets the value of several variables while it has a mutex locked. The right-hand code (running in thread B) reads those values, also while holding the mutex.</p>
<TABLE>
<TR>
<TD align = "left" ><b>Thread A</b> </TD>
<TD align = "left" ><b>Thread B</b></TD>
</TR>
<TR>
<TD align = "left" >pthread_mutex_lock (&mutex1);</TD>
<TD></TD>
</TR>
<TR>
<TD align = "left" >variableA = 1; variableB = 2;</TD>
<TD align = "left" >pthread mutex lock (&mutex1);</TD>
</TR>
<TR>
<TD align = "left" >pthread mutex unlock (&mutex1);</TD>
<TD></TD>
</TR>
<TR>
<TD></TD>
<TD align = "left" >localA = variableA; localB = variableB;</TD>
</TR>
<TR>
<TD></TD>
<TD align = "left" >pthread mutex unlock (&mutex1);</TD>
</TR>
</TABLE>
<p class=book><b>FIGURE 3.5</b> <i>Correct memory visibility</i></p>
<p class=book>Rule 2: visibility from pthread_mutex_unlock to pthread_mutex_lock. When thread B returns from pthread_mutex_lock, it will see the same values for variableA and variableB that thread A had seen at the time it called pthread_ mutex_unlock. That is, 1 and 2. respectively.</p>
<p class=book>This example shows an error. The left-hand code (running in thread A) sets the value of variables after unlocking the mutex. The right-hand code (running in thread B) reads those values while holding the mutex.</p>
<TABLE>
<TR>
<TD align = "left" ><b>Thread A</b> </TD>
<TD align = "left" ><b>Thread B</b></TD>
</TR>
<TR>
<TD align = "left" >pthread_mutex_lock (&mutex1);</TD>
<TD align = "left" >pthread mutex lock (&mutex1);</TD>
</TR>
<TR>
<TD align = "left" >variableA = 1;</TD>
<TD></TD>
</TR>
<TR>
<TD align = "left" >pthread_mutex_unlock (&mutex1); variableB = 2;</TD>
<TD></TD>
</TR>
<TR>
<TD></TD>
<TD align = "left" >localA = variableA; localB = variableB</TD>
</TR>
<TR>
<TD></TD>
<TD align = "left" >; pthread mutex_unlock (&mutex1);</TD>
</TR>
</TABLE>
<p class=book><b>FIGURE 3.6</b> <i>Incorrect memory visibility</i></p>
<p class=book>Rule 2: visibility from pthread_mutex_unlock to pthread_mutex_lock. When thread B returns from pthread_mutex_lock, it will see the same values for variableA and variableB that thread A had seen at the time it called pthread_ mutex_unlock. That is, it will see the value 1 for variableA, but may not see the value 2 for variableB since that was written after the mutex was unlocked.</p>
<p class=book>As the rules state, there are specific cases where you do not need to use a mutex to ensure visibility. If one thread sets a global variable, and then creates a new thread that reads the same variable, you know that the new thread will not see an old value. But if you create a thread and <i>then</i> set some variable that the new thread reads, the thread may not see the new value, even if the creating thread succeeds in writing the new value before the new thread reads it.</p>
<p class=book>Warning! We are now descending below the Pthreads API into details of hardware memory architecture that you may prefer not to know. You may want to skip this explanation for now and come back later.</p>
<p class=book>If you are willing to just trust me on all that {or if you've had enough for now), you may now skip past the end of this section. This book is not about multiprocessor memory architecture, so I will just skim the surface—but even so, the details are a little deep, and if you don't care right now, you do not need to worry about them yet. You will probably want to come back later and read the rest, though, when you have some time.</p>
<p class=book>In a single-threaded, fully synchronous program, it is "safe" to read or write any memory at any time. That is, if the program writes a value to some memory address, and later reads from that memory address, it will always receive the last value that it wrote to that address.</p>
<p class=book>When you add asynchronous behavior (which includes multiprocessors) to the program, the assumptions about memory visibility become more complicated. For example, an asynchronous signal could occur at any point in the program's execution. If the program writes a value to memory, a signal handler runs and writes a different value to the same memory address, when the main program resumes and reads the value, it may not receive the value it wrote.</p>
<p class=book>That's not usually a major problem, because you go to a lot of trouble to declare and use signal handlers. They run "specialized" code in a distinctly different environment from the main program. Experienced programmers know that they should write global data only with extreme care, and it is possible to keep track of what they do. If that becomes awkward, you block the signal around areas of code that use the global data.</p>
<p class=book>When you add multiple threads to the program the asynchronous code is no longer special. Each thread runs normal program code, and all in the same unrestricted environment. You can hardly ever be sure you always know what each thread may be doing. It is likely that they will all read and write some of the same data. Your threads may run at unpredictable times or even simultaneously on different processors. And that's when things get interesting.</p>
<p class=book>By the way, although we are talking about programming with multiple threads, none of the problems outlined in this section is specific to threads. Rather, they are artifacts of memory architecture design, and they apply to any situation where two "things" independently access the same memory. The two things may be threads running on separate processors, but they could instead be processes running on separate processors and using shared memory. Or one "thing" might be code running on a uniprocessor, while an independent I/O controller reads or writes the same memory.</p>
<p class=book>A memory address can hold only one value at a time; don't let threads "race" to get there first.</p>
<p class=book>When two threads write different values to the same memory address, one after the other, the final state of memory is the same as if a single thread had</p>
<p class=book>written those two values in the same sequence. Either way only one value remains in memory. The problem is that it becomes difficult to know which write occurred last. Measuring some absolute external time base, it may be obvious that "processor B" wrote the value "2" several microseconds after "processor A" wrote the value "1." That doesn't mean the final state of memory will have a "2."</p>
<p class=book>Why? Because we haven't said anything about how the machine's cache and memory bus work. The processors probably have cache memory, which is just fast, local memory used to keep quickly accessible copies of data that were recently read from main memory. In a write-back cache system, data is initially written only to cache, and copied ("flushed") to main memory at some later time. In a machine that doesn't guarantee read/write ordering, each cache block may be written whenever the processor finds it convenient. If two processors write different values to the same memory address, each processor's value will go into its own cache. Eventually both values will be written to main memory, but at essentially random times, not directly related to the order in which the values were written to the respective processor caches.</p>
<p class=book>Even two writes from within a single thread (processor) need not appear in memory in the same order. The memory controller may find it faster, or just more convenient, to write the values in "reverse" order, as shown in Figure 3.7. They may have been cached in different cache blocks, for example, or interleaved to different memory banks. In general, there's no way to make a program aware of these effects. If there was, a program that relied on them might not run correctly on a different model of the same processor family, much less on a different type of computer.</p>
<p class=book>The problems aren't restricted to two threads <i>writing</i> memory. Imagine that one thread writes a value to a memory address on one processor, and then another thread reads from that memory address on another processor. It may seem obvious that the thread will see the last value written to that address, and on some hardware that will be true. This is sometimes called "memory coherence" or "read/write ordering." But it is complicated to ensure that sort of synchronization between processors. It slows the memory system and the overhead provides no benefit to most code. Many modern computers (usually among the fastest) don't guarantee any ordering of memory accesses between different processors, unless the program uses special instructions commonly known as <i>memory barriers.</i></p>
<TABLE>
<TR>
<TD align = "left" ><b>Time</b></TD>
<TD align = "left" ><b>Thread 1</b></TD>
<TD align = "left" ><b>Thread 2</b></TD>
</TR>
<TR>
<TD align = "left" >t</TD>
<TD align = "left" >write "1" to address 1 (cache)</TD>
<TD></TD>
</TR>
<TR>
<TD align = "left" >t+1</TD>
<TD align = "left" >write "2" to address 2 (cache)</TD>
<TD align = "left" >read "0" from address 1</TD>
</TR>
<TR>
<TD align = "left" >t+2</TD>
<TD align = "left" >cache system flushes address 2</TD>
<TD></TD>
</TR>
<TR>
<TD align = "left" >t+3</TD>
<TD></TD>
<TD align = "left" >read "2" from address 2</TD>
</TR>
<TR>
<TD align = "left" >t+4</TD>
<TD align = "left" >cache system flushes address 1</TD>
<TD></TD>
</TR>
</TABLE>
<p class=book><b>FIGURE 3.7</b> <i>Memory ordering without synchronization</i></p>
<p class=book>Memory accesses in these computers are, at least in principle, queued to the memory controller, and may be processed in whatever order becomes most efficient. A read from an address that is not in the processor's cache may be held waiting for the cache fill, while later reads complete. A write to a "dirty" cache line, which requires that old data be flushed, may be held while later writes complete. A memory barrier ensures that all memory accesses that were initiated by the processor prior to the memory barrier have completed before any memory accesses initiated after the memory barrier can complete.</p>
<p class=book><b>I</b> A "memory barrier" is a moving wall,not a "cache flush" command.</p>
<p class=book>A common misconception about memory barriers is that they "flush" values to main memory, thus ensuring that the values are visible to other processors. That is not the case, however. What memory barriers do is ensure an order between sets of operations. If each memory access is an item in a queue, you can think of a memory barrier as a special queue token. Unlike other memory accesses, however, the memory controller cannot remove the barrier, or look past it, until it has completed all previous accesses.</p>
<p class=book>A mutex lock, for example, begins by locking the mutex, and completes by issuing a memory barrier. The result is that any memory accesses issued while the mutex is locked cannot complete before other threads can see that the mutex was locked. Similarly, a mutex unlock begins by issuing a memory barrier and completes by unlocking the mutex, ensuring that memory accesses issued while the mutex is locked cannot complete after other threads can see that the mutex is unlocked.</p>
<p class=book>This memory barrier model is the logic behind my description of the Pthreads memory rules. For each of the rules, we have a "source" event, such as a thread calling pthread_mutex_unlock, and a "destination" event, such as another thread returning from pthread_mutex_lock. The passage of "memory view" from the first to the second occurs because of the memory barriers carefully placed in each.</p>
<p class=book>Even without read/write ordering and memory barriers, it may seem that writes to a single memory address must be atomic, meaning that another thread will always see either the intact original value or the intact new value. But that's not always true, either. Most computers have a natural memory granularity, which depends on the organization of memory and the bus architecture. Even if the processor naturally reads and writes 8-bit units, memory transfers may occur in 32- or 64-bit "memory units."</p>
<p class=book>That may mean that 8-bit writes aren't atomic with respect to other memory operations that overlap the same 32- or 64-bit unit. Most computers write the full memory unit (say, 32 bits) that contains the data you're modifying. If two threads write different 8-bit values within the same 32-bit memory unit, the result may be that the last thread to write the memory unit specifies the value of both bytes, overwriting the value supplied by the first writer. Figure 3.8 shows this effect.</p>
<img border=0 style='spacing 9px;' src="img_9.png">
<p class=book><b>FIGURE 3.8</b> <i>Memory conflict</i></p>
<p class=book>If a variable crosses the boundary between memory units, which can happen if the machine supports unaligned memory access, the computer may have to send the data in two bus transactions. An unaligned 32-bit value, for example, may be sent by writing the two adjacent 32-bit memory units. If either memory unit involved in the transaction is simultaneously written from another processor, half of the value may be lost. This is called "word tearing," and is shown in Figure 3.9.</p>
<p class=book>We have finally returned to the advice at the beginning of this section: If you want to write portable Pthreads code, you will always guarantee correct memory visibility by using the Pthreads memory visibility rules instead of relying on any assumptions regarding the hardware or compiler behavior. But now, at the bottom of the section, you have some understanding of why this is true. For a substantially more in-depth treatment of multiprocessor memory architecture, refer to <i>UNIX Systems for Modern Architectures[Schimmel, 1994].</i></p>
<p class=book>Figure 3.10 shows the same sequence as Figure 3.7, but it uses a mutex to ensure the desired read/write ordering. Figure3.10 does not show the cache flush steps that are shown in Figure 3.7, because those steps are no longer relevant. Memory visibility is guaranteed by passing mutex ownership in steps t+3 and t+4, through the associated memory barriers. That is, when thread 2 has</p>
<img border=0 style='spacing 9px;' src="img_10.png">
<br>
<p class=book><b>FIGURE 3.9</b> <i>Word tearing</i></p>
<p class=book>successfully locked the mutex previously unlocked by thread 1, thread 2 is guaranteed to see memory values "at least as recent" as the values visible to thread 1 at the time it unlocked the mutex.</p>
<TABLE>
<TR>
<TD align = "left" ><b>Time</b></TD>
<TD align = "left" ><b>Thread 1</b></TD>
<TD align = "left" ><b>Thread 2</b></TD>
</TR>
<TR>
<TD align = "left" >t</TD>
<TD align = "left" >lock mutex (memory barrier)</TD>
<TD></TD>
</TR>
<TR>
<TD align = "left" >t+1</TD>
<TD align = "left" >write "1" to address 1 (cache)</TD>
<TD></TD>
</TR>
<TR>
<TD align = "left" >t+2</TD>
<TD align = "left" >write "2" to address 2 (cache)</TD>
<TD></TD>
</TR>
<TR>
<TD align = "left" >t+3</TD>
<TD align = "left" >(memory barrier) unlock mutex</TD>
<TD></TD>
</TR>
<TR>
<TD align = "left" >t+4</TD>
<TD></TD>
<TD align = "left" >lock mutex (memory barrier)</TD>
</TR>
<TR>
<TD align = "left" >t+5</TD>
<TD></TD>
<TD align = "left" >read "1" from address 1</TD>
</TR>
<TR>
<TD align = "left" >t+6</TD>
<TD></TD>
<TD align = "left" >read "2" from address 2</TD>
</TR>
<TR>
<TD align = "left" >t+7</TD>
<TD></TD>
<TD align = "left" >(memory barrier) unlock mutex</TD>
</TR>
</TABLE>
<p class=book><b>FIGURE 3.10</b> <i>Memory ordering with synchronization</i></p>
<br>



<a name=t63></a><h3 class=book>
4 A few ways to use threads
</h3>
<blockquote class="epigraph">
<p class=book>"They were obliged to have him with them," the Mock Turtle said.</p>
<p class=book>"No wise fish would go anywhere without a porpoise." </p>
<p class=book>Wouldn't it, really?" said Alice, in a tone of great surprise.</p>
<p class=book>"Of course not," said the Mock Turtle. "Why, if a fish came to me,</p>
<p class=book><i><b>and told me he was going on a journey, I should say</b></i> 'Wi<i><b>th what porpoise?'"</b></i></p>
<blockquote class=book><i>— <i>Lewis Carroll, Alice's Adventures in Wonderland</i></i></blockquote>
</blockquote>

<p class=book>During the introduction to this book, I mentioned some of the ways you can structure a threaded solution to a problem. There are infinite variations, but the primary models of threaded programming are shown in Table 4.1.</p>
<TABLE>
<TR>
<TD align = "left" >Pipeline</TD>
<TD align = "left" >Each thread repeatedly performs the same operation on a sequence of data sets, passing each result to another thread for the next step. This is also known as an "assembly line."</TD>
</TR>
<TR>
<TD align = "left" >Work crew</TD>
<TD align = "left" >Each thread performs an operation on its own data. Threads in a work crew may all perform the same operation, or each a separate operation, but they always proceed independently.</TD>
</TR>
<TR>
<TD align = "left" >Client/server</TD>
<TD align = "left" >A client "contracts" with an independent server for each job. Often the "contract" is anonymous—a request is made through some interface that queues the work item.</TD>
</TR>
</TABLE>
<p class=book><b>TABLE 4.1</b> <i>Thread programming models</i></p>
<p class=book>All of these models can be combined in arbitrary ways and modified beyond all recognition to fit individual situations. A step in a pipeline could involve requesting a service from a server thread, and the server might use a work crew, and one or more workers in the crew might use a pipeline. Or a parallel search "engine" might initiate several threads, each trying a different search algorithm.</p>


<a name=t64></a><h3 class=book>
4.1 Pipeline
</h3>
<blockquote class="epigraph">
<p class=book><i>"I want a cl</i>e<i>an cup," interrupted the Hatter: "let's all move one place on.</i></p>
<p class=book><i>" He moved on as he spoke, and the Dormouse followed him: the March Hare moved into the Dormouse's place, and Alice rather unwillingly took the place of the March Hare. The Hatter was the only one who got any advantage from the change; and Alice was a good deal worse off than before, as the March Hare had just upset the milk-jug into his plate.</i></p>
<blockquote class=book><i>— <i>Lewis Carroll, Alice's Adventures in Wonderland</i></i></blockquote>
</blockquote>
<p class=book>In pipelining, a stream of "data items" is processed serially by an ordered set of threads (Figure 4.1). Each thread performs a specific operation on each item in sequence, passing the data on to the next thread in the pipeline.</p>
<p class=book>For example, the data might be a scanned image, and thread A might process an image array, thread B might search the processed data for a specific set of fea-tures, and thread C might collect the serial stream of search results from thread B into a report. Or each thread might perform a single step in some sequence of modifications on the data.</p>
<p class=book>The following program, called pipe.c, shows the pieces of a simple pipeline program. Each thread in the pipeline increments its input value by 1 and passes it to the next thread. The main program reads a series of "command lines" from stdin. A command line is either a number, which is fed into the beginning of the pipeline, or the character "=," which causes the program to read the next result from the end of the pipeline and print it to stdout.</p>
<br>
<img border=0 style='spacing 9px;' src="img_11.png">
<p class=book><b>FIGURE4.1</b> <i>Pipelining</i></p>
<p class=book><CODE>1 #include &lt;pthread.h&gt;</CODE></p>
<p class=book><CODE>2 #include "errors.h" 3</CODE></p>
<p class=book><CODE>4 /*</CODE></p>
<p class=book><CODE>5 * Internal structure describing a "stage" in the</CODE></p>
<p class=book><CODE>6 * pipeline. One for each thread, plus a "result</CODE></p>
<p class=book><CODE>7 * stage" where the final thread can stash the value.</CODE></p>
<p class=book><CODE>8 */</CODE></p>
<p class=book><CODE>9 typedef struct stage_tag {</CODE></p>
<p class=book><CODE>10 	pthread_mutex_t mutex;                  /* Protect data */</CODE></p>
<p class=book><CODE>11 	pthread_cond_t avail;                  /* Data available */</CODE></p>
<p class=book><CODE>12 	pthread_cond_t ready;                  /* Ready for data */</CODE></p>
<p class=book><CODE>13 	int data_ready;         /* Data present */</CODE></p>
<p class=book><CODE>14 	long data;                   /* Data to process */</CODE></p>
<p class=book><CODE>15 	pthread_t thread;                /* Thread for stage */</CODE></p>
<p class=book><CODE>16 	struct stage_tag       *next; /* Next stage */</CODE></p>
<p class=book><CODE>17 } stage_t; 18</CODE></p>
<p class=book><CODE>19 /*</CODE></p>
<p class=book><CODE>20 * External structure representing the entire</CODE></p>
<p class=book><CODE>21 * pipeline.</CODE></p>
<p class=book><CODE>22 */</CODE></p>
<p class=book><CODE>23 typedef struct pipe_tag {</CODE></p>
<p class=book><CODE>24 	pthread_mutex_t mutex;                 /* Mutex to protect pipe */</CODE></p>
<p class=book><CODE>25 	stage_t *head;                  /* First stage */</CODE></p>
<p class=book><CODE>26 	stage_t *tail;                  /* Final stage */</CODE></p>
<p class=book><CODE>27 	int stages;                 /* Number of stages */</CODE></p>
<p class=book><CODE>28 	int active;                /* Active data elements */</CODE></p>
<p class=book><CODE>29 } pipe_t;</CODE></p>
<p class=book><b>9-17</b> Each stage of a pipeline is represented by a variable of type stage_t. stage_t contains a mutex to synchronize access to the stage. The avail condition variable is used to signal a stage that data is ready for it to process, and each stage signals its own ready condition variable when it is ready for new data. The data member is the data passed from the previous stage, thread is the thread operating this stage, and next is a pointer to the following stage. </p>
<p class=book><b>23-29</b> The pipe_t structure describes a pipeline. It provides pointers to the first and last stage of a pipeline. The first stage, head, represents the first thread in the pipeline. The last stage, tail, is a special stage_t that has no thread—it is a place to store the final result of the pipeline.</p>
<p class=book>Part 2 shows pipe_send, a utility function used to start data along a pipeline, and also called by each stage to pass data to the next stage.</p>
<p class=book><b>17-23</b> It begins by waiting on the specified pipeline stage's ready condition variable until it can accept new data. </p>
<p class=book><b>28-30</b> Store the new data value, and then tell the stage that data is available.</p>
<p class=book>■ pipe.c part 2 pipe_send</p>
<p class=book><CODE>1 /*</CODE></p>
<p class=book><CODE>2 * Internal function to send a "message" to the</CODE></p>
<p class=book><CODE>3 * specified pipe stage. Threads use this to pass</CODE></p>
<p class=book><CODE>4 * along the modified data item.</CODE></p>
<p class=book><CODE>5 */</CODE></p>
<p class=book><CODE>6 int pipe_send (stage_t *stage, long data)</CODE></p>
<p class=book><CODE>7 {</CODE></p>
<p class=book><CODE>8 	int status; 9</CODE></p>
<p class=book><CODE>10 	status = pthread_mutex_lock (&stage-&gt;mutex);</CODE></p>
<p class=book><CODE>11 	if (status != 0)</CODE></p>
<p class=book><CODE>12 		return status;</CODE></p>
<p class=book><CODE>13 /*</CODE></p>
<p class=book><CODE>14 * If there's data in the pipe stage, wait for it</CODE></p>
<p class=book><CODE>15 * to be consumed.</CODE></p>
<p class=book><CODE>16 */</CODE></p>
<p class=book><CODE>17 	while (stage-&gt;data_ready) {</CODE></p>
<p class=book><CODE>18 		status = pthread_cond_wait (&stage-&gt;ready, &stage-&gt;mutex);</CODE></p>
<p class=book><CODE>19 		if (status != 0) {</CODE></p>
<p class=book><CODE>20 			pthread_mutex_unlock (&stage-&gt;mutex);</CODE></p>
<p class=book><CODE>21 			return status;</CODE></p>
<p class=book><CODE>22 		}</CODE></p>
<p class=book><CODE>23 	}</CODE></p>
<p class=book><CODE>24</CODE></p>
<p class=book><CODE>25 /*</CODE></p>
<p class=book><CODE>26 * Send the new data</CODE></p>
<p class=book><CODE>27 */</CODE></p>
<p class=book><CODE>28 stage-&gt;data = data;</CODE></p>
<p class=book><CODE>29 stage-&gt;data_ready = <b>1;</b></CODE></p>
<p class=book><CODE>30 status = pthread_cond_signal (&stage-&gt;avail);</CODE></p>
<p class=book><CODE>31 if (status != 0) {</CODE></p>
<p class=book><CODE>32 	pthread_mutex_unlock (&stage-&gt;mutex);</CODE></p>
<p class=book><CODE>33 	return status;</CODE></p>
<p class=book><CODE>34 }</CODE></p>
<p class=book><CODE>35 status = pthread_mutex_unlock (&stage-&gt;mutex);</CODE></p>
<p class=book><CODE>36 return status;</CODE></p>
<p class=book><CODE>37 }</CODE></p>
<p class=book>Part 3 shows pipe_stage, the start function for each thread in the pipeline. The thread's argument is a pointer to its stage_t structure. </p>
<p class=book><b>16-27</b> The thread loops forever, processing data. Because the mutex is locked outside the loop, the thread appears to have the pipeline stage's mutex locked all the</p>
<p class=book>time. However, it spends most of its time waiting for new data, on the avail condition variable. Remember that a thread automatically unlocks the mutex associated with a condition variable, while waiting on that condition variable. In reality, therefore, the thread spends most of its time with mutex unlocked. </p>
<p class=book><b>22-26</b> When given data, the thread increases its own data value by one, and passes the result to the next stage. The thread then records that the stage no longer has data by clearing the data_ready flag, and signals the ready condition variable to wake any thread that might be waiting for this pipeline stage.</p>
<p class=book>■ pipe.c part 3 pipe_stage</p>
<p class=book><CODE>1 /*</CODE></p>
<p class=book><CODE>2 * The thread start routine for pipe stage threads.</CODE></p>
<p class=book><CODE>3 * Each will wait for a data item passed from the</CODE></p>
<p class=book><CODE>4 * caller or the previous stage, modify the data</CODE></p>
<p class=book><CODE>5 * and pass it along to the next (or final) stage.</CODE></p>
<p class=book><CODE>6 */</CODE></p>
<p class=book><CODE>7 void *pipe_stage (void *arg)</CODE></p>
<p class=book><CODE>8 {</CODE></p>
<p class=book><CODE>9 	stage_t *stage = (stage_t*)arg;</CODE></p>
<p class=book><CODE>10 	stage_t *next_stage = stage-&gt;next;</CODE></p>
<p class=book><CODE>11 	int status;</CODE></p>
<p class=book><CODE>12</CODE></p>
<p class=book><CODE>13 	status = pthread_mutex_lock (&stage-&gt;mutex);</CODE></p>
<p class=book><CODE>14 	if (status != 0)</CODE></p>
<p class=book><CODE>15 		err_abort (status, "Lock pipe stage");</CODE></p>
<p class=book><CODE>16 	while (1) {</CODE></p>
<p class=book><CODE>17 		while (stage-&gt;data_ready != 1) {</CODE></p>
<p class=book><CODE>18 			status = pthread_cond_wait (&stage-&gt;avail, &stage-&gt;mutex);</CODE></p>
<p class=book><CODE>19 			if (status != 0)</CODE></p>
<p class=book><CODE>20 				err_abort (status, "Wait for previous stage");</CODE></p>
<p class=book><CODE>21 		}</CODE></p>
<p class=book><CODE>22 		pipe_send (next_stage, stage-&gt;data + 1);</CODE></p>
<p class=book><CODE>23 		stage-&gt;data_ready = 0;</CODE></p>
<p class=book><CODE>24 		status = pthread_cond_signal (&stage-&gt;ready);</CODE></p>
<p class=book><CODE>25 		if (status != 0)</CODE></p>
<p class=book><CODE>26 			err_abort (status, "Wake next stage");</CODE></p>
<p class=book><CODE>27 	}</CODE></p>
<p class=book><CODE>28 /*</CODE></p>
<p class=book><CODE>29 * Notice that the routine never unlocks the stage-&gt;mutex.</CODE></p>
<p class=book><CODE>30 * The call to pthread_cond_wait implicitly unlocks the</CODE></p>
<p class=book><CODE>31 * mutex while the thread is waiting, allowing other threads</CODE></p>
<p class=book><CODE>32 * to make progress. Because the loop never terminates, this</CODE></p>
<p class=book><CODE>33 * function has no need to unlock the mutex explicitly.</CODE></p>
<p class=book><CODE>34 */</CODE></p>
<p class=book>Part 4 shows pipe_create, the function that creates a pipeline. It can create a pipeline of any number of stages, linking them together in a list.</p>
<p class=book><b>18-34</b> For each stage, it allocates a new stage_t structure and initializes the members. Notice that one additional "stage" is allocated and initialized to hold the final result of the pipeline.</p>
<p class=book><b>36-37</b> The link member of the final stage is set to NULL to terminate the list, and the pipeline's tail is set to point at the final stage. The tail pointer allows pipe_ result to easily find the final product of the pipeline, which is stored into the final stage.</p>
<p class=book><b>52-59</b> After all the stage data is initialized, pipe_create creates a thread for each stage. The extra "final stage" does not get a thread—the termination condition of the for loop is that the current stage's next link is not NULL, which means that it will not process the final stage.</p>
<p class=book>■ pipe.c part 4 pipe_create</p>
<p class=book><CODE>1 /*</CODE></p>
<p class=book><CODE>2 * External interface to create a pipeline. All the</CODE></p>
<p class=book><CODE>3 * data is initialized and the threads created. They'll</CODE></p>
<p class=book><CODE>4 * wait for data.</CODE></p>
<p class=book><CODE>5 */</CODE></p>
<p class=book><CODE>6 int pipe_create (pipe_t *pipe, int stages)</CODE></p>
<p class=book><CODE>7 {</CODE></p>
<p class=book><CODE>8 	int pipe_index;</CODE></p>
<p class=book><CODE>9 	stage_t **link = &pipe-&gt;head, *new_stage, *stage; 10 int status;</CODE></p>
<p class=book><CODE>11</CODE></p>
<p class=book><CODE>12 	status = pthread_mutex_init(&pipe-&gt;mutex, NULL);</CODE></p>
<p class=book><CODE>13 	if (status != 0)</CODE></p>
<p class=book><CODE>14 		err_abort (status, "Init pipe mutex");</CODE></p>
<p class=book><CODE>15 	pipe-&gt;stages = stages;</CODE></p>
<p class=book><CODE>16 	pipe-&gt;active = 0;</CODE></p>
<p class=book><CODE>17</CODE></p>
<p class=book><CODE>18 	for (pipe_index = 0; pipe_index &lt;= stages; pipe_index++) {</CODE></p>
<p class=book><CODE>19 		new_stage = (stage_t*)malloc (sizeof (stage_t));</CODE></p>
<p class=book><CODE>20 		if (new_stage == NULL)</CODE></p>
<p class=book><CODE>21 			errno_abort ("Allocate stage");</CODE></p>
<p class=book><CODE>22 		status = pthread_mutex_init (&new_stage-&gt;mutex, NULL);</CODE></p>
<p class=book><CODE>23 		if (status != 0)</CODE></p>
<p class=book><CODE>24 			err_abort (status, "Init stage mutex");</CODE></p>
<p class=book><CODE>25 		status = pthread_cond_init (&new_stage-&gt;avail, NULL);</CODE></p>
<p class=book><CODE>26 		if (status != 0)</CODE></p>
<p class=book><CODE>27 			err_abort (status, "Init avail condition");</CODE></p>
<p class=book><CODE>28 		status = pthread_cond_init (&new_stage-&gt;ready, NULL);</CODE></p>
<p class=book><CODE>29 		if (status != 0)</CODE></p>
<p class=book><CODE>30 			err_abort (status, "Init ready condition");</CODE></p>
<p class=book><CODE>31 		new_stage-&gt;data_ready = 0;</CODE></p>
<p class=book><CODE>32 		*link = new_stage;</CODE></p>
<p class=book><CODE>33 		link = &new_stage-&gt;next;</CODE></p>
<p class=book><CODE>34 	}</CODE></p>
<p class=book><CODE>35</CODE></p>
<p class=book><CODE>36 	*link = (stage_t*)NULL; /* Terminate list */</CODE></p>
<p class=book><CODE>37 	pipe-&gt;tail = new_stage; /* Record the tail */ 38</CODE></p>
<p class=book><CODE>39 /*</CODE></p>
<p class=book><CODE>40 * Create the threads for the pipe stages only after all</CODE></p>
<p class=book><CODE>41 * the data is initialized (including all links). Note</CODE></p>
<p class=book><CODE>42 * that the last stage doesn't get a thread, it's just</CODE></p>
<p class=book><CODE>43 * a receptacle for the final pipeline value.</CODE></p>
<p class=book><CODE>44 *</CODE></p>
<p class=book><CODE>45 * At this point, proper cleanup on an error would take up</CODE></p>
<p class=book><CODE>46 * more space than worthwhile in a "simple example," so</CODE></p>
<p class=book><CODE>47 * instead of cancelling and detaching all the threads</CODE></p>
<p class=book><CODE>48 * already created, plus the synchronization object and</CODE></p>
<p class=book><CODE>49 * memory cleanup done for earlier errors, it will simply</CODE></p>
<p class=book><CODE>50 * abort.</CODE></p>
<p class=book><CODE>51 */</CODE></p>
<p class=book><CODE>52 	for ( stage = pipe-&gt;head;</CODE></p>
<p class=book><CODE>53 		stage-&gt;next != NULL;</CODE></p>
<p class=book><CODE>54 		stage = stage-&gt;next) {</CODE></p>
<p class=book><CODE>55 		status = pthread_create (</CODE></p>
<p class=book><CODE>56 		&stage-&gt;thread, NULL, pipe_stage, (void*)stage);</CODE></p>
<p class=book><CODE>57 		if (status != 0)</CODE></p>
<p class=book><CODE>58 			err_abort (status, "Create pipe stage");</CODE></p>
<p class=book><CODE>59 	}</CODE></p>
<p class=book><CODE>60 	return 0;</CODE></p>
<p class=book><CODE>61 }</CODE></p>
<p class=book>Part 5 shows <CODE>pipe_start</CODE> and <CODE>pipe_result</CODE>. The pipe_start function pushes an item of data into the beginning of the pipeline and then returns immediately without waiting for a result. The pipe_result function allows the caller to wait for the final result, whenever the result might be needed. </p>
<p class=book><b>19-22</b> The pipe_start function sends data to the first stage of the pipeline. The function increments a count of "active" items in the pipeline, which allows pipe_ result to detect that there are no more active items to collect, and to return immediately instead of blocking. You would not always want a pipeline to behave this way — it makes sense for this example because a single thread alternately "feeds" and "reads" the pipeline, and the application would hang forever if the user inadvertently reads one more item than had been fed.</p>
<p class=book><b>23-47</b> The pipe_result function first checks whether there is an active item in the pipeline. If not, it returns with a status of 0, after unlocking the pipeline mutex.</p>
<p class=book><b>48-55</b> If there is another item in the pipeline, pipe_result locks the tail (final) stage, and waits for it to receive data. It copies the data and then resets the stage so it can receive the next item of data. Remember that the final stage does not have a thread, and cannot reset itself.</p>
<p class=book>■ <b>pipe.c</b> <b>part 5 pipe_start,pipe_result</b></p>
<p class=book><CODE>1 /*</CODE></p>
<p class=book><CODE>2 * External interface to start a pipeline by passing</CODE></p>
<p class=book><CODE>3 * data to the first stage. The routine returns while</CODE></p>
<p class=book><CODE>4 * the pipeline processes in parallel. Call the</CODE></p>
<p class=book><CODE>5 * pipe_result return to collect the final stage values</CODE></p>
<p class=book><CODE>6 * (note that the pipe will stall when each stage fills,</CODE></p>
<p class=book><CODE>7 * until the result is collected).</CODE></p>
<p class=book><CODE>8 */</CODE></p>
<p class=book><CODE>9 int pipe_start (pipe_t *pipe, long value)</CODE></p>
<p class=book><CODE>10 {</CODE></p>
<p class=book><CODE>11 int status; 12</CODE></p>
<p class=book><CODE>13 status = pthread_mutex_lock (&pipe-&gt;mutex);</CODE></p>
<p class=book><CODE>14 if (status != 0)</CODE></p>
<p class=book><CODE>15 err_abort (status, "Lock pipe mutex");</CODE></p>
<p class=book><CODE>16 pipe-&gt;active++;</CODE></p>
<p class=book><CODE>17 status = pthread_mutex_unlock (&pipe-&gt;mutex);</CODE></p>
<p class=book><CODE>18 if (status != 0)</CODE></p>
<p class=book><CODE>19 err_abort (status, "Unlock pipe mutex");</CODE></p>
<p class=book><CODE>20 pipe_send (pipe-&gt;head, value);</CODE></p>
<p class=book><CODE>21 return 0;</CODE></p>
<p class=book><CODE>22 } 23</CODE></p>
<p class=book><CODE>24 /*</CODE></p>
<p class=book><CODE>25 * Collect the result of the pipeline. Wait for a</CODE></p>
<p class=book><CODE>26 * result if the pipeline hasn't produced one.</CODE></p>
<p class=book><CODE>27 */</CODE></p>
<p class=book><CODE>28 int pipe_result (pipe_t *pipe, long *result)</CODE></p>
<p class=book><CODE>29 {</CODE></p>
<p class=book><CODE>30 stage_t *tail = pipe-&gt;tail;</CODE></p>
<p class=book><CODE>31 long value;</CODE></p>
<p class=book><CODE>32 int empty = 0;</CODE></p>
<p class=book><CODE>33 int status;</CODE> </p>
<p class=book><CODE>34</CODE></p>
<p class=book><CODE>35 status = pthread_mutex_lock (&pipe-&gt;mutex);</CODE></p>
<p class=book><CODE>36 if (status != 0)</CODE></p>
<p class=book><CODE>37 err_abort (status, "Lock pipe mutex");</CODE></p>
<p class=book><CODE>38 if (pipe-&gt;active &lt;= 0)</CODE></p>
<p class=book><CODE>39 empty = 1;</CODE></p>
<p class=book><CODE>40 else</CODE></p>
<p class=book><CODE>41 pipe-&gt;active--;</CODE></p>
<p class=book><CODE>42</CODE></p>
<p class=book><CODE>43 status = pthread_mutex_unlock (&pipe-&gt;mutex);</CODE></p>
<p class=book><CODE>44 if (status != 0)</CODE></p>
<p class=book><CODE>45 err_abort (status, "Unlock pipe mutex");</CODE></p>
<p class=book><CODE>46 if (empty)</CODE></p>
<p class=book><CODE>47 return 0;</CODE> </p>
<p class=book><CODE>48</CODE></p>
<p class=book><CODE>49 pthread_mutex_lock (&tail-&gt;mutex);</CODE></p>
<p class=book><CODE>50 while (!tail-&gt;data_ready)</CODE></p>
<p class=book><CODE>51 pthread_cond_wait (&tail-&gt;avail, &tail-&gt;mutex);</CODE></p>
<p class=book><CODE>52 *result = tail-&gt;data;</CODE></p>
<p class=book><CODE>53 tail-&gt;data_ready = 0;</CODE></p>
<p class=book><CODE>54 pthread_cond_signal (&tail-&gt;ready);</CODE></p>
<p class=book><CODE>55 pthread_mutex_unlock (&tail-&gt;mutex);</CODE></p>
<p class=book><CODE>56 return 1;</CODE></p>
<p class=book><CODE>57 }</CODE></p>
<p class=book>Part 6 shows the main program that drives the pipeline. It creates a pipeline, and then loops reading lines from stdin. If the line is a single "=" character, it pulls a result from the pipeline and prints it. Otherwise, it converts the line to an integer value, which it feeds into the pipeline.</p>
<p class=book>■ <b>pipe.c</b> <b>part 6 main</b></p>
<p class=book><CODE>1 /*</CODE></p>
<p class=book><CODE>2 * The main program to "drive" the pipeline...</CODE></p>
<p class=book><CODE>3 */</CODE></p>
<p class=book><CODE>4 int main (int argc, char *argv[])</CODE></p>
<p class=book><CODE>5 {</CODE></p>
<p class=book><CODE>6 pipe_t my_pipe;</CODE></p>
<p class=book><CODE>7 long value, result;</CODE></p>
<p class=book><CODE>8 int status;</CODE></p>
<p class=book><CODE>9 char line[128];</CODE> </p>
<p class=book><CODE>10</CODE></p>
<p class=book><CODE>11 pipe_create (&my_pipe, 10);</CODE></p>
<p class=book><CODE>12 printf ("Enter integer values, or \"=\" for next result\n");</CODE> </p>
<p class=book><CODE>13</CODE></p>
<p class=book><CODE>14 while (1) {</CODE></p>
<p class=book><CODE>15 	printf ("Data&gt; ");</CODE></p>
<p class=book><CODE>16 	if (fgets (line, sizeof (line), stdin) == NULL) exit (0);</CODE></p>
<p class=book><CODE>17 	if (strlen (line) &lt;= 1) continue;</CODE></p>
<p class=book><CODE>18 	if (strlen (line) &lt;= 2 && line[0] == '=') {</CODE></p>
<p class=book><CODE>19 		if (pipe_result (&my_pipe, &result))</CODE></p>
<p class=book><CODE>20 			printf ("Result is %ld\n", result);</CODE></p>
<p class=book><CODE>21 		else</CODE></p>
<p class=book><CODE>22 			printf ("Pipe is empty\n");</CODE></p>
<p class=book><CODE>23 	} else {</CODE></p>
<p class=book><CODE>24 	if (sscanf (line, "%ld", &value) &lt; 1)</CODE></p>
<p class=book><CODE>25 		fprintf (stderr, "Enter an integer value\n");</CODE></p>
<p class=book><CODE>26 	else</CODE></p>
<p class=book><CODE>27 		pipe_start (&my_pipe, value);</CODE></p>
<p class=book><CODE>28 	}</CODE></p>
<p class=book><CODE>29 }</CODE></p>
<p class=book><CODE>30 }</CODE></p>


<a name=t65></a><h3 class=book>
4.2 Work crew
</h3>
<blockquote class="epigraph">
<p class=book>The twelve jurors were all writing very busily on slates. "What are they doing?"Alice whispered to the Gryphon.</p>
<p class=book>"They ca'n't have anything to put down yet, before the trial's begun." "They're putting down their names," the Gryphon whispered in reply, "for fear they should forget them before the end of the trial."</p>
<blockquote class=book><i>— <i>Lewis Carroll, Alice's Adventures in Wonderland</i></i></blockquote>
</blockquote>
<p class=book>In a work crew, data is processed independently by a set of threads (Figure 4.2). A "parallel decomposition" of a loop generally falls into this category. A set of threads may be created, for example, each directed to process some set of rows or columns of an array. A single set of data is split between the threads, and the result is a single (filtered) set of data. Because all the threads in the work crew, in this model, are performing the same operation on different data, it is often known as SIMD parallel processing, for "single instruction, multiple data." The original use of SIMD was in an entirely different form of parallelism, and doesn't literally apply to threads — but the concept is similar.</p>
<img border=0 style='spacing 9px;' src="img_12.png">
<br>
<p class=book><b>FIGURE 4.2</b> <i>Work crew</i></p>
<p class=book>The threads in a work crew don't have to use a SIMD model, though. They may perform entirely different operations on different data. The members of our work crew, for example, each remove work requests from a shared queue, and do whatever is required by that request. Each queued request packet could describe a variety of operations—but the common queue and "mission statement" (to process that queue) make them a "crew" rather than independent worker threads. This model can be compared to the original definition of MIMD parallel processing, "multiple instruction, multiple data."</p>
<p class=book>Section 7.2, by the way, shows the development of a more robust and general (and more complicated) "work queue manager" package. A "work crew" and a "work queue" are related in much the same way as "invariants" and "critical sections" — it depends on how you look at what's happening. A work <i>crew</i> is the set of threads that independently processes data, whereas a work <i>queue</i> is a mechanism by which your code may request that data be processed by anonymous and independent "agents." So in this section, we develop a "work crew," whereas in Section 7.2 we develop a more sophisticated "work queue." The focus differs, but the principle is the same.</p>
<p class=book>The following program, called crew.c, shows a simple work crew. Run the program with two arguments, a string, and a file path. The program will queue the file path to the work crew. A crew member will determine whether the file path is a file or a directory—if a file, it will search the file for the string; if a directory, it will use <CODE>readdir_r</CODE> to find all directories and regular files within the directory, and queue each entry as new work. Each file containing the search string will be reported on <CODE>stdout.</CODE></p>
<p class=book>Part 1 shows the header files and definitions used by the program. 7 The symbol CREW_SIZE determines how many threads are created for each work crew.</p>
<p class=book><b>13-17</b> Each item of work is described by a work_t structure. This structure has a pointer to the next work item (set to NULL to indicate the end of the List), a pointer to the file path described by the work item, and a pointer to the string for which the program is searching. As currently constructed, all work items point to the same search string.</p>
<p class=book><b>23-27</b> Each member of a work crew has a worker_t structure. This structure contains the index of the crew member in the crew vector, the thread identifier of the crew member (thread), and a pointer to the crew_t structure (crew).</p>
<p class=book><b>33-41</b> The crew_t structure describes the work crew state. It records the number of members in the work crew (crew_size) and an array of worker_t structures (crew). It also has a counter of how many work items remain to be processed (work_count) and a list of outstanding work items (first points to the earliest item, and last to the latest). Finally, it contains the various Pthreads synchronization objects: a mutex to control access, a condition variable (done) to wait for the work crew to finish a task, and a condition variable on which crew members wait to receive new work (go).</p>
<p class=book><b>43-44</b> The allowed size of a file name and path name may vary depending on the file system to which the path leads. When a crew is started, the program calculates the allowable file name and path length for the specified file path by calling path-conf, and stores the values in path_max and name_max, respectively, for later use.</p>
<p class=book><CODE>1	#include &lt;sys/types.h&gt;	</CODE></p>
<p class=book><CODE>2	#include &lt;pthread.h&gt;	</CODE></p>
<p class=book><CODE>3	#include &lt;sys/stat.h&gt;	</CODE></p>
<p class=book><CODE>4	#include &lt;dirent.h&gt;	</CODE></p>
<p class=book><CODE>5	#include "errors.h"	</CODE></p>
<p class=book><CODE>6</CODE></p>
<p class=book><CODE>7	#define CREW_SIZE	4</CODE></p>
<p class=book><CODE>8</CODE> </p>
<p class=book><CODE>9	/*</CODE></p>
<p class=book><CODE>	/*	</CODE></p>
<p class=book><CODE>10	* Queued items of work	for the crew. One is queued by</CODE></p>
<p class=book><CODE>11	* crew_start, and each	worker may queue additional items.</CODE></p>
<p class=book><CODE>12	*/	</CODE></p>
<p class=book><CODE>13	typedef struct work_tag	{</CODE></p>
<p class=book><CODE>14	struct work_tag	*next; /* Next work item */</CODE></p>
<p class=book><CODE>15	char	*path; /* Directory or file */</CODE></p>
<p class=book><CODE>16	char	*string; /* Search string */</CODE></p>
<p class=book><CODE>17</CODE> </p>
<p class=book><CODE>18</CODE> </p>
<p class=book><CODE>19	} work_t, *work_p;	</CODE></p>
<p class=book><CODE>	/*	</CODE></p>
<p class=book><CODE>20	* One of these is initialized for each worker thread in the</CODE></p>
<p class=book><CODE>21	* crew. It contains the "identity" of each worker.</CODE></p>
<p class=book><CODE>22	*/	</CODE></p>
<p class=book><CODE>23	typedef struct worker_tag {</CODE></p>
<p class=book><CODE>24	int	index; /* Thread's index */</CODE></p>
<p class=book><CODE>25	pthread_t	thread; /* Thread for stage */</CODE></p>
<p class=book><CODE>26	struct crew_tag	*crew; /* Pointer to crew */</CODE></p>
<p class=book><CODE>27	} worker_t, *worker_p;	</CODE></p>
<p class=book><CODE>28</CODE></p>
<p class=book><CODE>29	/*	</CODE></p>
<p class=book><CODE>30	* The external "handle'	' for a work crew. Contains the</CODE></p>
<p class=book><CODE>31	* crew synchronization	state and staging area.</CODE></p>
<p class=book><CODE>32	*/	</CODE></p>
<p class=book><CODE>33	typedef struct crew_tag	{</CODE></p>
<p class=book><CODE>34	int	crew_size; /* Size of array */</CODE></p>
<p class=book><CODE>35	worker_t	crew[CREW_SIZE];/* Crew members */</CODE></p>
<p class=book><CODE>36	long	work_count; /* Count of work items */</CODE></p>
<p class=book><CODE>37	work_t	*first, *last; /* First & last work item */</CODE></p>
<p class=book><CODE>38	pthread_mutex_t	mutex; /* Mutex for crew data */</CODE></p>
<p class=book><CODE>39	pthread_cond_t	done; /* Wait for crew done */</CODE></p>
<p class=book><CODE>40	pthread_cond_t	go; /* Wait for work */</CODE></p>
<p class=book><CODE>41</CODE></p>
<p class=book><CODE>42	} crew_t, *crew_p;	</CODE></p>
<p class=book> <CODE>43	size_t path_max;	/* Filepath length */</CODE></p>
<p class=book><CODE>44	size t name max;	/* Name length */</CODE></p>
<p class=book>Part 2 shows worker_routine, the start function for crew threads. The outer loop repeats processing until the thread is told to terminate. </p>
<p class=book><b>20-23</b> POSIX is a little ambiguous about the actual size of the struct dirent type. The actual requirement for readdir_r is that you pass the address of a buffer large enough to contain a struct dirent with a name member of at least NAME_ MAX bytes. To ensure that we have enough space, allocate a buffer the size of the system's struct dirent plus the maximum size necessary for a file name on the file system we're using. This may be bigger than necessary, but it surely won't be too small.</p>
<p class=book><b>33-37</b> This condition variable loop blocks each new crew member until work is made available.</p>
<p class=book><b>61-65</b> This wait is a little different. While the work list is empty, wait for more work. The crew members never terminate—once they're all done with the current assignment, they're ready for a new assignment. (This example doesn't take advantage of that capability — the process will terminate once the single search command has completed.)</p>
<p class=book><b>73-76</b> Remove the first work item from the queue. If the queue becomes empty, also clear the pointer to the last entry, crew-&gt;last.</p>
<p class=book><b>81-83</b> Unlock the work crew mutex, so that the bulk of the crew's work can proceed concurrently.</p>
<p class=book><b>89</b> Determine what sort of file we've got in the work item's path string. We use lstat, which will return information for a symbolic link, rather than stat, which would return information for the file to which the link pointed. By not following symbolic links, we reduce the amount of work in this example, and, especially, avoid following links into other file systems where our name_max and path_max sizes may not be sufficient. </p>
<p class=book><b>91-95</b> If the file is a link, report the name, but do nothing else with it. Note that each message includes the thread's work crew index (mine-&gt;index), so that you can easily see "concurrency at work" within the example. </p>
<p class=book><b>96-165</b> If the file is a directory, open it with opendir. Find all entries in the directory by repeatedly calling readdir_r. Each directory entry is entered as a new work item.</p>
<p class=book><b>166-206</b> If the file is a regular file, open it and read all text, looking for the search string. If we find it, write a message and exit the search loop.</p>
<p class=book><b>207-218</b> If the file is of any other type, write a message attempting to identify the type.</p>
<p class=book><b>232-252</b> Relock the work crew mutex, and report that another work item is done. If the count reaches 0, then the crew has completed the assignment, and we broadcast to awaken any threads waiting to issue a new assignment. Note that the work count is decreased only after the work item is fully processed — the count will never reach 0 if any crew member is still busy (and might queue additional directory entries).</p>
<p class=book>■ crew.c part 2 worker_routine</p>
<p class=book><CODE>1 /*</CODE></p>
<p class=book><CODE>2 * The thread start routine for crew threads. Waits until "go"</CODE></p>
<p class=book><CODE>3 * command, processes work items until requested to shut down.</CODE></p>
<p class=book><CODE>4 */</CODE></p>
<p class=book><CODE>5 void *worker_routine (void *arg)</CODE></p>
<p class=book><CODE>6 {</CODE></p>
<p class=book><CODE>7 worker_p mine = (worker_t*)arg;</CODE></p>
<p class=book><CODE>8 crew_p crew = mine-&gt;crew;</CODE></p>
<p class=book><CODE>9 work_p work, new_work;</CODE></p>
<p class=book><CODE>10 struct stat filestat;</CODE></p>
<p class=book><CODE>11 struct dirent *entry;</CODE></p>
<p class=book><CODE>12 int status; 13</CODE></p>
<p class=book><CODE>14 /*</CODE></p>
<p class=book><CODE>15 * "struct dirent" is funny, because POSIX doesn't require</CODE></p>
<p class=book><CODE>16 * the definition to be more than a header for a variable</CODE></p>
<p class=book><CODE>17 * buffer. Thus, allocate a "big chunk" of memory, and use</CODE></p>
<p class=book><CODE>18 * it as a buffer.</CODE></p>
<p class=book><CODE>19 */</CODE></p>
<p class=book><CODE>20 entry = (struct dirent*)malloc (</CODE></p>
<p class=book><CODE>21 sizeof (struct dirent) + name_max);</CODE></p>
<p class=book><CODE>22 if (entry == NULL)</CODE></p>
<p class=book><CODE>23 errno_abort ("Allocating dirent");</CODE> </p>
<p class=book><CODE>24</CODE></p>
<p class=book><CODE>25 status = pthread_mutex_lock (&crew-&gt;mutex);</CODE></p>
<p class=book><CODE>26 if (status != 0)</CODE></p>
<p class=book><CODE>27 err_abort (status, "Lock crew mutex");</CODE> </p>
<p class=book><CODE>28</CODE></p>
<p class=book><CODE>29 /*</CODE></p>
<p class=book><CODE>30 * There won't be any work when the crew is created, so wait</CODE></p>
<p class=book><CODE>31 * until something's put on the queue.</CODE></p>
<p class=book><CODE>32 */</CODE></p>
<p class=book><CODE>33 while (crew-&gt;work_count == 0) {</CODE></p>
<p class=book><CODE>34 	status = pthread_cond_wait (&crew-&gt;go, &crew-&gt;mutex);</CODE></p>
<p class=book><CODE>35 	if (status != 0)</CODE></p>
<p class=book><CODE>36 		err_abort (status, "Wait for go");</CODE></p>
<p class=book><CODE>37 }</CODE> </p>
<p class=book><CODE>38</CODE></p>
<p class=book><CODE>39 status = pthread_mutex_unlock (&crew-&gt;mutex);</CODE></p>
<p class=book><CODE>40 if (status != 0)</CODE></p>
<p class=book><CODE>41 	err_abort (status, "Unlock mutex");</CODE> </p>
<p class=book><CODE>42</CODE></p>
<p class=book><CODE>43 DPRINTF (("Crew %d starting\n", mine-&gt;index));</CODE> </p>
<p class=book><CODE>44</CODE></p>
<p class=book><CODE>45 /*</CODE></p>
<p class=book><CODE>46 * Now, as long as there's work, keep doing it.</CODE></p>
<p class=book><CODE>47 */</CODE></p>
<p class=book><CODE>48 while (1) {</CODE></p>
<p class=book><CODE>49 /*</CODE></p>
<p class=book><CODE>50 * Wait while there is nothing to do, and</CODE></p>
<p class=book><CODE>51 * the hope of something coming along later. If</CODE></p>
<p class=book><CODE>52 * crew-&gt;first is NULL, there's no work. But if</CODE></p>
<p class=book><CODE>53 * crew-&gt;work_count goes to zero, we're done.</CODE></p>
<p class=book><CODE>54 */</CODE></p>
<p class=book><CODE>55 	status = pthread_mutex_lock (&crew-&gt;mutex);</CODE></p>
<p class=book><CODE>56 	if (status != 0)</CODE></p>
<p class=book><CODE>57 		err_abort (status, "Lock crew mutex");</CODE> </p>
<p class=book><CODE>58</CODE></p>
<p class=book><CODE>59 	DPRINTF (("Crew %d top: first is %#lx, count is %d\n",</CODE></p>
<p class=book><CODE>60 	mine-&gt;index, crew-&gt;first, crew-&gt;work_count));</CODE></p>
<p class=book><CODE>61 	while (crew-&gt;first == NULL) {</CODE></p>
<p class=book><CODE>62 		status = pthread_cond_wait (&crew-&gt;go, &crew-&gt;mutex);</CODE></p>
<p class=book><CODE>63 		if (status != 0)</CODE></p>
<p class=book><CODE>64 			err_abort (status, "Wait for work");</CODE></p>
<p class=book><CODE>65 	}</CODE> </p>
<p class=book><CODE>66</CODE></p>
<p class=book><CODE>67 	DPRINTF (("Crew %d woke: %#lx, %d\n",</CODE></p>
<p class=book><CODE>68 		mine-&gt;index, crew-&gt;first, crew-&gt;work_count));</CODE> </p>
<p class=book><CODE>69</CODE></p>
<p class=book><CODE>70 /*</CODE></p>
<p class=book><CODE>71 * Remove and process a work item.</CODE></p>
<p class=book><CODE>72 */</CODE></p>
<p class=book><CODE>73 	work = crew-&gt;first;</CODE></p>
<p class=book><CODE>74 	crew-&gt;first = work-&gt;next;</CODE></p>
<p class=book><CODE>75 	if (crew-&gt;first == NULL)</CODE></p>
<p class=book><CODE>76 		crew-&gt;last = NULL;</CODE></p>
<p class=book><CODE>77</CODE></p>
<p class=book><CODE>78 	DPRINTF (("Crew %d took %#lx, leaves first %#lx, last %#lx\n",</CODE></p>
<p class=book><CODE>79 		mine-&gt;index, work, crew-&gt;first, crew-&gt;last));</CODE> </p>
<p class=book><CODE>80</CODE></p>
<p class=book><CODE>81 	status = pthread_mutex_unlock (&crew-&gt;mutex);</CODE></p>
<p class=book><CODE>82 	if (status != 0)</CODE></p>
<p class=book><CODE>83 		err_abort (status, "Unlock mutex");</CODE></p>
<p class=book><CODE>84</CODE></p>
<p class=book><CODE>85 /*</CODE></p>
<p class=book><CODE>86 * We have a work item. Process it, which may involve</CODE></p>
<p class=book><CODE>87 * queuing new work items.</CODE></p>
<p class=book><CODE>88 */</CODE></p>
<p class=book><CODE>89 	status = lstat (work-&gt;path, &filestat);</CODE> </p>
<p class=book><CODE>90</CODE></p>
<p class=book><CODE>91 	if (S_ISLNK (filestat.st_mode))</CODE></p>
<p class=book><CODE>92 		printf (</CODE></p>
<p class=book><CODE>93 			"Thread %d: %s is a link, skipping.\n",</CODE></p>
<p class=book><CODE>94 			mine-&gt;index,</CODE></p>
<p class=book><CODE>95 			work-&gt;path);</CODE></p>
<p class=book><CODE>96 	else if (S_ISDIR (filestat.st_mode)) {</CODE></p>
<p class=book><CODE>97 		DIR *directory;</CODE></p>
<p class=book><CODE>98 		struct dirent *result;</CODE> </p>
<p class=book><CODE>99</CODE></p>
<p class=book><CODE>100 /*</CODE></p>
<p class=book><CODE>101 * If the file is a directory, search it and place</CODE></p>
<p class=book><CODE>102 * all files onto the queue as new work items.</CODE></p>
<p class=book><CODE>103 */</CODE></p>
<p class=book><CODE>104 		directory = opendir (work-&gt;path);</CODE></p>
<p class=book><CODE>105 		if (directory == NULL) {</CODE></p>
<p class=book><CODE>106 			fprintf (</CODE></p>
<p class=book><CODE>107 				stderr, "Unable to open directory %s: %d (%s)\n",</CODE></p>
<p class=book><CODE>108 				work-&gt;path,</CODE></p>
<p class=book><CODE>109 				errno, strerror (errno));</CODE></p>
<p class=book><CODE>110 			continue;</CODE></p>
<p class=book><CODE>111 		}</CODE></p>
<p class=book><CODE>112</CODE></p>
<p class=book><CODE>113 		while (1) {</CODE></p>
<p class=book><CODE>114 			status = readdir_r (directory, entry, &result);</CODE></p>
<p class=book><CODE>115 			if (status != 0) {</CODE></p>
<p class=book><CODE>116 				fprintf (</CODE></p>
<p class=book><CODE>117 					stderr,</CODE></p>
<p class=book><CODE>118 					"Unable to read directory %s: %d (%s)\n",</CODE></p>
<p class=book><CODE>119 					work-&gt;path,</CODE></p>
<p class=book><CODE>120 					status, strerror (status));</CODE></p>
<p class=book><CODE>121 				break;</CODE></p>
<p class=book><CODE>122 			}</CODE></p>
<p class=book><CODE>123 			if (result == NULL)</CODE></p>
<p class=book><CODE>124 				break; /* End of directory */</CODE> </p>
<p class=book><CODE>125</CODE></p>
<p class=book><CODE>126 /*</CODE></p>
<p class=book><CODE>127 * Ignore "." and entries.</CODE></p>
<p class=book><CODE>128 */</CODE></p>
<p class=book><CODE>129 			if (strcmp (entry-&gt;d_name, ".") == 0)</CODE></p>
<p class=book><CODE>130 				continue;</CODE></p>
<p class=book><CODE>131 			if (strcmp (entry-&gt;d_name, "..") == 0)</CODE></p>
<p class=book><CODE>132 				continue;</CODE></p>
<p class=book><CODE>133 			new_work = (work_p)malloc (sizeof (work_t));</CODE></p>
<p class=book><CODE>134 			if (new_work == NULL)</CODE></p>
<p class=book><CODE>135 				errno_abort ("Unable to allocate space");</CODE></p>
<p class=book><CODE>136 			new_work-&gt;path = (char*)malloc (path_max);</CODE></p>
<p class=book><CODE>137 			if (new_work-&gt;path == NULL)</CODE></p>
<p class=book><CODE>138 				errno_abort ("Unable to allocate path");</CODE></p>
<p class=book><CODE>139 			strcpy (new_work-&gt;path, work-&gt;path);</CODE></p>
<p class=book><CODE>140 			strcat (new_work-&gt;path, "/");</CODE></p>
<p class=book><CODE>141 			strcat (new_work-&gt;path, entry-&gt;d_name);</CODE></p>
<p class=book><CODE>142 			new_work-&gt;string = work-&gt;string;</CODE></p>
<p class=book><CODE>143 			new_work-&gt;next = NULL;</CODE></p>
<p class=book><CODE>144 			status = pthread_mutex_lock (&crew-&gt;mutex);</CODE></p>
<p class=book><CODE>145 			if (status != 0)</CODE></p>
<p class=book><CODE>146 				err_abort (status, "Lock mutex");</CODE></p>
<p class=book><CODE>147 			if (crew-&gt;first == NULL) {</CODE></p>
<p class=book><CODE>148 				crew-&gt;first = new_work;</CODE></p>
<p class=book><CODE>149 				crew-&gt;last = new_work;</CODE></p>
<p class=book><CODE>150 			} else {</CODE></p>
<p class=book><CODE>151 				crew-&gt;last-&gt;next = new_work;</CODE></p>
<p class=book><CODE>152 				crew-&gt;last = new_work;</CODE></p>
<p class=book><CODE>153 			}</CODE></p>
<p class=book><CODE>154 			crew-&gt;work_count++;</CODE></p>
<p class=book><CODE>155 			DPRINTF ((</CODE></p>
<p class=book><CODE>156 				"Crew %d: add %#lx, first %#lx, last %#lx, %d\n",</CODE></p>
<p class=book><CODE>157 				mine-&gt;index, new_work, crew-&gt;first,</CODE></p>
<p class=book><CODE>158 				crew-&gt;last, crew-&gt;work_count));</CODE></p>
<p class=book><CODE>159 			status = pthread_cond_signal (&crew-&gt;go);</CODE></p>
<p class=book><CODE>160 			status = pthread_mutex_unlock (&crew-&gt;mutex);</CODE></p>
<p class=book><CODE>161 			if (status != 0)</CODE></p>
<p class=book><CODE>162 				err_abort (status, "Unlock mutex");</CODE></p>
<p class=book><CODE>163 		}</CODE> </p>
<p class=book><CODE>164</CODE></p>
<p class=book><CODE>165 		closedir (directory);</CODE></p>
<p class=book><CODE>166 	} else if (S_ISREG (filestat.st_mode)) {</CODE></p>
<p class=book><CODE>167 		FILE *search;</CODE></p>
<p class=book><CODE>168 		char buffer[256], *bufptr, *search_ptr;</CODE> </p>
<p class=book><CODE>169</CODE></p>
<p class=book><CODE>170 /*</CODE></p>
<p class=book><CODE>171 * If this is a file, not a directory, then search</CODE></p>
<p class=book><CODE>172 * it for the string.</CODE></p>
<p class=book><CODE>173 */</CODE></p>
<p class=book><CODE>174 		search = fopen (work-&gt;path, "r");</CODE></p>
<p class=book><CODE>175 		if (search == NULL)</CODE></p>
<p class=book><CODE>176 			fprintf (</CODE></p>
<p class=book><CODE>177 				stderr, "Unable to open %s: %d (%s)\n",</CODE></p>
<p class=book><CODE>178 				work-&gt;path,</CODE></p>
<p class=book><CODE>179 				errno, strerror (errno));</CODE></p>
<p class=book><CODE>180 		else {</CODE> </p>
<p class=book><CODE>181</CODE></p>
<p class=book><CODE>182 			while (1) {</CODE></p>
<p class=book><CODE>183 				bufptr = fgets (</CODE></p>
<p class=book><CODE>184 				buffer, sizeof (buffer), search);</CODE></p>
<p class=book><CODE>185 				if (bufptr == NULL) {</CODE></p>
<p class=book><CODE>186 					if (feof (search))</CODE></p>
<p class=book><CODE>187 						break;</CODE></p>
<p class=book><CODE>188 				if (ferror (search)) {</CODE></p>
<p class=book><CODE>189 					fprintf (</CODE></p>
<p class=book><CODE>190 						stderr,</CODE></p>
<p class=book><CODE>191 						"Unable to read %s: %d (%s)\n",</CODE></p>
<p class=book><CODE>192 						work-&gt;path,</CODE></p>
<p class=book><CODE>193 						errno, strerror (errno));</CODE></p>
<p class=book><CODE>194 					break;</CODE></p>
<p class=book><CODE>195 				}</CODE></p>
<p class=book><CODE>196 			}</CODE></p>
<p class=book><CODE>197 			search_ptr = strstr (buffer, work-&gt;string);</CODE></p>
<p class=book><CODE>198 			if (search_ptr != NULL) {</CODE></p>
<p class=book><CODE>199 				printf (</CODE></p>
<p class=book><CODE>200 					"Thread %d found \"%s\" in %s\n",</CODE></p>
<p class=book><CODE>201 					mine-&gt;index, work-&gt;string, work-&gt;path);</CODE></p>
<p class=book><CODE>202 				break;</CODE></p>
<p class=book><CODE>203 			}</CODE></p>
<p class=book><CODE>204 		}</CODE></p>
<p class=book><CODE>205 		fclose (search);</CODE></p>
<p class=book><CODE>206 	}</CODE></p>
<p class=book><CODE>207 } else</CODE></p>
<p class=book><CODE>208 	fprintf (</CODE></p>
<p class=book><CODE>209 		stderr,</CODE></p>
<p class=book><CODE>210 		"Thread %d: %s is type %o (%s))\n",</CODE></p>
<p class=book><CODE>211 		mine-&gt;index,</CODE></p>
<p class=book><CODE>212 		work-&gt;path,</CODE></p>
<p class=book><CODE>213 		filestat.st_mode & S_IFMT,</CODE></p>
<p class=book><CODE>214 		(S_ISFIFO (filestat.st_mode) ? "FIFO"</CODE></p>
<p class=book><CODE>215 		:(S_ISCHR (filestat.st_mode) ? "CHR"</CODE></p>
<p class=book><CODE>216 		:(S_ISBLK (filestat.st_mode) ? "BLK"</CODE></p>
<p class=book><CODE>217 		:(S_ISSOCK (filestat.st_mode) ? "SOCK"</CODE></p>
<p class=book><CODE>218 		:"unknown")))));</CODE> </p>
<p class=book><CODE>219</CODE></p>
<p class=book><CODE>220 	free (work-&gt;path); /* Free path buffer */</CODE></p>
<p class=book><CODE>221 	free (work); /* We're done with this */</CODE> </p>
<p class=book><CODE>222</CODE></p>
<p class=book><CODE>223 /*</CODE></p>
<p class=book><CODE>224 * Decrement count of outstanding work items, and wake</CODE></p>
<p class=book><CODE>225 * waiters (trying to collect results or start a new</CODE></p>
<p class=book><CODE>226 * calculation) if the crew is now idle.</CODE></p>
<p class=book><CODE>227 *</CODE></p>
<p class=book><CODE>228 * It's important that the count be decremented AFTER</CODE></p>
<p class=book><CODE>229 * processing the current work item. That ensures the</CODE></p>
<p class=book><CODE>230 * count won't go to 0 until we're really done.</CODE></p>
<p class=book><CODE>231 */</CODE></p>
<p class=book><CODE>232 	status = pthread_mutex_lock (&crew-&gt;mutex);</CODE></p>
<p class=book><CODE>233 	if (status != 0)</CODE></p>
<p class=book><CODE>234 		err_abort (status, "Lock crew mutex");</CODE> </p>
<p class=book><CODE>235</CODE></p>
<p class=book><CODE>236 	crew-&gt;work_count--;</CODE></p>
<p class=book><CODE>237 	DPRINTF (("Crew %d decremented work to %d\n", mine-&gt;index,</CODE></p>
<p class=book><CODE>238 		crew-&gt;work_count));</CODE></p>
<p class=book><CODE>239 	if (crew-&gt;work_count &lt;= 0) {</CODE></p>
<p class=book><CODE>240 		DPRINTF (("Crew thread %d done\n", mine-&gt;index));</CODE></p>
<p class=book><CODE>241 		status = pthread_cond_broadcast (&crew-&gt;done);</CODE></p>
<p class=book><CODE>242 		if (status != 0)</CODE></p>
<p class=book><CODE>243 			err_abort (status, "Wake waiters");</CODE></p>
<p class=book><CODE>244 		status = pthread_mutex_unlock (&crew-&gt;mutex);</CODE></p>
<p class=book><CODE>245 		if (status != 0)</CODE></p>
<p class=book><CODE>246 			err_abort (status, "Unlock mutex");</CODE></p>
<p class=book><CODE>247 		break;</CODE></p>
<p class=book><CODE>248 	}</CODE> </p>
<p class=book><CODE>249</CODE></p>
<p class=book><CODE>250 	status = pthread_mutex_unlock (&crew-&gt;mutex);</CODE></p>
<p class=book><CODE>251 	if (status != 0)</CODE></p>
<p class=book><CODE>252 		err_abort (status, "Unlock mutex");</CODE> </p>
<p class=book><CODE>253</CODE></p>
<p class=book><CODE>254 }</CODE></p>
<p class=book><CODE>255</CODE></p>
<p class=book><CODE>256 free (entry);</CODE></p>
<p class=book><CODE>257 return NULL;</CODE></p>
<p class=book><CODE>258 }</CODE></p>
<p class=book>Part 3 shows crew_create, the function used to create a new work crew. This simple example does not provide a way to destroy a work crew, because that is not necessary — the work crew would be destroyed only when the main program was prepared to exit, and process exit will destroy all threads and process data.</p>
<p class=book><b>12-15</b> The <CODE>crew_create</CODE> function begins by checking the <CODE>crew_size</CODE> argument.The size of the crew is not allowed to exceed the size of the crew array in crew_t. If the requested size is acceptable, copy it into the structure.</p>
<p class=book><b>16-31</b> Start with no work and an empty work queue. Initialize the crew's synchronization objects.</p>
<p class=book><b>36-43</b> Then, for each crew member, initialize the member's <CODE>worker_t</CODE> data. The index of the member within the crew array is recorded, and a pointer back to the <CODE>crew_t</CODE>. Then the crew member thread is created, with a pointer to the member's <CODE>worker_t</CODE> as its argument.</p>
<p class=book>■ <b>crew.c</b> <b>part</b> 3 <b>crew_create</b></p>
<p class=book><CODE>1 /*</CODE></p>
<p class=book><CODE>2 * Create a work crew.</CODE></p>
<p class=book><CODE>3 */</CODE></p>
<p class=book><CODE>4 int crew_create (crew_t *crew, int crew_size)</CODE></p>
<p class=book><CODE>5 {</CODE></p>
<p class=book><CODE>6 int crew_index;</CODE></p>
<p class=book><CODE>7 int status;</CODE> </p>
<p class=book><CODE>8</CODE></p>
<p class=book><CODE>9 /*</CODE></p>
<p class=book><CODE>10 * We won't create more than CREW_SIZE members.</CODE></p>
<p class=book><CODE>11 */</CODE></p>
<p class=book><CODE>12 if (crew_size &gt; CREW_SIZE)</CODE></p>
<p class=book><CODE>13 return EINVAL;</CODE> </p>
<p class=book><CODE>14</CODE></p>
<p class=book><CODE>15 crew-&gt;crew_size = crew_size;</CODE></p>
<p class=book><CODE>16 crew-&gt;work_count = 0;</CODE></p>
<p class=book><CODE>17 crew-&gt;first = NULL;</CODE></p>
<p class=book><CODE>18 crew-&gt;last = NULL;</CODE> </p>
<p class=book><CODE>19</CODE></p>
<p class=book><CODE>20 /*</CODE></p>
<p class=book><CODE>21 * Initialize synchronization objects.</CODE></p>
<p class=book><CODE>22 */</CODE></p>
<p class=book><CODE>23 status = pthread_mutex_init (&crew-&gt;mutex, NULL);</CODE></p>
<p class=book><CODE>24 if (status != 0)</CODE></p>
<p class=book><CODE>25 return status;</CODE></p>
<p class=book><CODE>26 status = pthread_cond_init (&crew-&gt;done, NULL);</CODE></p>
<p class=book><CODE>27 if (status != 0)</CODE></p>
<p class=book><CODE>28 return status;</CODE></p>
<p class=book><CODE>29 status = pthread_cond_init (&crew-&gt;go, NULL);</CODE></p>
<p class=book><CODE>30 if (status != 0)</CODE></p>
<p class=book><CODE>31 return status;</CODE> </p>
<p class=book><CODE>32</CODE></p>
<p class=book><CODE>33 /*</CODE></p>
<p class=book><CODE>34 * Create the worker threads.</CODE></p>
<p class=book><CODE>35 */</CODE></p>
<p class=book><CODE>36 for (crew_index = 0; crew_index &lt; CREW_SIZE; crew_index++) {</CODE></p>
<p class=book><CODE>37 crew-&gt;crew[crew_index].index = crew_index;</CODE></p>
<p class=book><CODE>38 crew-&gt;crew[crew_index].crew = crew;</CODE></p>
<p class=book><CODE>39 status = pthread_create (&crew-&gt;crew[crew_index].thread,</CODE></p>
<p class=book><CODE>40 NULL, worker_routine, (void*)&crew-&gt;crew[crew_index]);</CODE></p>
<p class=book><CODE>41 if (status != 0)</CODE></p>
<p class=book><CODE>42 err_abort (status, "Create worker");</CODE></p>
<p class=book><CODE>43 }</CODE></p>
<p class=book><CODE>44 return 0;</CODE></p>
<p class=book><CODE>45 }</CODE></p>
<p class=book>Part 4 shows the crew_start function, which is called to assign a new path name and search string to the work crew. The function is synchronous — that is, after assigning the task it waits for the crew members to complete the task before returning to the caller. The crew_start function assumes that the crew_t structure has been previously created by calling crew_create, shown in part 3, but does not attempt to validate the structure. </p>
<p class=book><b>20-26</b> Wait for the crew members to finish any previously assigned work. Although crew_start is synchronous, the crew may be processing a task assigned by another thread. On creation, the crew's work_count is set to 0, so the first call to crew start will not need to wait.</p>
<p class=book><b>28-43</b> Get the proper values of path_max and name_max for the file system specified by the file path we'll be reading. The <CODE>pathconf</CODE> function may return a value of -1 without setting errno, if the requested value for the file system is "unlimited." To detect this, we need to clear errno before making the call. If <CODE>pathconf</CODE> returns -1 without setting errno, assume reasonable values.</p>
<p class=book><b>47-48</b> The values returned by pathconf don't include the terminating null character of a string — so add one character to both.</p>
<p class=book><b>49-67</b> Allocate a work queue entry (work_t) and fill it in. Add it to the end of the request queue.</p>
<p class=book><b>68-75</b> We've queued a single work request, so awaken one of the waiting work crew members by signaling the condition variable. If the attempt fails, free the work request, clear the work queue, and return with the error.</p>
<p class=book><b>76-80</b> Wait for the crew to complete the task. The crew members handle all output, so when they're done we simply return to the caller.</p>
<p class=book>■ crew.c part 4 crew_start</p>
<p class=book><CODE>1 /*</CODE></p>
<p class=book><CODE>2 * Pass a file path to a work crew previously created</CODE></p>
<p class=book><CODE>3 * using crew_create</CODE></p>
<p class=book><CODE>4 */</CODE></p>
<p class=book><CODE>5 int crew_start (</CODE></p>
<p class=book><CODE>6 crew_p crew,</CODE></p>
<p class=book><CODE>7 char *filepath,</CODE></p>
<p class=book><CODE>8 char *search)</CODE></p>
<p class=book><CODE>9 {</CODE></p>
<p class=book><CODE>10 work_p request;</CODE></p>
<p class=book><CODE>11 int status;</CODE> </p>
<p class=book><CODE>12</CODE></p>
<p class=book><CODE>13 status = pthread_mutex_lock (&crew-&gt;mutex);</CODE></p>
<p class=book><CODE>14 if (status != 0)</CODE></p>
<p class=book><CODE>15 return status;</CODE> </p>
<p class=book><CODE>16</CODE></p>
<p class=book><CODE>17 /*</CODE></p>
<p class=book><CODE>18 * If the crew is busy, wait for them to finish.</CODE></p>
<p class=book><CODE>19 */</CODE></p>
<p class=book><CODE>20 while (crew-&gt;work_count &gt; 0) {</CODE></p>
<p class=book><CODE>21 status = pthread_cond_wait (&crew-&gt;done, &crew-&gt;mutex);</CODE></p>
<p class=book><CODE>22 if (status != 0) {</CODE></p>
<p class=book><CODE>23 pthread_mutex_unlock (&crew-&gt;mutex);</CODE></p>
<p class=book><CODE>24 return status;</CODE></p>
<p class=book><CODE>25 }</CODE></p>
<p class=book><CODE>26 } 27</CODE></p>
<p class=book><CODE>28 errno = 0;</CODE></p>
<p class=book><CODE>29 path_max = pathconf (filepath, _PC_PATH_MAX);</CODE></p>
<p class=book><CODE>30 if (path_max == -1) {</CODE></p>
<p class=book><CODE>31 if (errno == 0)</CODE></p>
<p class=book><CODE>32 path_max = 1024; /* "No limit" */</CODE></p>
<p class=book><CODE>33 else</CODE></p>
<p class=book><CODE>34 errno_abort ("Unable to get PATH_MAX");</CODE></p>
<p class=book><CODE>35 }</CODE></p>
<p class=book><CODE>36 errno = 0;</CODE></p>
<p class=book><CODE>37 name_max = pathconf (filepath, _PC_NAME_MAX);</CODE></p>
<p class=book><CODE>38 if (name_max == -1) {</CODE></p>
<p class=book><CODE>39 if (errno == 0)</CODE></p>
<p class=book><CODE>40 name_max = 256; /* "No limit" */</CODE></p>
<p class=book><CODE>41 else</CODE></p>
<p class=book><CODE>42 errno_abort ("Unable to get NAME_MAX");</CODE></p>
<p class=book><CODE>43 }</CODE></p>
<p class=book><CODE>44 DPRINTF ((</CODE></p>
<p class=book><CODE>45 "PATH_MAX for %s is %ld, NAME_MAX is %ld\n",</CODE></p>
<p class=book><CODE>46 filepath, path_max, name_max));</CODE></p>
<p class=book><CODE>47 path_max++; /* Add null byte */</CODE></p>
<p class=book><CODE>48 name_max++; /* Add null byte */</CODE></p>
<p class=book><CODE>49 request = (work_p)malloc (sizeof (work_t));</CODE></p>
<p class=book><CODE>50 if (request == NULL)</CODE></p>
<p class=book><CODE>51 errno_abort ("Unable to allocate request");</CODE></p>
<p class=book><CODE>52 DPRINTF (("Requesting %s\n", filepath));</CODE></p>
<p class=book><CODE>53 request-&gt;path = (char*)malloc (path_max);</CODE></p>
<p class=book><CODE>54 if (request-&gt;path == NULL)</CODE></p>
<p class=book><CODE>55 errno_abort ("Unable to allocate path");</CODE></p>
<p class=book><CODE>56 strcpy (request-&gt;path, filepath);</CODE></p>
<p class=book><CODE>57 request-&gt;string = search;</CODE></p>
<p class=book><CODE>58 request-&gt;next = NULL;</CODE></p>
<p class=book><CODE>59 if (crew-&gt;first == NULL) {</CODE></p>
<p class=book><CODE>60 crew-&gt;first = request;</CODE></p>
<p class=book><CODE>61 crew-&gt;last = request;</CODE></p>
<p class=book><CODE>62 } else {</CODE></p>
<p class=book><CODE>63 crew-&gt;last-&gt;next = request;</CODE></p>
<p class=book><CODE>64 crew-&gt;last = request;</CODE></p>
<p class=book><CODE>65 } 66</CODE></p>
<p class=book><CODE>67 crew-&gt;work_count++;</CODE></p>
<p class=book><CODE>68 status = pthread_cond_signal (&crew-&gt;go);</CODE></p>
<p class=book><CODE>69 if (status != 0) {</CODE></p>
<p class=book><CODE>70 free (crew-&gt;first);</CODE></p>
<p class=book><CODE>71 crew-&gt;first = NULL;</CODE></p>
<p class=book><CODE>72 crew-&gt;work_count = 0;</CODE></p>
<p class=book><CODE>73 pthread_mutex_unlock (&crew-&gt;mutex);</CODE></p>
<p class=book><CODE>74 return status;</CODE></p>
<p class=book><CODE>75 }</CODE></p>
<p class=book><CODE>76 while (crew-&gt;work_count &gt; 0) {</CODE></p>
<p class=book><CODE>77 status = pthread_cond_wait (&crew-&gt;done, &crew-&gt;mutex);</CODE></p>
<p class=book><CODE>78 if (status != 0)</CODE></p>
<p class=book><CODE>79 err_abort (status, "waiting for crew to finish");</CODE></p>
<p class=book><CODE>80 }</CODE></p>
<p class=book><CODE>81 status = pthread_mutex_unlock (&crew-&gt;mutex);</CODE></p>
<p class=book><CODE>82 if (status != 0)</CODE></p>
<p class=book><CODE>83 err_abort (status, "Unlock crew mutex");</CODE></p>
<p class=book><CODE>84 return 0;</CODE></p>
<p class=book><CODE>85 }</CODE></p>
<p class=book>Part 5 shows the initial thread (main) for the little work crew sample.</p>
<p class=book><b>10-13</b> The program requires three arguments — the program name, a string for which to search, and a path name. For example, "crew butenhof ~"</p>
<p class=book><b>15-23</b> On a Solaris system, call thr_setconcurrency to ensure that at least one LWP (kernel execution context) is created for each crew member. The program will work without this call, but, on a uniprocessor, you would not see any concurrency. See Section 5.6.3 for more information on "many to few" scheduling models, and Section 10.1.3 for information on "set concurrency" functions.</p>
<p class=book><b>24-30</b> Create a work crew, and assign to it the concurrent file search.</p>
<p class=book>■ <b>crew.c part 5 main</b></p>
<p class=book><CODE>1 /*</CODE></p>
<p class=book><CODE>2 * The main program to "drive" the crew...</CODE></p>
<p class=book><CODE>3 */</CODE></p>
<p class=book><CODE>4 int main (int argc, char *argv[])</CODE></p>
<p class=book><CODE>5 {</CODE></p>
<p class=book><CODE>6 	crew_t my_crew;</CODE></p>
<p class=book><CODE>7 	char line[128], *next;</CODE></p>
<p class=book><CODE>8 	int status;</CODE> </p>
<p class=book><CODE>9</CODE></p>
<p class=book><CODE>10 	if (argc &lt; 3)  {</CODE></p>
<p class=book><CODE>11 		fprintf (stderr,  "Usage: %s string path\n", argv[0]);</CODE></p>
<p class=book><CODE>12 		return -1;</CODE></p>
<p class=book><CODE>13 	}</CODE></p>
<p class=book><CODE>14</CODE> </p>
<p class=book><CODE>15 #ifdef sun</CODE></p>
<p class=book><CODE>16 /*</CODE></p>
<p class=book><CODE>17 * On Solaris 2.5, threads are not timesliced. To ensure</CODE></p>
<p class=book><CODE>18 * that our threads can run concurrently, we need to</CODE></p>
<p class=book><CODE>19 * increase the concurrency level to CREW_SIZE.</CODE></p>
<p class=book><CODE>20 */</CODE></p>
<p class=book><CODE>21 	DPRINTF (("Setting concurrency level to %d\n", CREW_SIZE));</CODE></p>
<p class=book><CODE>22 	thr_setconcurrency (CREW_SIZE);</CODE></p>
<p class=book><CODE>23 #endif</CODE></p>
<p class=book><CODE>24 	status = crew_create (&my_crew, CREW_SIZE);</CODE></p>
<p class=book><CODE>25 	if (status != 0)</CODE></p>
<p class=book><CODE>26 		err_abort (status,  "Create crew");</CODE></p>
<p class=book><CODE>27</CODE></p>
<p class=book><CODE>28 	status = crew_start (&my_crew, argv[2], argv[l]);</CODE></p>
<p class=book><CODE>29 	if (status != 0)</CODE></p>
<p class=book><CODE>30 		err_abort (status,  "Start crew");</CODE> </p>
<p class=book><CODE>31</CODE></p>
<p class=book><CODE>32 	return 0;</CODE></p>
<p class=book><CODE>33 }</CODE></p>


<a name=t66></a><h3 class=book>
4.3 Client/Server
</h3>
<blockquote class="epigraph">
<p class=book>But the Judge said he never had summed up before;</p>
<p class=book>So the Snark undertook it instead,</p>
<p class=book>And summed it so well that it came to far more </p>
<p class=book>Than the Witnesses ever had said!</p>
<blockquote class=book><i>— <i>Lewis Carroll, The Hunting of the Snark</i></i></blockquote>
</blockquote>
<p class=book>In a client/server system, a "client" requests that a "server" perform some operation on a set of data (Figure 4.3). The server performs the operation independently — the client can either wait for the server or proceed in parallel and look for the result at a later time when the result is required. Although it is simplest to have the client wait for the server, that's rarely very useful — it certainly doesn't</p>
<br>
<img border=0 style='spacing 9px;' src="img_13.png">
<p class=book><b>FIGURE 4.3</b> <i>Client/Server</i></p>
<p class=book>provide a speed advantage to the client. On the other hand, it can be an easy way to manage synchronization for some common resource.</p>
<p class=book>If a set of threads all need to read input from <CODE>stdin</CODE>, it might be confusing for them to each issue independent prompt-and-read operations. Imagine that two threads each writes its prompt using <CODE>printf</CODE>, and then each reads the response using gets — you would have no way of knowing to which thread you were responding. If one thread asks "OK to send mail?" and the other asks "OK to delete root directory?" you'd probably like to know which thread will receive your response. Of course there are ways to keep the prompt and response "connected" without introducing a server thread; for example, by using the flockfile and funlockfile functions to lock both stdin and stdout around the prompt-and-read sequences, but a server thread is more interesting — and certainly more relevant to this section.</p>
<p class=book>In the following program, server.c, each of four threads will repeatedly read, and then echo, input lines. When the program is run you should see the threads prompt in varying orders, and another thread may prompt before the echo. But you'll never see a prompt or an echo between the prompt and read performed by the "prompt server."</p>
<p class=book><b>7-9</b> These symbols define the commands that can be sent to the "prompt server." It can be asked to read input, <i>write</i> output, or <i>quit.</i></p>
<p class=book><b>14-22</b> The request_t structure defines each request to the server. The outstanding requests are linked in a list using the next member. The operation member contains one of the request codes (read, write, or quit). The synchronous member is nonzero if the client wishes to wait for the operation to be completed (synchronous), or 0 if it does not wish to wait (asynchronous).</p>
<p class=book><b>27-33</b> The tty_server_t structure provides the context for the server thread. It has the synchronization objects (mutex and request), a flag denoting whether the server is running, and a list of requests that have been made and not yet processed (first and last).</p>
<p class=book><b>35-37</b> This program has a single server, and the control structure (tty_server) is statically allocated and initialized here. The list of requests is empty, and the server is not running. The mutex and condition variable are statically initialized.</p>
<p class=book><b>43-45</b> The main program and client threads coordinate their shutdown using these synchronization objects (client_mutex and clients_done) rather than using pthread_join.</p>
<p class=book>■ <b>server.c</b> <b>part 1 definitions</b></p>
<p class=book><CODE>1 #include &lt;pthread.h&gt;</CODE></p>
<p class=book><CODE>2 #include &lt;math.h&gt;</CODE></p>
<p class=book><CODE>3 #include "errors.h" 4</CODE></p>
<p class=book><CODE>5 #define CLIENT THREADS 4 /* Number of clients */</CODE></p>
<p class=book><CODE>6</CODE></p>
<p class=book><CODE>7 #define REQ_READ 1	/* Read with prompt */</CODE></p>
<p class=book><CODE>8 #define REQ WRITE 2	 /* Write */</CODE></p>
<p class=book><CODE>9 #define REQ_QUIT 3 /* Quit server */</CODE></p>
<p class=book><CODE>10</CODE></p>
<p class=book><CODE>11 /*</CODE></p>
<p class=book><CODE>12 * Internal to server "package" — one for each request.</CODE></p>
<p class=book><CODE>13 */</CODE></p>
<p class=book><CODE>14 typedef struct request_tag {</CODE></p>
<p class=book><CODE>15 	struct request_tag *next; /* Link to next */</CODE></p>
<p class=book><CODE>16 	int operation; /* Function code */</CODE></p>
<p class=book><CODE>17 	int synchronous; /* Nonzero if synchronous */</CODE></p>
<p class=book><CODE>18 	int done_flag; /* Predicate for wait */</CODE></p>
<p class=book><CODE>19 	pthread_cond_t done; /* Wait for completion */</CODE></p>
<p class=book><CODE>20 	char prompt[32]; /* Prompt string for reads */</CODE></p>
<p class=book><CODE>21 	char text[128]; /* Read/write text */</CODE></p>
<p class=book><CODE>22 } request_t;</CODE> </p>
<p class=book><CODE>23</CODE></p>
<p class=book><CODE>24 /*</CODE></p>
<p class=book><CODE>25 * Static context for the server</CODE></p>
<p class=book><CODE>26 */</CODE></p>
<p class=book><CODE>27 typedef struct tty_server_tag {</CODE></p>
<p class=book><CODE>28 	request_t *first;</CODE></p>
<p class=book><CODE>29 	request_t *last;</CODE></p>
<p class=book><CODE>30 	int running;</CODE></p>
<p class=book><CODE>31 	pthread_mutex_t mutex;</CODE></p>
<p class=book><CODE>32 	pthread_cond_t request;</CODE></p>
<p class=book><CODE>33 } tty_server_t;</CODE> </p>
<p class=book><CODE>34</CODE></p>
<p class=book><CODE>35 tty_server_t tty_server = {</CODE></p>
<p class=book><CODE>36 	NULL, NULL, 0,</CODE></p>
<p class=book><CODE>37 	PTHREAD MUTEX_INITIALIZER, PTHREAD_COND_INITIALIZER};</CODE></p>
<p class=book><CODE>38</CODE></p>
<p class=book><CODE>39 /*</CODE></p>
<p class=book><CODE>40 * Main program data</CODE></p>
<p class=book><CODE>41 */ 42</CODE></p>
<p class=book><CODE>43 int client_threads;</CODE></p>
<p class=book><CODE>44 pthread_mutex_t client_mutex = PTHREAD_MUTEX_INITIALIZER;</CODE></p>
<p class=book><CODE>45 pthread_cond_t clients_done = PTHREAD_COND_INITIALIZER;</CODE></p>
<p class=book>Part 2 shows the server thread function, tty_server_routine. It loops, processing requests continuously until asked to quit.</p>
<p class=book><b>25-30</b> The server waits for a request to appear using the request condition variable.</p>
<p class=book><b>31-34</b> Remove the first request from the queue — if the queue is now empty, also clear the pointer to the last entry (tty_server.last).</p>
<p class=book><b>43-66</b> The switch statement performs the requested work, depending on the operation given in the request packet. REQ_QUIT tells the server to shut down. REQ_ READ tells the server to read, with an optional prompt string. REQ_WRITE tells the server to write a string.</p>
<p class=book><b>67-79</b> If a request is marked "synchronous" (synchronous flag is nonzero), the server sets done_flag and signals the done condition variable. When the request is synchronous, the client is responsible for freeing the request packet. If the request was asynchronous, the server frees request on completion.</p>
<p class=book><b>80-81</b> If the request was REQ_QUIT, terminate the server thread by breaking out of the while loop, to the return statement.</p>
<p class=book>■ <b>server.c part 2 tty_server_routine</b></p>
<p class=book><CODE>1 /*</CODE></p>
<p class=book><CODE>2 * The server start routine. It waits for a request to appear</CODE></p>
<p class=book><CODE>3 * in tty_server.requests using the request condition variable.</CODE></p>
<p class=book><CODE>4 * It processes requests in FIFO order. If a request is marked</CODE></p>
<p class=book><CODE>5 * "synchronous" (synchronous != 0), the server will set done_flag</CODE></p>
<p class=book><CODE>6 * and signal the request's condition variable. The client is</CODE></p>
<p class=book><CODE>7 * responsible for freeing the request. If the request was not</CODE></p>
<p class=book><CODE>8 * synchronous, the server will free the request on completion.</CODE></p>
<p class=book><CODE>9 */</CODE></p>
<p class=book><CODE>10 void *tty_server_routine (void *arg)</CODE></p>
<p class=book><CODE>11 {</CODE></p>
<p class=book><CODE>12 static pthread_mutex_t prompt_mutex = PTHREAD_MUTEX_INITIALIZER;</CODE></p>
<p class=book><CODE>13 request_t *request;</CODE></p>
<p class=book><CODE>14 int operation, len;</CODE></p>
<p class=book><CODE>15 int status;</CODE> </p>
<p class=book><CODE>16</CODE></p>
<p class=book><CODE>17 while (1) {</CODE></p>
<p class=book><CODE>18 status = pthread_mutex_lock (&tty_server.mutex);</CODE></p>
<p class=book><CODE>19 if (status != 0)</CODE></p>
<p class=book><CODE>20 err_abort (status, "Lock server mutex");</CODE> </p>
<p class=book><CODE>21</CODE></p>
<p class=book><CODE>22 /*</CODE></p>
<p class=book><CODE>23 * Wait for data</CODE></p>
<p class=book><CODE>24 */ </CODE></p>
<p class=book><CODE>25 while (tty_server.first == NULL) {</CODE></p>
<p class=book><CODE>26 status = pthread_cond_wait (</CODE></p>
<p class=book><CODE>27 &tty_server.request, &tty_server.mutex);</CODE></p>
<p class=book><CODE>28 if (status != 0)</CODE></p>
<p class=book><CODE>29 err_abort (status, "Wait for request");</CODE></p>
<p class=book><CODE>30 }</CODE></p>
<p class=book><CODE>31 request = tty_server.first;</CODE></p>
<p class=book><CODE>32 tty_server.first = request-&gt;next;</CODE></p>
<p class=book><CODE>33 if (tty_server.first == NULL)</CODE></p>
<p class=book><CODE>34 tty_server.last = NULL;</CODE></p>
<p class=book><CODE>35 status = pthread_mutex_unlock (&tty_server.mutex);</CODE></p>
<p class=book><CODE>36 if (status != 0)</CODE></p>
<p class=book><CODE>37 err_abort (status, "Unlock server mutex");</CODE></p>
<p class=book><CODE>38</CODE></p>
<p class=book><CODE>39 /*</CODE></p>
<p class=book><CODE>40 * Process the data</CODE></p>
<p class=book><CODE>41 */</CODE></p>
<p class=book><CODE>42 operation = request-&gt;operation;</CODE></p>
<p class=book><CODE>43 switch (operation) {</CODE></p>
<p class=book><CODE>44 case REQ_QUIT:</CODE></p>
<p class=book><CODE>45 break;</CODE></p>
<p class=book><CODE>46 case REQ_READ:</CODE></p>
<p class=book><CODE>47 if (strlen (request-&gt;prompt) &gt; 0)</CODE></p>
<p class=book><CODE>48 printf (request-&gt;prompt);</CODE></p>
<p class=book><CODE>49 if (fgets (request-&gt;text, 128, stdin) == NULL)</CODE></p>
<p class=book><CODE>50 request-&gt;text[0] = '\0';</CODE></p>
<p class=book><CODE>51 /*</CODE></p>
<p class=book><CODE>52 * Because fgets returns the newline, and we don't</CODE></p>
<p class=book><CODE>53 * want it, we look for it, and turn it into a null</CODE></p>
<p class=book><CODE>54 * (truncating the input) if found. It should be the</CODE></p>
<p class=book><CODE>55 * last character, if it is there.</CODE></p>
<p class=book><CODE>56 */</CODE></p>
<p class=book><CODE>57 len = strlen (request-&gt;text);</CODE></p>
<p class=book><CODE>58 if (len &gt; 0 && request-&gt;text[len-l] == '\n')</CODE></p>
<p class=book><CODE>59 request-&gt;text[len-l] = '\0';</CODE></p>
<p class=book><CODE>60 break;</CODE></p>
<p class=book><CODE>61 case REQ_WRITE:</CODE></p>
<p class=book><CODE>62 puts (request-&gt;text);</CODE></p>
<p class=book><CODE>63 break;</CODE></p>
<p class=book><CODE>64 default:</CODE></p>
<p class=book><CODE>65 break;</CODE></p>
<p class=book><CODE>66 }</CODE></p>
<p class=book><CODE>67 if (request-&gt;synchronous) {</CODE></p>
<p class=book><CODE>68 status = pthread_mutex_lock (&tty_server.mutex);</CODE></p>
<p class=book><CODE>69 if (status != 0)</CODE></p>
<p class=book><CODE>70 err_abort (status, "Lock server mutex");</CODE></p>
<p class=book><CODE>71 request-&gt;done_flag = 1;</CODE></p>
<p class=book><CODE>72 status = pthread_cond_signal (&request-&gt;done);</CODE></p>
<p class=book><CODE>73 if (status != 0)</CODE></p>
<p class=book><CODE>74 err_abort (status, "Signal server condition");</CODE></p>
<p class=book><CODE>75 status = pthread_mutex_unlock (&tty_server.mutex);</CODE></p>
<p class=book><CODE>76 if (status != 0)</CODE></p>
<p class=book><CODE>77 err_abort (status, "Unlock server mutex");</CODE></p>
<p class=book><CODE>78 } else</CODE></p>
<p class=book><CODE>79 free (request);</CODE></p>
<p class=book><CODE>80 if (operation == REQ_QUIT)</CODE></p>
<p class=book><CODE>81 break;</CODE></p>
<p class=book><CODE>82 }</CODE></p>
<p class=book><CODE>83 return NULL;</CODE></p>
<p class=book><CODE>84 }</CODE></p>
<p class=book>Part 3 shows the function that is called to initiate a request to the tty server thread. The caller specifies the desired operation (REQ_QUIT, REQ_READ, or REQ_ WRITE), whether the operation is synchronous or not (sync), an optional prompt string (prompt) for REQ_READ operations, and the pointer to a string (input for REQ_WRITE, or a buffer to return the result of an REQ_READ operation). </p>
<p class=book><b>16-40</b> If a tty server thread is not already running, start one. A temporary thread attributes object (detached_attr) is created, and the <i>detachstate</i> attribute is set to PTHREAD_CREATE_DETACHED. Thread attributes will be explained later in Section 5.2.3. In this case, we are just saying that we will not need to use the thread identifier after creation.</p>
<p class=book><b>45-76</b> Allocate and initialize a server request (request_t) packet. If the request is synchronous, initialize the condition variable (done) in the request packet — otherwise the condition variable isn't used. The new request is linked onto the request queue.</p>
<p class=book><b>81-83</b> Wake the server thread to handle the queued request. </p>
<p class=book><b>88-105</b> If the request is synchronous, wait for the server to set done_flag and signal the done condition variable. If the operation is REQ_READ, copy the result string into the output buffer. Finally, destroy the condition variable, and free the request packet.</p>
<p class=book>■ <b>server.c</b> <b>part 3 tty_server_request</b></p>
<p class=book><CODE>1 /*</CODE></p>
<p class=book><CODE>2 * Request an operation</CODE></p>
<p class=book><CODE>3 */</CODE></p>
<p class=book><CODE>4 void tty_server_request (</CODE></p>
<p class=book><CODE>5 int operation,</CODE></p>
<p class=book><CODE>6 int sync,</CODE></p>
<p class=book><CODE>7 const char *prompt,</CODE></p>
<p class=book><CODE>8 char *string)</CODE></p>
<p class=book><CODE>9 {</CODE></p>
<p class=book><CODE>10 request_t *request;</CODE></p>
<p class=book><CODE>11 int status;</CODE> </p>
<p class=book><CODE>12</CODE></p>
<p class=book><CODE>13 status = pthread_mutex_lock (&tty_server.mutex);</CODE></p>
<p class=book><CODE>14 if (status != 0)</CODE></p>
<p class=book><CODE>15 err_abort (status, "Lock server mutex");</CODE></p>
<p class=book><CODE>16 if (!tty_server.running) {</CODE></p>
<p class=book><CODE>17 pthread_t thread;</CODE></p>
<p class=book><CODE>18 pthread_attr_t detached_attr;</CODE> </p>
<p class=book><CODE>19</CODE></p>
<p class=book><CODE>20 status = pthread_attr_init (&detached_attr);</CODE></p>
<p class=book><CODE>21 if (status != 0)</CODE></p>
<p class=book><CODE>22 err_abort (status, "Init attributes object");</CODE></p>
<p class=book><CODE>23 status = pthread_attr_setdetachstate (</CODE></p>
<p class=book><CODE>24 &detached_attr, PTHREAD_CREATE_DETACHED);</CODE></p>
<p class=book><CODE>25 if (status != 0)</CODE></p>
<p class=book><CODE>26 err_abort (status, "Set detach state");</CODE></p>
<p class=book><CODE>27 tty_server.running = 1;</CODE></p>
<p class=book><CODE>28 status = pthread_create (&thread, &detached_attr,</CODE></p>
<p class=book><CODE>29 tty_server_routine, NULL);</CODE></p>
<p class=book><CODE>30 if (status != 0)</CODE></p>
<p class=book><CODE>31 err_abort (status, "Create server");</CODE> </p>
<p class=book><CODE>32</CODE></p>
<p class=book><CODE>33 /*</CODE></p>
<p class=book><CODE>34 * Ignore an error in destroying the attributes object.</CODE></p>
<p class=book><CODE>35 * It's unlikely to fail, there's nothing useful we can</CODE></p>
<p class=book><CODE>36 * do about it, and it's not worth aborting the program</CODE></p>
<p class=book><CODE>37 * over it.</CODE></p>
<p class=book><CODE>38 */</CODE></p>
<p class=book><CODE>39 pthread_attr_destroy (&detached_attr);</CODE></p>
<p class=book><CODE>40 }</CODE> </p>
<p class=book><CODE>41</CODE></p>
<p class=book><CODE>42 /*</CODE></p>
<p class=book><CODE>43 * Create and initialize a request structure.</CODE></p>
<p class=book><CODE>44 */</CODE></p>
<p class=book><CODE>45 request = (request_t*)malloc (sizeof (request_t));</CODE></p>
<p class=book><CODE>46 if (request == NULL)</CODE></p>
<p class=book><CODE>47 errno_abort ("Allocate request");</CODE></p>
<p class=book><CODE>48 request-&gt;next = NULL;</CODE></p>
<p class=book><CODE>49 request-&gt;operation = operation;</CODE></p>
<p class=book><CODE>50 request-&gt;synchronous = sync;</CODE></p>
<p class=book><CODE>51 if (sync) {</CODE></p>
<p class=book><CODE>52 request-&gt;done_flag = 0;</CODE></p>
<p class=book><CODE>53 status = pthread_cond_init (&request-&gt;done, NULL);</CODE></p>
<p class=book><CODE>54 if (status != 0)</CODE></p>
<p class=book><CODE>55 err_abort (status, "Init request condition");</CODE></p>
<p class=book><CODE>56 }</CODE></p>
<p class=book><CODE>57 if (prompt != NULL)</CODE></p>
<p class=book><CODE>58 strncpy (request-&gt;prompt, prompt, 32);</CODE></p>
<p class=book><CODE>59 else</CODE></p>
<p class=book><CODE>60 request-&gt;prompt[0] = '\0';</CODE></p>
<p class=book><CODE>61 if (operation == REQ_WRITE && string != NULL)</CODE></p>
<p class=book><CODE>62 strncpy (request-&gt;text, string, 128);</CODE></p>
<p class=book><CODE>63 else</CODE></p>
<p class=book><CODE>64 request-&gt;text[0] = '\0';</CODE> </p>
<p class=book><CODE>65</CODE></p>
<p class=book><CODE>66 /*</CODE></p>
<p class=book><CODE>67 * Add the request to the queue, maintaining the first and</CODE></p>
<p class=book><CODE>68 * last pointers.</CODE></p>
<p class=book><CODE>69 */</CODE></p>
<p class=book><CODE>70 if (tty_server.first == NULL) {</CODE></p>
<p class=book><CODE>71 tty_server.first = request;</CODE></p>
<p class=book><CODE>72 tty_server.last = request;</CODE></p>
<p class=book><CODE>73 } else {</CODE></p>
<p class=book><CODE>74 (tty_server.last)-&gt;next = request;</CODE></p>
<p class=book><CODE>75 tty_server.last = request;</CODE></p>
<p class=book><CODE>76 } 77</CODE></p>
<p class=book><CODE>78 /*</CODE></p>
<p class=book><CODE>79 * Tell the server that a request is available.</CODE></p>
<p class=book><CODE>80 */</CODE></p>
<p class=book><CODE>81 status = pthread_cond_signal (&tty_server.request);</CODE></p>
<p class=book><CODE>82 if (status != 0)</CODE></p>
<p class=book><CODE>83 err_abort (status, "Wake server");</CODE></p>
<p class=book><CODE>84</CODE></p>
<p class=book><CODE>85 /*</CODE></p>
<p class=book><CODE>86 * If the request was "synchronous", then wait for a reply.</CODE></p>
<p class=book><CODE>87 */</CODE></p>
<p class=book><CODE>88 if (sync) {</CODE></p>
<p class=book><CODE>89 while (!request-&gt;done_flag) {</CODE></p>
<p class=book><CODE>90 status = pthread_cond_wait (</CODE></p>
<p class=book><CODE>91 &request-&gt;done, &tty_server.mutex);</CODE></p>
<p class=book><CODE>92 if (status != 0)</CODE></p>
<p class=book><CODE>93 err_abort (status, "Wait for sync request");</CODE></p>
<p class=book><CODE>94 }</CODE></p>
<p class=book><CODE>95 if (operation == REQ_READ) {</CODE></p>
<p class=book><CODE>96 if (strlen (request-&gt;text) &gt; 0)</CODE></p>
<p class=book><CODE>97 strcpy (string, request-&gt;text);</CODE></p>
<p class=book><CODE>98 else</CODE></p>
<p class=book><CODE>99 string[0] = '\0*;</CODE></p>
<p class=book><CODE>100 }</CODE></p>
<p class=book><CODE>101 status = pthread_cond_destroy (&request-&gt;done);</CODE></p>
<p class=book><CODE>102 if (status != 0)</CODE></p>
<p class=book><CODE>103 err_abort (status, "Destroy request condition");</CODE></p>
<p class=book><CODE>104 free (request);</CODE></p>
<p class=book><CODE>105 }</CODE></p>
<p class=book><CODE>106 status = pthread_mutex_unlock (&tty_server.mutex);</CODE></p>
<p class=book><CODE>107 if (status != 0)</CODE></p>
<p class=book><CODE>108 err_abort (status, "Unlock mutex");</CODE></p>
<p class=book><CODE>109 }</CODE></p>
<p class=book>Part 4 shows the thread start function for the client threads, which repeatedly queue tty operation requests to the server. </p>
<p class=book><b>12-22</b> Read a line through the tty server. If the resulting string is empty, break out of the loop and terminate. Otherwise, loop four times printing the result string, at one-second intervals. Why four? It just "mixes things up" a little. </p>
<p class=book><b>26-31</b> Decrease the count of client threads, and wake the main thread if this is the last client thread to terminate.</p>
<p class=book>■ <b>server.c part 4 client_routine</b></p>
<p class=book><CODE>1 /*</CODE></p>
<p class=book><CODE>2 * Client routine — multiple copies will request server.</CODE></p>
<p class=book><CODE>3 */</CODE></p>
<p class=book><CODE>4 void *client_routine (void *arg)</CODE></p>
<p class=book><CODE>5 {</CODE></p>
<p class=book><CODE>6 int my_number = (int)arg, loops;</CODE></p>
<p class=book><CODE>7 char prompt[32];</CODE></p>
<p class=book><CODE>8 char string[128], formatted[128];</CODE></p>
<p class=book><CODE>9 int status;</CODE> </p>
<p class=book><CODE>10</CODE></p>
<p class=book><CODE>11 sprintf (prompt, "Client %d&gt; ", my_number);</CODE></p>
<p class=book><CODE>12 while (1) {</CODE></p>
<p class=book><CODE>13 tty_server_request (REQ_READ, 1, prompt, string);</CODE></p>
<p class=book><CODE>14 if (strlen (string) == 0)</CODE></p>
<p class=book><CODE>15 break;</CODE></p>
<p class=book><CODE>16 for (loops = 0; loops &lt; 4; loops++) {</CODE></p>
<p class=book><CODE>17 sprintf (</CODE></p>
<p class=book><CODE>18 formatted, "(%d#%d) %s", my_number, loops, string);</CODE></p>
<p class=book><CODE>19 tty_server_request (REQ_WRITE, 0, NULL, formatted);</CODE></p>
<p class=book><CODE>20 sleep (1);</CODE></p>
<p class=book><CODE>21 }</CODE></p>
<p class=book><CODE>22 }</CODE></p>
<p class=book><CODE>23 status = pthread_mutex_lock (&client_mutex);</CODE></p>
<p class=book><CODE>24 if (status != 0)</CODE></p>
<p class=book><CODE>25 err_abort (status, "Lock client mutex");</CODE></p>
<p class=book><CODE>26 client_threads--;</CODE></p>
<p class=book><CODE>27 if (client_threads &lt;= 0) {</CODE></p>
<p class=book><CODE>28 status = pthread_cond_signal (&clients_done);</CODE></p>
<p class=book><CODE>29 if (status != 0)</CODE></p>
<p class=book><CODE>30 err_abort (status, "Signal clients done");</CODE></p>
<p class=book><CODE>31 }</CODE></p>
<p class=book><CODE>32 status = pthread_mutex_unlock (&client_mutex);</CODE></p>
<p class=book><CODE>33 if (status != 0)</CODE></p>
<p class=book><CODE>34 err_abort (status, "Unlock client mutex");</CODE></p>
<p class=book><CODE>35 return NULL;</CODE></p>
<p class=book><CODE>36 }</CODE></p>
<p class=book>■ <b>server.c</b> <b>part 4 client_routine</b></p>
<p class=book>Part 5 shows the main program for server.c. It creates a set ofclient threads to utilize the tty server, and waits for them. </p>
<p class=book><b>7-15</b> On a Solaris system, set the concurrency level to the number of client threads by calling thr_setconcurrency. Because all the client threads will spend some of their time blocked on condition variables, we don't really need to increase the concurrency level for this program — however, it will provide less predictable execution behavior. </p>
<p class=book><b>20-26</b> Create the client threads.</p>
<p class=book><b>27-35</b> This construct is much like pthread_join, except that it completes only when all of the client threads have terminated. As I have said elsewhere, pthread_join is nothing magical, and there is no reason to use it to detect thread termination unless it does exactly what you want. Joining multiple threads in a loop with pthread_join is rarely exactly what you want, and a "multiple join" like that shown here is easy to construct.</p>
<p class=book>■ <b>server.c part 5 main</b></p>
<p class=book><CODE>1 int main (int argc, char *argv[])</CODE></p>
<p class=book><CODE>2 {</CODE></p>
<p class=book><CODE>3 pthread_t thread;</CODE></p>
<p class=book><CODE>4 int count;</CODE></p>
<p class=book><CODE>5 int status; 6</CODE></p>
<p class=book><CODE>7 #ifdef sun</CODE></p>
<p class=book><CODE>8 /*</CODE></p>
<p class=book><CODE>9 * On Solaris 2.5, threads are not timesliced. To ensure</CODE></p>
<p class=book><CODE>10 * that our threads can run concurrently, we need to</CODE></p>
<p class=book><CODE>11 * increase the concurrency level to CLIENT_THREADS.</CODE></p>
<p class=book><CODE>12 */</CODE></p>
<p class=book><CODE>13 DPRINTF (("Setting concurrency level to %d\n", CLIENT_THREADS));</CODE></p>
<p class=book><CODE>14 thr_setconcurrency (CLIENT_THREADS);</CODE></p>
<p class=book><CODE>15 #endif</CODE> </p>
<p class=book><CODE>16</CODE></p>
<p class=book><CODE>17 /*</CODE></p>
<p class=book><CODE>18 * Create CLIENT_THREADS clients.</CODE></p>
<p class=book><CODE>19 */</CODE></p>
<p class=book><CODE>20 client_threads = CLIENT_THREADS;</CODE></p>
<p class=book><CODE>21 for (count = 0; count &lt; client_threads; count++) {</CODE></p>
<p class=book><CODE>22 status = pthread_create (&thread, NULL,</CODE></p>
<p class=book><CODE>23 client_routine, (void*)count);</CODE></p>
<p class=book><CODE>24 if (status != 0)</CODE></p>
<p class=book><CODE>25 err_abort (status, "Create client thread");</CODE></p>
<p class=book><CODE>26 }</CODE></p>
<p class=book><CODE>27 status = pthread_mutex_lock (&client_mutex);</CODE></p>
<p class=book><CODE>28 if (status != 0)</CODE></p>
<p class=book><CODE>29 err_abort (status, "Lock client mutex");</CODE></p>
<p class=book><CODE>30 while (client_threads &gt; 0) {</CODE></p>
<p class=book><CODE>31 status = pthread_cond_wait (&clients_done, &client_mutex);</CODE></p>
<p class=book><CODE>32 if (status != 0)</CODE></p>
<p class=book><CODE>33 err_abort (status, "Wait for clients to finish");</CODE></p>
<p class=book><CODE>34 }</CODE></p>
<p class=book><CODE>35 status = pthread_mutex_unlock (&client_mutex);</CODE></p>
<p class=book><CODE>36 if (status != 0)</CODE></p>
<p class=book><CODE>37 err_abort (status, "Unlock client mutex");</CODE></p>
<p class=book><CODE>38 printf ("All clients done\n");</CODE></p>
<p class=book><CODE>39 tty_server_request (REQ_QUIT, 1, NULL, NULL);</CODE></p>
<p class=book><CODE>40 return 0;</CODE></p>
<p class=book><CODE>41 }</CODE></p>



<a name=t67></a><h3 class=book>
5 Advanced threaded programming
</h3>
<blockquote class="epigraph">
<p class=book>"Take same more tea," the March Hare said to Alice, very earnestly. </p>
<p class=book>"I've had nothing yet,"Alice replied in an offended tone:</p>
<p class=book>"so I ca'n't take more." </p>
<p class=book>"You mean you ca'n't take less,"said the Hatter:</p>
<p class=book>"it's very easy to take more than nothing."</p>
<blockquote class=book><i>— <i>Lewis Carroll, Alice's Adventures in Wonderland</i></i></blockquote>
</blockquote>

<p class=book><i>The</i> Pthreads standard provides many capabilities that aren't needed by many programs. To keep the sections dealing with synchronization and threads relatively simple, the more advanced capabilities are collected into this additional section.</p>
<p class=book>Section 5.1 describes a facility to manage initialization of data, particularly within a library, in a multithreaded environment.</p>
<p class=book>Section 5.2 describes "attributes objects," a way to control various characteristics ofyour threads, mutexes, and condition variables when you create them.</p>
<p class=book>Section 5.3 describes cancellation, a way to ask your threads to "go away" when you don't need them to continue.</p>
<p class=book>Section 5.4 describes thread-specific data, a sort ofdatabase mechanism that allows a library to associate data with individual threads that it encounters and to retrieve that data later.</p>
<p class=book>Section 5.5 describes the Pthreads facilities for realtime scheduling, to help your program interact with the cold, cruel world in a predictable way.</p>


<a name=t68></a><h3 class=book>
5.1 One-time initialization
</h3>
<blockquote class="epigraph">
<p class=book>"Tis the voice of the Jubjub!" he suddenly cried.</p>
<p class=book>(This man, that they used to call "Dunce.")</p>
<p class=book>"As the Bellman would tell you," he added with pride,</p>
<p class=book>"I have uttered that sentiment once."</p>
<blockquote class=book><i>— <i>Lewis Carroll, The Hunting of the Snark</i></i></blockquote>
</blockquote>
<p class=book><b>pthread_once_t once_control = PTHREAD_ONCE_INIT;</b></p>
<p class=book><b>int pthread_once (pthread_once_t *once_control,</b></p>
<p class=book><b>		void (*init_routine) (void));</b></p>
<p class=book>Some things need to be done once and only once, no matter what. When you are initializing an application, it is often easiest to do all that from main, before calling anything else that might depend on the initialization — and, in particular, before creating any threads that might depend on having initialized mutexes, created thread-specific data keys, and so forth.</p>
<p class=book>If you are writing a library, you usually don't have that luxury. But you must still be sure that the necessary initialization has been completed before you can use anything that needs to be initialized. Statically initialized mutexes can help a lot, but sometimes you may find this "one-time initialization" feature more convenient.</p>
<p class=book>In traditional sequential programming, one-time initialization is often managed by a boolean variable. A control variable is statically initialized to 0, and any code that depends on the initialization can test the variable. If the value is still 0 it can perform the initialization and then set the variable to 1. Later checks will skip the initialization.</p>
<p class=book>When you are using multiple threads, it is not that easy. If more than one thread executes the initialization sequence concurrently, two threads may both find initializer to be 0, and both perform the initialization, which, presumably, should have been performed only once. The state of initialization is a shared <i>invariant</i> that must be protected by a mutex.</p>
<p class=book>You can code your own one-time initialization using a boolean variable and a statically initialized mutex. In many cases this will be more convenient than pthread_once, and it will always be more efficient. The main reason for pthread_ once is that you were not originally allowed to statically initialize a mutex. Thus, to use a mutex, you had to first call pthread_mutex_init. You must initialize a mutex only once, so the initialization call must be made in one-time initialization code. The pthread_once function solved this recursive problem. When static initialization of mutexes was added to the standard, pthread_once was retained as a convenience function. If it's convenient, use it, but remember that you don't have to use it.</p>
<p class=book>First, you declare a control variable of type pthread_once_t. The control variable must be statically initialized using the PTHREAD_ONCE_INIT macro, as shown in the following program, called once.c. You must also create a function containing the code to perform all initialization that is to be associated with the control variable. Now, at any time, a thread may call pthread_once, specifying a pointer to the control variable and a pointer to the associated initialization function.</p>
<p class=book>The <CODE>pthread_once</CODE> function first checks the control variable to determine whether the initialization has already completed. If so, <CODE>pthread_once</CODE> simply returns. If initialization has not yet been started, <CODE>pthread_once</CODE> calls the initialization function (with no arguments), and then records that initialization has been completed. If a thread calls <CODE>pthread_once</CODE> while initialization is in progress in another thread, the calling thread will wait until that other thread completes initialization, and then return. In other words, when any call to <CODE>pthread_once</CODE> returns successfully, the caller can be certain that all states initialized by the associated initialization function are ready to go.</p>
<p class=book><b>13-20</b> The function <CODE>once_init_routine</CODE> initializes the mutex when called — the use of <CODE>pthread_once</CODE> ensures that it will be called exactly one time.</p>
<p class=book><b>29</b> The thread function thread_routine calls <CODE>pthread_once</CODE> before using mutex, to ensure that it exists even if it had not already been created by main.</p>
<p class=book><b>51</b> The main program also calls <CODE>pthread_once</CODE> before using mutex, so that the program will execute correctly regardless of when thread_routine runs. Notice that, while I normally stress that all shared data must be initialized before creating any thread that uses it, in this case, the only critical shared data is really the once_block — it is irrelevant that the mutex is not initialized, because the use of <CODE>pthread_once</CODE> ensures proper synchronization.</p>
<p class=book>■ <b>once.c</b></p>
<p class=book><CODE>1 #include &lt;pthread.h&gt;</CODE></p>
<p class=book><CODE>2 #include "errors.h"</CODE> </p>
<p class=book><CODE>3</CODE></p>
<p class=book><CODE>4 pthread_once_t once_block = PTHREAD_ONCE_INIT;</CODE></p>
<p class=book><CODE>5 pthread_mutex_t mutex;</CODE> </p>
<p class=book><CODE>6</CODE></p>
<p class=book><CODE>7 /*</CODE></p>
<p class=book><CODE>8 * This is the one-time initialization routine. It will be</CODE></p>
<p class=book><CODE>9 * called exactly once, no matter how many calls to pthread_once</CODE></p>
<p class=book><CODE>10 * with the same control structure are made during the course of</CODE></p>
<p class=book><CODE>11 * the program.</CODE></p>
<p class=book><CODE>12 */</CODE></p>
<p class=book><CODE>13 void once_init_routine (void)</CODE></p>
<p class=book><CODE>14 {</CODE></p>
<p class=book><CODE>15 	int status;</CODE> </p>
<p class=book><CODE>16</CODE></p>
<p class=book><CODE>17 	status = pthread_mutex_init (&mutex, NULL);</CODE></p>
<p class=book><CODE>18 	if (status != 0)</CODE></p>
<p class=book><CODE>19 		err_abort (status, "Init Mutex");</CODE></p>
<p class=book><CODE>20 }</CODE></p>
<p class=book><CODE>21</CODE></p>
<p class=book><CODE>22 /*</CODE></p>
<p class=book><CODE>23 * Thread start routine that calls pthread_once.</CODE></p>
<p class=book><CODE>24 */</CODE></p>
<p class=book><CODE>25 void *thread_routine (void *arg)</CODE></p>
<p class=book><CODE>26 {</CODE></p>
<p class=book><CODE>27 	int status;</CODE> </p>
<p class=book><CODE>28</CODE></p>
<p class=book><CODE>29 	status = pthread_once (&once_block, once_init_routine);</CODE></p>
<p class=book><CODE>30 	if (status != 0)</CODE></p>
<p class=book><CODE>31 		err_abort (status, "Once init");</CODE></p>
<p class=book><CODE>32 	status = pthread_mutex_lock (&mutex);</CODE></p>
<p class=book><CODE>33 	if (status != 0)</CODE></p>
<p class=book><CODE>34 		err_abort (status, "Lock mutex");</CODE></p>
<p class=book><CODE>35 	printf ("thread_routine has locked the mutex.\n");</CODE></p>
<p class=book><CODE>36 	status = pthread_mutex_unlock (&mutex);</CODE></p>
<p class=book><CODE>37 	if (status != 0)</CODE></p>
<p class=book><CODE>38 		err_abort (status, "Unlock mutex");</CODE></p>
<p class=book><CODE>39 	return NULL;</CODE></p>
<p class=book><CODE>40 }</CODE> </p>
<p class=book><CODE>41</CODE></p>
<p class=book><CODE>42 int main (int argc, char *argv[])</CODE></p>
<p class=book><CODE>43 {</CODE></p>
<p class=book><CODE>44 	pthread_t thread_id;</CODE></p>
<p class=book><CODE>45 	char *input, buffer[64];</CODE></p>
<p class=book><CODE>46 	int status;</CODE> </p>
<p class=book><CODE>47</CODE></p>
<p class=book><CODE>48 	status = pthread_create (&thread_id, NULL, thread_routine, NULL);</CODE></p>
<p class=book><CODE>49 	if (status != 0)</CODE></p>
<p class=book><CODE>50 		err_abort (status, "Create thread");</CODE></p>
<p class=book><CODE>51 	status = pthread_once (&once_block, once_init_routine);</CODE></p>
<p class=book><CODE>52 	if (status != 0)</CODE></p>
<p class=book><CODE>53 		err_abort (status, "Once init");</CODE></p>
<p class=book><CODE>54 	status = pthread_mutex_lock (&mutex);</CODE></p>
<p class=book><CODE>55 	if (status != 0)</CODE></p>
<p class=book><CODE>56 		err_abort (status, "Lock mutex");</CODE></p>
<p class=book><CODE>57 	printf ("Main has locked the mutex.\n");</CODE></p>
<p class=book><CODE>58 	status = pthread_mutex_unlock (&mutex);</CODE></p>
<p class=book><CODE>59 	if (status != 0)</CODE></p>
<p class=book><CODE>60 		err_abort (status, "Unlock mutex");</CODE></p>
<p class=book><CODE>61 	status = pthread_join (thread_id, NULL);</CODE></p>
<p class=book><CODE>62 	if (status != 0)</CODE></p>
<p class=book><CODE>63 		err_abort (status, "Join thread");</CODE></p>
<p class=book><CODE>64 	return 0;</CODE></p>
<p class=book><CODE>65 }</CODE></p>


<a name=t69></a><h3 class=book>
5.2 Attributes objects
</h3>
<blockquote class="epigraph">
<p class=book>The fifth ls ambition. It next will be right</p>
<p class=book>To describe each particular batch:</p>
<p class=book>Distinguishing those that have feathers, and bite, </p>
<p class=book>From those that have whiskers, and scratch.</p>
<blockquote class=book><i>— <i>Lewis Carroll, The Hunting of the Snark</i></i></blockquote>
</blockquote>

<p class=book>So far, when we created threads, or dynamically initialized mutexes and condition variables, we have usually used the pointer value NULL as the second argument. That argument is actually a pointer to an <i>attributes object.</i> The value NULL indicates that Pthreads should assume the default value for all attributes— just as it does when statically initializing a mutex or condition variable.</p>
<p class=book>An attributes object is an extended argument list provided when you initialize an object. It allows the main interfaces (for example, <CODE>pthread_create</CODE>) to be relatively simple, while allowing "expert" capability when you need it. Later POSIX standards will be able to add options without requiring source changes to existing code. In addition to standard attributes provided by Pthreads, an implementation can provide specialized options without creating nonstandard parameters.</p>
<p class=book>You can think of an attributes object as a private structure. You read or write the "members" of the structure by calling special functions, rather than by accessing public member names. For example, you read the <i>stacksize</i> attribute from a thread attributes object by calling <CODE>pthread_attr_getstacksize</CODE>, or write it by calling <CODE>pthread_attr_setstacksize</CODE>.</p>
<p class=book>In a simple implementation of Pthreads the type <CODE>pthread_attr_t</CODE> might be a typedef struct and the get and set functions might be macros to read or write members of the variable. Another implementation might allocate memory when you initialize an attributes object, and it may implement the get and set operations as real functions that perform validity checking.</p>
<p class=book>Threads, mutexes, and condition variables each have their own special attributes object type. Respectively, the types are pthread_attr_t, pthread_ mutexattr_t, and pthread_condattr_t.</p>


<a name=t70></a><h3 class=book>
5.2.1 Mutex attributes
</h3>
<p class=book><b>pthread_mutexattr_t attr;</b></p>
<p class=book><b>int pthread_mutexattr_init (pthread_mutexattr_t *attr);</b></p>
<p class=book><b>int pthread_mutexattr_destroy (</b></p>
<p class=book><b>pthread_mutexattr_t *attr);</b> </p>
<p class=book><b>#ifdef _POSIX_THREAD_PROCESS_SHARED</b></p>
<p class=book><b>int pthread_mutexattr_getpshared (</b></p>
<p class=book><b>pthread_mutexattr_t *attr, int *pshared); int pthread_mutexattr_setpshared (</b></p>
<p class=book><b>pthread_mutexattr_t *attr, int pshared);</b></p>
<p class=book><b>#endif</b></p>
<p class=book>Pthreads defines the following attributes for mutex creation: <i>pshared, protocol,</i> and <i>prioceiling.</i> No system is required to implement any of these attributes, however, so check the system documentation before using them.</p>
<p class=book>You initialize a mutex attributes object by calling <CODE>pthread_mutexattr_init</CODE>, specifying a pointer to a variable of type <CODE>pthread_mutexattr_t</CODE>, as in mutex_ attr.c, shown next. You use that attributes object by passing its address to <CODE>pthread_mutex_init</CODE> instead of the NULL value we've been using so far.</p>
<p class=book>If your system provides the _POSIX_THREAD_PROCESS_SHARED option, then it supports the <i>pshared</i> attribute, which you can set by calling the function <CODE>pthread_mutexattr_setpshared</CODE>. If you set the <i>pshared</i> attribute to the value PTHREAD_PROCESS_SHARED, you can use the mutex to synchronize threads within separate processes that have access to the memory where the mutex (<CODE>pthread_ mutex_t</CODE>) is initialized. The default value for this attribute is PTHREAD_PROCESS_PRIVATE.</p>
<p class=book>The mutex_attr.c program shows how to set a mutex attributes object to create a mutex using the <CODE>pshared</CODE> attribute. This example uses the default value. PTHREAD_PROCESS_PRIVATE, to avoid the additional complexity of creating shared memory and forking a process. The other mutex attributes, <i>protocol</i> and <i>prioceiling,</i> will be discussed later in Section 5.5.5.</p>
<p class=book>■ <b>mutex_attr.c</b></p>
<p class=book><CODE>1 #include &lt;pthread.h&gt;</CODE></p>
<p class=book><CODE>2 #include "errors.h"</CODE></p>
<p class=book><CODE>3</CODE></p>
<p class=book><CODE>4 pthread_mutex_t mutex;</CODE> </p>
<p class=book><CODE>5</CODE></p>
<p class=book><CODE>6 int main (int argc, char *argv[])</CODE></p>
<p class=book><CODE>7 {</CODE></p>
<p class=book><CODE>8 	pthread_mutexattr_t mutex_attr;</CODE></p>
<p class=book><CODE>9 	int status;</CODE> </p>
<p class=book><CODE>10</CODE></p>
<p class=book><CODE>11 	status = pthread_mutexattr_init (&mutex_attr);</CODE></p>
<p class=book><CODE>12 	if (status != 0)</CODE></p>
<p class=book><CODE>13 		err_abort (status, "Create attr");</CODE></p>
<p class=book><CODE>14 #ifdef _POSIX_THREAD_PROCESS_SHARED</CODE></p>
<p class=book><CODE>15 	status = pthread_mutexattr_setpshared (</CODE></p>
<p class=book><CODE>16 	&mutex_attr, PTHREAD_PROCESS_PRIVATE);</CODE></p>
<p class=book><CODE>17 	if (status != 0)</CODE></p>
<p class=book><CODE>18 		err_abort (status, "Set pshared");</CODE></p>
<p class=book><CODE>19 #endif</CODE></p>
<p class=book><CODE>20 	status = pthread_mutex_init (&mutex, &mutex_attr);</CODE></p>
<p class=book><CODE>21 	if (status != 0)</CODE></p>
<p class=book><CODE>22 		err_abort (status, "Init mutex");</CODE></p>
<p class=book><CODE>23 	return 0;</CODE></p>
<p class=book><CODE>24 }</CODE></p>


<a name=t71></a><h3 class=book>
<b>5.2.2 Condition variable attributes</b>
</h3>
<p class=book><b>pthread_condattr_t attr;</b></p>
<p class=book><b>int pthread_condattr_init (pthread_condattr_t *attr);</b></p>
<p class=book><b>int pthread_condattr_destroy (</b></p>
<p class=book><b>	pthread_condattr_t *attr);</b></p>
<p class=book><b>#ifdef _POSIX_THREAD_PROCESS_SHARED</b> </p>
<p class=book><b>int pthread_condattr_getpshared (</b></p>
<p class=book><b>	pthread_condattr_t *attr, int *pshared);</b></p>
<p class=book><b>int pthread_condattr_setpshared (</b></p>
<p class=book><b>	pthread_condattr_t *attr, int pshared);</b></p>
<p class=book><b>#endif</b></p>
<p class=book>Pthreads defines only one attribute for condition variable creation, pshared. No system is required to implement this attribute, so check the system documentation before using it. You initialize a condition variable attributes object using <CODE>pthread_condattr_init</CODE>, specifying a pointer to a variable of type <CODE>pthread_ condattr_t</CODE>, as in cond_attr.c, shown next. You use that attributes object by passing its address to <CODE>pthread_cond_init</CODE> instead of the NULL value we've been using so far.</p>
<p class=book>If your system defines _POSIX_THREAD_PROCESS_SHARED then it supports the <i>pshared</i> attribute. You set the <i>pshared</i> attribute by calling the function <CODE>pthread_ condattr_setpshared</CODE>. If you set the <i>pshared</i> attribute to the value <CODE>PTHREAD_ PROCESS_SHARED</CODE>, the condition variable can be used by threads in separate processes that have access to the memory where the condition variable (pthread_ cond_t) is initialized. The default value for this attribute is PTHREAD_PROCESS_PRIVATE.</p>
<p class=book>The cond_attr.c program shows how to set a condition variable attributes object to create a condition variable using the <i>pshared</i> attribute. This example uses the default value, PTHREAD_PROCESS_PRIVATE, to avoid the additional complexity of creating shared memory and forking a process.</p>
<p class=book>■ <b>cond_attr.c</b></p>
<p class=book><CODE>1 #include &lt;pthread.h&gt;</CODE></p>
<p class=book><CODE>2 #include "errors.h"</CODE> </p>
<p class=book><CODE>3</CODE></p>
<p class=book><CODE>4 pthread_cond_t cond;</CODE> </p>
<p class=book><CODE>5</CODE></p>
<p class=book><CODE>6 int main (int argc, char *argv[])</CODE></p>
<p class=book><CODE>7 {</CODE></p>
<p class=book><CODE>8 	pthread_condattr_t cond_attr;</CODE></p>
<p class=book><CODE>9 	int status;</CODE> </p>
<p class=book><CODE>10</CODE></p>
<p class=book><CODE>11 	status = pthread_condattr_init (&cond_attr);</CODE></p>
<p class=book><CODE>12 	if (status != 0)</CODE></p>
<p class=book><CODE>13 		err_abort (status, "Create attr");</CODE></p>
<p class=book><CODE>14 #ifdef _POSIX_THREAD_PROCESS_SHARED</CODE></p>
<p class=book><CODE>15 	status = pthread_condattr_setpshared (</CODE></p>
<p class=book><CODE>16 		&cond_attr, PTHREAD_PROCESS_PRIVATE);</CODE></p>
<p class=book><CODE>17 	if (status != 0)</CODE></p>
<p class=book><CODE>18 		err_abort (status, "Set pshared");</CODE></p>
<p class=book><CODE>19 #endif</CODE></p>
<p class=book><CODE>20 	status = pthread_cond_init (&cond, &cond_attr);</CODE></p>
<p class=book><CODE>21 	if (status != 0)</CODE></p>
<p class=book><CODE>22 		err_abort (status, "Init cond");</CODE></p>
<p class=book><CODE>23 return 0;</CODE></p>
<p class=book><CODE>24 }</CODE></p>
<p class=book>To make use of a PTHREAD_PROCESS_SHARED condition variable, you must also use a PTHREAD_PROCESS_SHARED mutex. That's because two threads that synchronize using a condition variable must also use the same mutex. Waiting for a condition variable automatically unlocks, and then locks, the associated mutex. So if the mutex isn't also created with PTHREAD_PROCESS_SHARED, the synchronization won't work.</p>


<a name=t72></a><h3 class=book>
5.2.3 Thread attributes
</h3>
<p class=book><b>pthread_attr_t attr;</b></p>
<p class=book><b>int pthread_attr_init (pthread_attr_t *attr);</b></p>
<p class=book><b>int pthread_attr_destroy (pthread_attr_t *attr); int pthread_attr_getdetachstate (pthread_attr_t *attr, int *detachstate);</b></p>
<p class=book><b>int pthread_attr_setdetachstate (pthread_attr_t *attr, int detachstate);</b></p>
<p class=book><b>#ifdef _POSIX_THREAD_ATTR_STACKSIZE</b> </p>
<p class=book><b>int pthread_attr_getstacksize (pthread_attr_t *attr, size_t *stacksize);</b></p>
<p class=book><b>int pthread_attr_setstacksize (pthread_attr_t *attr, size_t stacksize);</b> </p>
<p class=book><b>#endif</b></p>
<p class=book><b>#ifdef _POSIX_THREAD_ATTR_STACKADDR</b> </p>
<p class=book><b>int pthread_attr_getstackaddr (pthread_attr_t *attr, void *stackaddr);</b></p>
<p class=book><b>int pthread_attr_setstackaddr (pthread_attr_t *attr, void **stackaddr);</b></p>
<p class=book><b>#endif</b></p>
<p class=book>POSIX defines the following attributes for thread creation: <i>detachstate, stack-size, stackaddr, scope, inheritsched, schedpolicy,</i> and <i>schedparam.</i> Some systems won't support all of these attributes, so you need to check the system documentation before using them. You initialize a thread attributes object using <CODE>pthread_ attr_init</CODE>, specifying a pointer to a variable of type <CODE>pthread_attr_t</CODE>, as in the program thread_attr.c, shown later. You use the attributes object you've created by passing its address as the second argument to <CODE>pthread_create</CODE> instead of the NULL value we've been using so far.</p>
<p class=book>All Pthreads systems support the <i>detachstate</i> attribute. The value of this attribute can be either PTHREAD_CREATE_JOINABLE or PTHREAD_CREATE_DETACHED. By default, threads are created <i>joinable,</i> which means that the thread identification created by <CODE>pthread_create</CODE> can be used to join with the thread and retrieve its return value, or to cancel it. If you set the <i>detachstate</i> attribute to PTHREAD_ CREATE_DETACHED, the identification of threads created using that attributes object can't be used. It also means that when the thread terminates, any resources it used can immediately be reclaimed by the system.</p>
<p class=book>When you create threads that you know you won't need to cancel, or join with, you should create them detached. Remember that, in many cases, even if you want to know when a thread terminates, or receive some return value from it, you may not need to use <CODE>pthread_join</CODE>. If you provide your own notification mechanism, for example, using a condition variable, you can still create your threads detached.</p>
<p class=book> Setting the size of a stack is not very portable.</p>
<p class=book>If your system defines the symbol _POSIX_THREAD_ATTR_STACKSIZE<b>,</b> then you can set the <i>stacksize</i> attribute to specify the minimum size for the stack of a thread created using the attributes object. Most systems will support this option, but you should use it with caution because stack size isn't portable. The amount of stack space you'll need depends on the calling standards and data formats used by each system.</p>
<p class=book>Pthreads defines the symbol PTHREAD_STACK_MIN as the minimum stack size required for a thread: If you really need to specify a stack size, you might be best off calculating your requirements in terms of the minimum required by the implementation. Or, you could base your requirements on the default <i>stacksize</i> attribute selected by the implementation — for example, twice the default, or half the default. The program thread_attr.c shows how to read the default <i>stacksize</i> attribute value of an initialized attribute by calling <CODE>pthread_attr_getstacksize</CODE>.</p>
<p class=book> Setting the address of a stack is less portable!</p>
<p class=book>If your system defines the symbol _POSIX_THREAD_ATTR_STACKADDR, then you can set the <i>stackaddr</i> attribute to specify a region of memory to be used as a stack by any thread created using this attributes object. The stack must be at least as large as PTHREAD_STACK_MIN. You may need to specify an area of memory with an address that's aligned to some required granularity. On a machine where the stack grows downward from higher addresses to lower addresses, the address you specify should be the highest address in the stack, not the lowest. If the stack grows up, you need to specify the lowest address.</p>
<p class=book>You also need to be aware of whether the machine increments (or decrements) the stack before or after writing a new value — this determines whether the address you specify should be "inside" or "outside" the stack you've allocated. The system can't tell whether you allocated enough space, or specified the right address, so it has to trust you. If you get it wrong, undesirable things will occur.</p>
<p class=book>Use the <i>stackaddr</i> attribute only with great caution, and beware that it may well be the least portable aspect of Pthreads. While a reasonable value for the <i>stacksize</i> attribute will probably work on a wide range of machines, it is little more than a wild coincidence if any particular value of the <i>stackaddr</i> attribute works on any two machines. Also, you must remember that you can create only one thread with any value of the stackaddr attribute. If you create two concurrent threads with the same <i>stackaddr</i> attribute value, the threads will run on the same stack. (That would be bad.)</p>
<p class=book>The thread_attr.c program that follows shows some of these attributes in action, with proper conditionalization to avoid using the <i>stacksize</i> attribute if it is not supported by your system. If <i>stacksize</i> is supported (and it will be on most UNIX systems), the program will print the default and minimum stack size, and set <i>stacksize</i> to a value twice the minimum. The code also creates the thread <i>detached,</i> which means no thread can join with it to determine when it completes. Instead, main exits by calling <CODE>pthread_exit</CODE>, which means that the process will terminate when the last thread exits.</p>
<p class=book>This example does not include the priority scheduling attributes, which are discussed (and demonstrated) in Section 5.5.2. It also does not demonstrate use of the <i>stackaddr</i> attribute — as I said, there is no way to use <i>stackaddr</i> in any remotely portable way and, although I have mentioned it for completeness, I strongly discourage use of <i>stackaddr</i> in any program.</p>
<p class=book>■ <b>thread_attr.c</b></p>
<p class=book><CODE>1 #include &lt;limits.h&gt;</CODE></p>
<p class=book><CODE>2 #include &lt;pthread.h&gt;</CODE></p>
<p class=book><CODE>3 #include "errors.h"</CODE></p>
<p class=book><CODE>4</CODE></p>
<p class=book><CODE>5 /*</CODE></p>
<p class=book><CODE>6 * Thread start routine that reports it ran, and then exits.</CODE></p>
<p class=book><CODE>7 */</CODE></p>
<p class=book><CODE>8 void *thread_routine (void *arg)</CODE></p>
<p class=book><CODE>9 {</CODE></p>
<p class=book><CODE>10 	printf ("The thread is here\n");</CODE></p>
<p class=book><CODE>11 	return NULL;</CODE></p>
<p class=book><CODE>12 }</CODE> </p>
<p class=book><CODE>13</CODE></p>
<p class=book><CODE>14 int main (int argc, char *argv[])</CODE></p>
<p class=book><CODE>15 {</CODE></p>
<p class=book><CODE>16 	pthread_t thread_id;</CODE></p>
<p class=book><CODE>17 	pthread_attr_t thread_attr;</CODE></p>
<p class=book><CODE>18 	struct sched_param thread_param;</CODE></p>
<p class=book><CODE>19 	size_t stack_size;</CODE></p>
<p class=book><CODE>20 	int status;</CODE> </p>
<p class=book><CODE>21</CODE></p>
<p class=book><CODE>22 	status = pthread_attr_init (&thread_attr);</CODE></p>
<p class=book><CODE>23 	if (status != 0)</CODE></p>
<p class=book><CODE>24 		err_abort (status, "Create attr");</CODE> </p>
<p class=book><CODE>25</CODE></p>
<p class=book><CODE>26 /*</CODE></p>
<p class=book><CODE>27 * Create a detached thread.</CODE></p>
<p class=book><CODE>28 */</CODE></p>
<p class=book><CODE>29 	status = pthread_attr_setdetachstate (</CODE></p>
<p class=book><CODE>30 			&thread_attr, PTHREAD_CREATE_DETACHED);</CODE></p>
<p class=book><CODE>31 	if (status != 0)</CODE></p>
<p class=book><CODE>32 		err_abort (status, "Set detach");</CODE></p>
<p class=book><CODE>33 #ifdef _POSIX_THREAD_ATTR_STACKSIZE</CODE></p>
<p class=book><CODE>34 /*</CODE></p>
<p class=book><CODE>35 * If supported, determine the default stack size and report</CODE></p>
<p class=book><CODE>36 * it, and then select a stack size for the new thread.</CODE></p>
<p class=book><CODE>37 *</CODE></p>
<p class=book><CODE>38 * Note that the standard does not specify the default stack</CODE></p>
<p class=book><CODE>39 * size, and the default value in an attributes object need</CODE></p>
<p class=book><CODE>40 * not be the size that will actually be used. Solaris 2.5</CODE></p>
<p class=book><CODE>41 * uses a value of 0 to indicate the default.</CODE></p>
<p class=book><CODE>42 */</CODE></p>
<p class=book><CODE>43 	status = pthread_attr_getstacksize (&thread_attr, &stack_size);</CODE></p>
<p class=book><CODE>44 	if (status != 0)</CODE></p>
<p class=book><CODE>45 		err_abort (status, "Get stack size");</CODE></p>
<p class=book><CODE>46 	printf ("Default stack size is %u; minimum is %u\n",</CODE></p>
<p class=book><CODE>47 		stack_size, PTHREAD_STACK_MIN);</CODE></p>
<p class=book><CODE>48 	status = pthread_attr_setstacksize (</CODE></p>
<p class=book><CODE>49 		&thread_attr, PTHREAD_STACK_MIN*2);</CODE></p>
<p class=book><CODE>50 	if (status != 0)</CODE></p>
<p class=book><CODE>51 		err_abort (status, "Set stack size");</CODE></p>
<p class=book><CODE>52 #endif</CODE></p>
<p class=book><CODE>53 	status = pthread_create (</CODE></p>
<p class=book><CODE>54 		&thread_id, &thread_attr, thread_routine, NULL);</CODE></p>
<p class=book><CODE>55 	if (status != 0)</CODE></p>
<p class=book><CODE>56 		err_abort (status, "Create thread");</CODE></p>
<p class=book><CODE>57 	printf ("Main exiting\n");</CODE></p>
<p class=book><CODE>58 	pthread_exit (NULL);</CODE></p>
<p class=book><CODE>59 return 0;</CODE></p>
<p class=book><CODE>60 }</CODE></p>



<a name=t73></a><h3 class=book>
5.3 Cancellation
</h3>
<blockquote class="epigraph">
<p class=book>"Now, I give you fair warning,"</p>
<p class=book>shouted the Queen, stamping on the ground as she spoke;</p>
<p class=book>"either you or your head must be off,</p>
<p class=book>and that in about halfno time! Take your choice!"</p>
<p class=book> The Duchess took her choice, and was gone in a moment.</p>
<blockquote class=book><i>— <i>Lewis Carroll,Alice's Adventures in Wonderland</i></i></blockquote>
</blockquote>

<p class=book><b>int pthread_cancel (pthread_t thread);</b></p>
<p class=book><b>int pthread_setcancelstate (int state, int *oldstate);</b></p>
<p class=book><b>int pthread_setcanceltype (int type, int *oldtype);</b></p>
<p class=book><b>void pthread_testcancel (void);</b></p>
<p class=book><b>void pthread_cleanup_push (</b></p>
<p class=book><b>	void (*routine)(void *), void *arg);</b></p>
<p class=book><b>void pthread_cleanup_pop (int execute);</b></p>
<p class=book>Most of the time each thread runs independently, finishes a specific job, and exits on its own. But sometimes a thread is created to do something that doesn't necessarily need to be finished. The user might press a CANCEL button to stop a long search operation. Or the thread might be part of a redundant algorithm and is no longer useful because some other thread succeeded. What do you do when you just want a thread to go away? That's what the Pthreads cancellation interfaces are for.</p>
<p class=book>Cancelling a thread is a lot like telling a human to stop something they're doing. Say that one of the bailing programmers has become maniacally obsessed with reaching land, and refuses to stop rowing until reaching safety (Figure 5.1). When the boat finally runs up onto the beach, he's become so fixated that he fails to realize he's done. The other programmers must roughly shake him, and forcibly remove the oars from his blistered hands to stop him — but clearly he must be stopped. That's cancellation. Sort of. I can think of other analogies for cancellation within the bailing programmer story, but I choose to ignore them. Perhaps you can, too.</p>
<p class=book>Cancellation allows you to tell a thread to shut itself down. You don't need it often, but it can sometimes be extremely useful. Cancellation isn't an arbitrary external termination. It is more like a polite (though not necessarily "friendly") request. You're most likely to want to cancel a thread when you've found that something you set it off to accomplish is no longer necessary. You should never use cancellation unless you really want the target thread to go away. It is a termination mechanism, not a communication channel. So, why would you want to do that to a thread that you presumably created for some reason?</p>
<img border=0 style='spacing 9px;' src="img_14.png">
<p class=book><b>FIGURE 5.1</b> <i>Thread cancellation analogy</i></p>
<p class=book>An application might use threads to perform long-running operations, perhaps in the background, while the user continues working. Such operations might include saving a large document, preparing to print a document, or sorting a large list. Most such interfaces probably will need to have some way for the user to cancel an operation, whether it is pressing the ESC key or Ctrl-C, or clicking a stop sign icon on the screen. The thread receiving the user interface cancel request would then determine that one or more background operations were in progress, and use pthread_cancel to cancel the appropriate threads.</p>
<p class=book>Often, threads are deployed to "explore" a data set in parallel for some heuristic solution. For example, solving an equation for a local minimum or maximum. Once you've gotten one answer that's good enough, the remaining threads may no longer be needed. If so, you can cancel them to avoid wasting processor time and get on to other work.</p>
<p class=book>Pthreads allows each thread to control its own termination. It can restore program invariants and unlock mutexes. It can even defer cancellation while it completes some important operation. For example, when two write operations must <i>both</i> complete if either completes, a cancellation between the two is not acceptable.</p>
<TABLE>
<TR>
<TD align = "left" ><b>Mode</b></TD>
<TD align = "left" ><b>State</b></TD>
<TD align = "left" ><b>Type</b></TD>
<TD align = "left" ><b>Meaning</b></TD>
</TR>
<TR>
<TD align = "left" >Off</TD>
<TD align = "left" >disabled</TD>
<TD align = "left" >may be either</TD>
<TD align = "left" >Cancellation remains pending until enabled.</TD>
</TR>
<TR>
<TD align = "left" >Deferred</TD>
<TD align = "left" >enabled</TD>
<TD align = "left" >deferred</TD>
<TD align = "left" >Cancellation occurs at next <i>cancellation point.</i></TD>
</TR>
<TR>
<TD align = "left" >Asynchronous</TD>
<TD align = "left" >enabled</TD>
<TD align = "left" >asynchronous _</TD>
<TD align = "left" >Cancellation may be processed at any time.</TD>
</TR>
</TABLE>
<p class=book><i>TABLE 5.1 Cancellation states</i></p>
<p class=book>Pthreads supports three cancellation modes, described in Table 5.1, which are encoded as two binary values called "cancellation state" and "cancellation type." Each essentially can be on or off. (While that technically gives four modes, one of them is redundant.) As shown in the table, cancellation state is said to be <i>enabled</i> or <i>disabled,</i> and cancellation type is said to be <i>deferred</i> or <i>asynchronous.</i></p>
<p class=book>By default, cancellation is <i>deferred,</i> and can occur only at specific points in the program that check whether the thread has been requested to terminate, called <i>cancellation points.</i> Most functions that can wait for an unbounded time should be deferred cancellation points. Deferred cancellation points include waiting on a condition variable, reading or writing a file, and other functions where the thread may be blocked for a substantial period of time. There is also a special function called <CODE>pthread_testcancel</CODE> that is nothing but a deferred cancellation point. It will return immediately if the thread hasn't been asked to terminate, which allows you to turn any of your functions into cancellation points.</p>
<p class=book>Some systems provide a function to <i>terminate</i> a thread immediately. Although that sounds useful, it is difficult to use such a function safely. In fact, it is nearly impossible in a normal modular programming environment. If a thread is terminated with a mutex locked, for example, the next thread trying to lock that mutex will be stuck waiting forever.</p>
<p class=book>It might seem that the thread system could automatically release the mutex; but most of the time that's no help. Threads lock mutexes because they're modifying shared data. No other thread can know what data has been modified or what the thread was trying to change, which makes it difficult to fix the data. Now the program is broken. When the mutex is left locked, you can usually tell that something's broken because one or more threads will hang waiting for the mutex.</p>
<p class=book>The only way to recover from terminating a thread with a locked mutex is for the application to be able to analyze all shared data and repair it to achieve a consistent and correct state. That is not impossible, and it is worth substantial effort when an application must be fail-safe. However, it is generally not practical for anything but an embedded system where the application designers control every bit of shared state in the process. You would have to rebuild not only your own program or library state, but also the state affected by any library functions that might be called by the thread (for example, the ANSI C library).</p>
<p class=book>To cancel a thread, you need the thread's identifier, the <CODE>pthread_t</CODE> value returned to the creator by <CODE>pthread_create</CODE> or returned to the thread itself by <CODE>pthread_self</CODE>. Cancelling a thread is asynchronous — that is, when the call to <CODE>pthread_cancel</CODE> returns, the thread has not necessarily been canceled, it may have only been notified that a cancel request is <i>pending</i> against it. If you need to know when the thread has actually terminated, you must join with it by calling <CODE>pthread_join</CODE> after cancelling it.</p>
<p class=book>If the thread had asynchronous cancelability type set, or when the thread next reaches a deferred cancellation point, the cancel request will be <i>delivered</i> by the system. When that happens, the system will set the thread's cancelability type to PTHREAD_CANCEL_DEFERRED and the Cancelability State to PTHREAD_CANCEL_DISABLE.</p>
<p class=book>That is, the thread can clean up and terminate without having to worry about being canceled again.</p>
<p class=book>When a function that is a cancellation point detects a pending cancel request, the function does not return to the caller. The active cleanup handlers will be called, ifthere are any, and the thread will terminate. There is no way to "handle" cancellation and continue execution — the thread must either defer cancellation entirely or terminate. This is analogous to C++ object destructors, rather than C++ exceptions — the object is allowed to clean up after itself, but it is not allowed to avoid destruction.</p>
<p class=book>The following program, called cancel.c, shows how to write a thread that responds "reasonably quickly" to deferred cancellation, by calling pthread_ testcancel within a loop.</p>
<p class=book><b>11-19</b> The thread function thread_routine loops indefinitely, until canceled, testing periodically for a pending cancellation request. It minimizes the overhead of calling pthread_testcancel by doing so only every 1000 iterations (line 17).</p>
<p class=book><b>27-35</b> On a Solaris system, set the thread concurrency level to 2, by calling thr_ setconcurrency. Without the call to thr_setconcurrency, this program will hang on Solaris because thread_routine is "compute bound" and will not block. The main program would never have another chance to run once thread_routine started, and could not call pthread_cancel.</p>
<p class=book><b>36-54</b> The main program creates a thread running thread_routine, sleeps for two seconds, and then cancels the thread. It joins with the thread, and checks the return value, which should be PTHREAD_CANCELED to indicate that it was canceled, rather than terminated normally.</p>
<p class=book>■ <b>cancel.c</b></p>
<p class=book><CODE>1 #include &lt;pthread.h&gt;</CODE></p>
<p class=book><CODE>2 #include "errors.h" 3</CODE></p>
<p class=book><CODE>4 static int counter;</CODE> </p>
<p class=book><CODE>5</CODE></p>
<p class=book><CODE>6 /*</CODE></p>
<p class=book><CODE>7 * Loop until canceled. The thread can be canceled only</CODE></p>
<p class=book><CODE>8 * when it calls pthread_testcancel, which it does each 1000</CODE></p>
<p class=book><CODE>9 * iterations. 10 */</CODE></p>
<p class=book><CODE>11 void *thread_routine (void *arg)</CODE></p>
<p class=book><CODE>12 {</CODE></p>
<p class=book><CODE>13 DPRINTF (("thread_routine starting\n"));</CODE></p>
<p class=book><CODE>14 for (counter = 0; ; counter++)</CODE></p>
<p class=book><CODE>15 if ((counter % 1000) == 0) {</CODE></p>
<p class=book><CODE>16 DPRINTF (("calling testcancel\n"));</CODE></p>
<p class=book><CODE>17 pthread_testcancel ();</CODE></p>
<p class=book><CODE>18 }</CODE></p>
<p class=book><CODE>19 }</CODE></p>
<p class=book><CODE>20</CODE></p>
<p class=book><CODE>21 int main (int argc, char *argv[])</CODE></p>
<p class=book><CODE>22 {</CODE></p>
<p class=book><CODE>23 pthread_t thread_id;</CODE></p>
<p class=book><CODE>24 void *result;</CODE></p>
<p class=book><CODE>25 int status;</CODE> </p>
<p class=book><CODE>26</CODE></p>
<p class=book><CODE>27 #ifdef sun</CODE></p>
<p class=book><CODE>28 /*</CODE></p>
<p class=book><CODE>29 * On Solaris 2.5, threads are not timesliced. To ensure</CODE></p>
<p class=book><CODE>30 * that our two threads can run concurrently, we need to</CODE></p>
<p class=book><CODE>31 * increase the concurrency level to 2.</CODE></p>
<p class=book><CODE>32 */</CODE></p>
<p class=book><CODE>33 DPRINTF (("Setting concurrency level to 2\n"));</CODE></p>
<p class=book><CODE>34 thr_setconcurrency (2);</CODE></p>
<p class=book><CODE>35 #endif</CODE></p>
<p class=book><CODE>36 status = pthread_create (</CODE></p>
<p class=book><CODE>37 &thread_id, NULL, thread_routine, NULL);</CODE></p>
<p class=book><CODE>38 if (status != 0)</CODE></p>
<p class=book><CODE>39 err_abort (status, "Create thread");</CODE></p>
<p class=book><CODE>40 sleep (2);</CODE></p>
<p class=book><CODE>41</CODE></p>
<p class=book><CODE>42 DPRINTF (("calling cancel\n"));</CODE></p>
<p class=book><CODE>43 status = pthread_cancel (thread_id);</CODE></p>
<p class=book><CODE>44 if (status != 0)</CODE></p>
<p class=book><CODE>45 err_abort (status, "Cancel thread");</CODE></p>
<p class=book><CODE>46</CODE></p>
<p class=book><CODE>47 DPRINTF (("calling join\n"));</CODE></p>
<p class=book><CODE>48 status = pthread_join (thread_id, &result);</CODE></p>
<p class=book><CODE>49 if (status != 0)</CODE></p>
<p class=book><CODE>50 err_abort (status, "Join thread");</CODE></p>
<p class=book><CODE>51 if (result == PTHREAD_CANCELED)</CODE></p>
<p class=book><CODE>52 printf ("Thread canceled at iteration %d\n", counter);</CODE></p>
<p class=book><CODE>53 else</CODE></p>
<p class=book><CODE>54 printf ("Thread was not canceled\n");</CODE></p>
<p class=book><CODE>55 return 0;</CODE></p>
<p class=book><CODE>56 }</CODE></p>
<p class=book>A thread can disable cancellation around sections of code that need to complete without interruption, by calling pthread_setcancelstate. For example, ifa database update operation takes two separate write calls, you wouldn't want to complete the first and have the second canceled. If you request that a thread be canceled while cancellation is disabled, the thread remembers that it was canceled but won't do anything about it until after cancellation is enabled again. Because enabling cancellation isn't a <i>cancellation point,</i> you also need to test for a pending cancel request if you want a cancel processed immediately.</p>
<p class=book>When a thread may be canceled while it holds private resources, such as a locked mutex or heap storage that won't ever be freed by any other thread, those resources need to be released when the thread is canceled. If the thread has a mutex locked, it may also need to "repair" shared data to restore program invariants. <i>Cleanup handlers</i> provide the mechanism to accomplish the cleanup, somewhat like process atexit handlers. After acquiring a resource, and before any cancellation points, declare a cleanup handler by calling pthread_cleanup_ push. Before releasing the resource, but after any cancellation points, remove the cleanup handler by calling pthread_cleanup_pop.</p>
<p class=book>If you don't have a thread's identifier, you can't cancel the thread. That means that, at least using portable POSIX functions, you can't write an "idle thread killer" that will arbitrarily terminate threads in the process. You can only cancel threads that you created, or threads for which the creator (or the thread itself) gave you an identifier. That generally means that cancellation is restricted to operating within a subsystem.</p>


<a name=t74></a><h3 class=book>
5.3.1 Deferred cancelability
</h3>
<p class=book>"Deferred cancelability" means that the thread's cancelability type has been set to PTHREAD_CANCEL_DEFERRED and the thread's cancelability enable has been set to PTHREAD_CANCEL_ENABLE. The thread will only respond to cancellation requests when it reaches one of a set of "cancellation points."</p>
<p class=book>The following functions are always cancellation points on any Pthreads system:</p>
<p class=book>pthread_cond_wait 	fsync</p>
<p class=book>pthread_cond_timedwait mq_receive pthread_join mq_send</p>
<p class=book>pthread_testcancel msync</p>
<p class=book>sigwait nanosleep</p>
<p class=book>aio_suspend open</p>
<p class=book>close pause</p>
<p class=book>creat read</p>
<p class=book>fcntl (F_SETLCKW) sem_wait</p>
<p class=book>The following list of functions may be cancellation points. You should write your code so that it will function correctly if any of these are cancellation points</p>
<p class=book>sigwaitinfo</p>
<p class=book>sigsuspend</p>
<p class=book>sigtimedwait</p>
<p class=book>sleep</p>
<p class=book>system</p>
<p class=book>tcdrain</p>
<p class=book>wait</p>
<p class=book>waitpid</p>
<p class=book>write</p>
<p class=book>and also so that it will not break if any of them are not. If you depend upon any particular behavior, you may limit the portability of your code. You'll have to look at the conformance documentation to find out which, if any, are cancellation points for the system you are using:</p>
<TABLE>
<TR>
<TD align = "left" >closedir</TD>
<TD align = "left" >getc_unlocked</TD>
<TD align = "left" >printf</TD>
</TR>
<TR>
<TD align = "left" >ctermid</TD>
<TD align = "left" >getchar</TD>
<TD align = "left" >putc</TD>
</TR>
<TR>
<TD align = "left" >fclose</TD>
<TD align = "left" >getchar_unlocked</TD>
<TD align = "left" >putc_unlocked</TD>
</TR>
<TR>
<TD align = "left" >fcntl (except F_SETLCKW)</TD>
<TD align = "left" >getcwd</TD>
<TD align = "left" >putchar</TD>
</TR>
<TR>
<TD align = "left" >fflush</TD>
<TD align = "left" >getgrgid</TD>
<TD align = "left" >putchar_unlocked</TD>
</TR>
<TR>
<TD align = "left" >fgetc</TD>
<TD align = "left" >getgrgid_r</TD>
<TD align = "left" >puts</TD>
</TR>
<TR>
<TD align = "left" >fgets</TD>
<TD align = "left" >getrtnam</TD>
<TD align = "left" >readdir</TD>
</TR>
<TR>
<TD align = "left" >fopen</TD>
<TD align = "left" >getgrnam_r</TD>
<TD align = "left" >remove</TD>
</TR>
<TR>
<TD align = "left" >fprintf</TD>
<TD align = "left" >getlogin</TD>
<TD align = "left" >rename</TD>
</TR>
<TR>
<TD align = "left" >fputc</TD>
<TD align = "left" >getlogin_r</TD>
<TD align = "left" >rewind</TD>
</TR>
<TR>
<TD align = "left" >fputs</TD>
<TD align = "left" >getpwnam</TD>
<TD align = "left" >rewinddir</TD>
</TR>
<TR>
<TD align = "left" >fread</TD>
<TD align = "left" >getpwnam_r</TD>
<TD align = "left" >scanf</TD>
</TR>
<TR>
<TD align = "left" >freopen</TD>
<TD align = "left" >getpwuid</TD>
<TD align = "left" >tmpfile</TD>
</TR>
<TR>
<TD align = "left" >fscanf</TD>
<TD align = "left" >getpwuid_r</TD>
<TD align = "left" >tmpname</TD>
</TR>
<TR>
<TD align = "left" >fseek</TD>
<TD align = "left" >gets</TD>
<TD align = "left" >ttyname</TD>
</TR>
<TR>
<TD align = "left" >ftell</TD>
<TD align = "left" >lseek</TD>
<TD align = "left" >ttyname_r</TD>
</TR>
<TR>
<TD align = "left" >fwrite</TD>
<TD align = "left" >opendir</TD>
<TD align = "left" >ungetc</TD>
</TR>
<TR>
<TD align = "left" >getc</TD>
<TD align = "left" >perror</TD>
<TD></TD>
</TR>
</TABLE>
<p class=book>Pthreads specifies that any ANSI C or POSIX function not specified in one of the two lists cannot be a cancellation point. However, your system probably has many additional cancellation points. That's because few UNIX systems are "POSIX." That is, they support other programming interfaces as well — such as BSD 4.3, System V Release 4, UNLX95, and so forth. POSIX doesn't recognize the existence of functions such as select or poll, and therefore it can't say whether or not they are cancellation points. Yet clearly both are functions that may block for an arbitrary period of time, and programmers using them with cancellation would reasonably expect them to behave as cancellation points. X/Open is currently addressing this problem for UNLX98 <i>(X/Open System Interfaces, Issue 5).</i> by extending the Pthreads list of cancellation points.</p>
<p class=book>Most cancellation points involve I/O operations that may block the thread for an "unbounded" time. They're cancelable so that the waits can be interrupted. When a thread reaches a cancellation point the system determines whether a cancel is <i>pending</i> for the current ("target") thread. A cancel will be pending if another thread has called pthread_cancel for the target thread since the last time the target thread returned from a cancellation point. If a cancel is pending, the system will immediately begin calling cleanup functions, and then the thread will terminate.</p>
<p class=book>If no cancel is currently pending, the function will proceed. If another thread requests that the thread be canceled while the thread is waiting for something (such as I/O) then the wait will be interrupted and the thread will begin its cancellation cleanup.</p>
<p class=book>If you need to ensure that cancellation can't occur at a particular cancellation point, or during some sequence of cancellation points, you can temporarily disable cancellation in that region of code. The following program, called cancel_ disable.c, is a variant of cancel.c. The "target" thread periodically calls sleep, and does not want the call to be cancelable.</p>
<p class=book><b>23-32</b> After each cycle of 755 iterations, thread_routine will call sleep to wait a second. (The value 755 is just an arbitrary number that popped into my head. Do arbitrary numbers ever pop into your head?) Prior to sleeping, thread_routine disables cancellation by setting the cancelability state to PTHREAD_CANCEL_ DISABLE. After sleep returns, it restores the saved cancelability state by calling <CODE>pthread_setcancelstate</CODE> again.</p>
<p class=book><b>33-35</b> Just as in cancel.c, test for a pending cancel every 1000 iterations.</p>
<p class=book>■ <b>cancel_disable.c</b></p>
<p class=book><CODE>1 #include &lt;pthread.h&gt;</CODE></p>
<p class=book><CODE>2 #include "errors.h"</CODE></p>
<p class=book><CODE>3</CODE></p>
<p class=book><CODE>4 static int counter;</CODE></p>
<p class=book><CODE>5</CODE></p>
<p class=book><CODE>6 /*</CODE></p>
<p class=book><CODE>7 * Thread start routine.</CODE></p>
<p class=book><CODE>8 */</CODE></p>
<p class=book><CODE>9 void *thread_routine (void *arg)</CODE></p>
<p class=book><CODE>10 {</CODE></p>
<p class=book><CODE>11 int state;</CODE></p>
<p class=book><CODE>12 int status;</CODE> </p>
<p class=book><CODE>13</CODE></p>
<p class=book><CODE>14 for (counter = 0; ; counter++) {</CODE> </p>
<p class=book><CODE>15</CODE></p>
<p class=book><CODE>16 /*</CODE></p>
<p class=book><CODE>17 * Each 755 iterations, disable cancellation and sleep</CODE></p>
<p class=book><CODE>18 * for one second.</CODE></p>
<p class=book><CODE>19 *</CODE></p>
<p class=book><CODE>20 * Each 1000 iterations, test for a pending cancel by</CODE></p>
<p class=book><CODE>21 * calling pthread_testcancel().</CODE></p>
<p class=book><CODE>22 */</CODE></p>
<p class=book><CODE>23 if ((counter % 755) == 0) {</CODE></p>
<p class=book><CODE>24 status = pthread_setcancelstate (</CODE></p>
<p class=book><CODE>25 PTHREAD_CANCEL_DISABLE, &state);</CODE></p>
<p class=book><CODE>26 if (status != 0)</CODE></p>
<p class=book><CODE>27 err_abort (status, "Disable cancel");</CODE></p>
<p class=book><CODE>28 sleep (1);</CODE></p>
<p class=book><CODE>29 status = pthread_setcancelstate (</CODE></p>
<p class=book><CODE>30 state, &state);</CODE></p>
<p class=book><CODE>31 if (status != 0)</CODE></p>
<p class=book><CODE>32 err_abort (status, "Restore cancel");</CODE></p>
<p class=book><CODE>33 } else</CODE></p>
<p class=book><CODE>34 if ((counter % 1000) == 0)</CODE></p>
<p class=book><CODE>35 pthread_testcancel ();</CODE></p>
<p class=book><CODE>36 }</CODE></p>
<p class=book><CODE>37 }</CODE> </p>
<p class=book><CODE>38</CODE></p>
<p class=book><CODE>39 int main (int argc, char *argv[])</CODE></p>
<p class=book><CODE>40 {</CODE></p>
<p class=book><CODE>41 pthread_t thread_id;</CODE></p>
<p class=book><CODE>42 void *result;</CODE></p>
<p class=book><CODE>43 int status;</CODE> </p>
<p class=book><CODE>44</CODE></p>
<p class=book><CODE>45 status = pthread_create (</CODE></p>
<p class=book><CODE>46 &thread_id, NULL, thread_routine, NULL);</CODE></p>
<p class=book><CODE>47 if (status != 0)</CODE></p>
<p class=book><CODE>48 err_abort (status, "Create thread");</CODE></p>
<p class=book><CODE>49 sleep (2);</CODE></p>
<p class=book><CODE>50 status = pthread_cancel (thread_id);</CODE></p>
<p class=book><CODE>51 if (status != 0)</CODE></p>
<p class=book><CODE>52 err_abort (status, "Cancel thread");</CODE> </p>
<p class=book><CODE>53</CODE></p>
<p class=book><CODE>54 status = pthread_join (thread_id, &result);</CODE></p>
<p class=book><CODE>55 if (status != 0)</CODE></p>
<p class=book><CODE>56 err_abort (status, "Join thread");</CODE></p>
<p class=book><CODE>57 if (result == PTHREAD_CANCELED)</CODE></p>
<p class=book><CODE>58 printf ("Thread canceled at iteration %d\n", counter);</CODE></p>
<p class=book><CODE>59 else</CODE></p>
<p class=book><CODE>60 printf ("Thread was not canceled\n");</CODE></p>
<p class=book><CODE>61 return 0;</CODE></p>
<p class=book><CODE>62 }</CODE></p>


<a name=t75></a><h3 class=book>
<b>5.3.2 Asynchronous cancelability</b>
</h3>
<p class=book>Asynchronous cancellation is useful because the "target thread" doesn't need to poll for cancellation requests by using cancellation points. That can be valuable for a thread that runs a tight compute-bound loop (for example, searching for a prime number factor) where the overhead of calling pthread_testcancel might be severe.</p>
<p class=book>Avoid asynchronous cancellation! It is difficult to use correctly and is rarely useful.</p>
<p class=book>The problem is that you're limited in what you can do with asynchronous cancellation enabled. You can't acquire any resources, for example, including locking a mutex. That's because the cleanup code would have no way to determine</p>
<p class=book>whether the mutex had been locked. Asynchronous cancellation can occur at any hardware instruction. On some computers it may even be possible to interrupt some instructions in the middle. That makes it really difficult to determine what the canceled thread was doing.</p>
<p class=book>For example, when you call malloc the system allocates some heap memory for you, stores a pointer to that memory somewhere (possibly in a hardware register), and then returns to your code, which probably moves the return value into some local storage for later use. There are lots of places that malloc might be interrupted by an asynchronous cancel, with varying effects. It might be interrupted before the memory was allocated. Or it might be interrupted after allocating storage but before it stored the address for return. Or it might even return to your code, but get interrupted before the return value could be copied to a local variable. In any of those cases the variable where your code expects to find a pointer to the allocated memory will be uninitialized. You can't tell whether the memory really was allocated yet. You can't free the memory, so that memory (if it was allocated to you) will remain allocated for the life of the program. That's a memory leak, which is not a desirable feature.</p>
<p class=book>Or when you call <CODE>pthread_mutex_lock</CODE>, the system might be interrupted within a function call either before or after locking the mutex. Again, there's no way for your program to find out, because the interrupt may have occurred between any two instructions, even within the <CODE>pthread_mutex_lock</CODE> function, which might leave the mutex unusable. If the mutex is locked, the application will likely end up hanging because it will never be <i>unlocked.</i></p>
<p class=book>Call no code with asynchronous cancellation enabled unless you wrote it to be async-cancel safe — and even then, think twice!</p>
<p class=book>You are not allowed to call any function that acquires resources while asynchronous cancellation is enabled. In fact, you should never call <i>any</i> function while asynchronous cancellation is enabled unless the function is documented as "async-cancel safe." The only functions required to be async safe by Pthreads are <CODE>pthread_cancel</CODE>, <CODE>pthread_setcancelstate</CODE>, and <CODE>pthread_setcanceltype</CODE>. (And there is no reason to call <CODE>pthread_cancel</CODE> with asynchronous cancelability enabled.) No other POSIX orANSI C functions need be async-cancel safe, and you should never call them with asynchronous cancelability enabled.</p>
<p class=book>Pthreads suggests that all library functions should document whether or not they are async-cancel safe. However if the description of a function does not specifically say it is async-cancel safe you should always assume that it is not. The consequences of asynchronous cancellation in a function that is not async-cancel safe can be severe. And worse, the effects are sensitive to timing — so a function that appears to be async-cancel safe during experimentation may in fact cause all sorts of problems later when it ends up being canceled in a slightly different place.</p>
<p class=book>The following program, cancel_async.c, shows the use of asynchronous cancellation in a compute-bound loop. Use of asynchronous cancellation makes this</p>
<p class=book>loop "more responsive" than the deferred cancellation loop in cancel.c. However, the program would become unreliable if any function calls were made within the loop, whereas the deferred cancellation version would continue to function correctly. In most cases, synchronous cancellation is preferable. </p>
<p class=book><b>24-28</b> To keep the thread running awhile with something more interesting than an empty loop, cancel_async.c uses a simple matrix multiply nested loop. The matrixa and matrixb arrays are initialized with, respectively, their major or minor array index.</p>
<p class=book><b>34-36</b> The cancellation type is changed to PTHREAD_CANCEL_ASYNCHRONOUS, allowing asynchronous cancellation within the matrix multiply loops.</p>
<p class=book><b>39-44</b> The thread repeats the matrix multiply until canceled, on each iteration replacing the first source array (matrixa) with the result of the previous multiplication (matrixc).</p>
<p class=book><b>66-74</b> Once again, on a Solaris system, set the thread concurrency level to 2, allowing the main thread and thread_routine to run concurrently on a uniprocessor. The program will hang without this step, since user mode threads are not timesliced on Solaris.</p>
<p class=book>■ <b>cancel_async.c</b></p>
<p class=book><CODE>1 #include &lt;pthread.h&gt;</CODE></p>
<p class=book><CODE>2 #include "errors.h" 3</CODE></p>
<p class=book><CODE>4 #define SIZE 10 /* array size */</CODE></p>
<p class=book><CODE>5</CODE></p>
<p class=book><CODE>6 static int matrixa[SIZE][SIZE];</CODE></p>
<p class=book><CODE>7 static int matrixb[SIZE][SIZE];</CODE></p>
<p class=book><CODE>8 static int matrixc[SIZE][SIZE]; 9</CODE></p>
<p class=book><CODE>10 /*</CODE></p>
<p class=book><CODE>11 * Loop until canceled. The thread can be canceled at any</CODE></p>
<p class=book><CODE>12 * point within the inner loop, where asynchronous cancellation</CODE></p>
<p class=book><CODE>13 * is enabled. The loop multiplies the two matrices matrixa</CODE></p>
<p class=book><CODE>14 * and matrixb.</CODE></p>
<p class=book><CODE>15 */</CODE></p>
<p class=book><CODE>16 void *thread_routine (void *arg)</CODE></p>
<p class=book><CODE>17 {</CODE></p>
<p class=book><CODE>18 int cancel_type, status;</CODE></p>
<p class=book><CODE>19 int i, j, k, value = 1;</CODE> </p>
<p class=book><CODE>20</CODE></p>
<p class=book><CODE>21 /*</CODE></p>
<p class=book><CODE>22 * Initialize the matrices to something arbitrary.</CODE></p>
<p class=book><CODE>23 */</CODE></p>
<p class=book><CODE>24 for (i = 0; i &lt; SIZE; i++)</CODE></p>
<p class=book><CODE>25 for (j = 0; j &lt; SIZE; j++) {</CODE></p>
<p class=book><CODE>26 matrixa[i][j] = i;</CODE></p>
<p class=book><CODE>27 matrixb[i][j] = j;</CODE></p>
<p class=book><CODE>28 }</CODE> </p>
<p class=book><CODE>29</CODE></p>
<p class=book><CODE>30 while (1) {</CODE></p>
<p class=book><CODE>31 /*</CODE></p>
<p class=book><CODE>32 * Compute the matrix product of matrixa and matrixb.</CODE></p>
<p class=book><CODE>33 */</CODE></p>
<p class=book><CODE>34 status = pthread_setcanceltype (</CODE></p>
<p class=book><CODE>35 PTHREAD_CANCEL_ASYNCHRONOUS,</CODE></p>
<p class=book><CODE>36 &cancel_type);</CODE></p>
<p class=book><CODE>37 if (status != 0)</CODE></p>
<p class=book><CODE>38 err_abort (status, "Set cancel type");</CODE></p>
<p class=book><CODE>39 for (i = 0; i &lt; SIZE; i++)</CODE></p>
<p class=book><CODE>40 for (j = 0; j &lt; SIZE; j++) {</CODE></p>
<p class=book><CODE>41 matrixc[i][j] = 0;</CODE></p>
<p class=book><CODE>42 for (k = 0; k &lt; SIZE; k++)</CODE></p>
<p class=book><CODE>43 matrixc[i][j] += matrixa[i][k] * matrixb[k][j];</CODE></p>
<p class=book><CODE>44 }</CODE></p>
<p class=book><CODE>45 status = pthread_setcanceltype (</CODE></p>
<p class=book><CODE>46 cancel_type,</CODE></p>
<p class=book><CODE>47 &cancel_type);</CODE></p>
<p class=book><CODE>48 if (status != 0)</CODE></p>
<p class=book><CODE>49 err_abort (status, "Set cancel type");</CODE></p>
<p class=book><CODE>50</CODE></p>
<p class=book><CODE>51 /*</CODE></p>
<p class=book><CODE>52 * Copy the result (matrixc) into matrixa to start again</CODE></p>
<p class=book><CODE>53 */</CODE></p>
<p class=book><CODE>54 for (i = 0; i &lt; SIZE; i++)</CODE></p>
<p class=book><CODE>55 for (j = 0; j &lt; SIZE; j++)</CODE></p>
<p class=book><CODE>56 matrixa[i][j] = matrixc[i][j];</CODE></p>
<p class=book><CODE>57 }</CODE></p>
<p class=book><CODE>58 }</CODE> </p>
<p class=book><CODE>59</CODE></p>
<p class=book><CODE>60 int main (int argc, char *argv[])</CODE></p>
<p class=book><CODE>61 {</CODE></p>
<p class=book><CODE>62 pthread_t thread_id;</CODE></p>
<p class=book><CODE>63 void *result;</CODE></p>
<p class=book><CODE>64 int status; 65</CODE></p>
<p class=book><CODE>66 #ifdef sun</CODE></p>
<p class=book><CODE>67 /*</CODE></p>
<p class=book><CODE>68 * On Solaris 2.5, threads are not timesliced. To ensure</CODE></p>
<p class=book><CODE>69 * that our two threads can run concurrently, we need to</CODE></p>
<p class=book><CODE>70 * increase the concurrency level to 2.</CODE></p>
<p class=book><CODE>71 */</CODE></p>
<p class=book><CODE>72 DPRINTF (("Setting concurrency level to 2\n"));</CODE></p>
<p class=book><CODE>73 thr_setconcurrency (2);</CODE></p>
<p class=book><CODE>74 #endif</CODE></p>
<p class=book><CODE>75 status = pthread_create (</CODE></p>
<p class=book><CODE>76 &thread_id, NULL, thread_routine, NULL);</CODE></p>
<p class=book><CODE>77 if (status != 0)</CODE></p>
<p class=book><CODE>78 err_abort (status, "Create thread");</CODE></p>
<p class=book><CODE>79 sleep (1);</CODE></p>
<p class=book><CODE>80 status = pthread_cancel (thread_id);</CODE></p>
<p class=book><CODE>81 if (status != 0)</CODE></p>
<p class=book><CODE>82 err_abort (status, "Cancel thread");</CODE></p>
<p class=book><CODE>83 status = pthread_join (thread_id, &result);</CODE></p>
<p class=book><CODE>84 if (status != 0)</CODE></p>
<p class=book><CODE>85 err_abort (status, "Join thread");</CODE></p>
<p class=book><CODE>86 if (result == PTHREAD_CANCELED)</CODE></p>
<p class=book><CODE>87 printf ("Thread canceled\n");</CODE></p>
<p class=book><CODE>88 else</CODE></p>
<p class=book><CODE>89 printf ("Thread was not canceled\n");</CODE></p>
<p class=book><CODE>90 return 0;</CODE></p>
<p class=book><CODE>91 }</CODE></p>
<p class=book>Warning: do not let "DCE threads'" habits carry over to Pthreads!</p>
<p class=book>I'll end this section with a warning. DCE threads, a critical component of the Open Software Foundation's Distributed Computing Environment, was designed to be independent of the underlying UNIX kernel. Systems with no thread support at all often emulated "thread synchronous" I/O in user mode, using nonblocking I/O mode, so that a thread attempting I/O on a busy file was blocked on a condition variable until a later select or poll showed that the I/O could complete. DCE listener threads might block indefinitely on a socket read, and it was important to be able to cancel that read.</p>
<p class=book>When DCE was ported to newer kernels that had thread support, but not Pthreads support, the user mode I/O wrappers were usually omitted, resulting in a thread blocked within a kernel that did not support deferred cancellation. Users discovered that, in many cases, these systems implemented asynchronous cancellation in such a way that, quite by coincidence, a kernel wait might be canceled "safely" if the thread switched to asynchronous cancellation immediately before the kernel call, and switched back to deferred cancellation immediately after. This observation was publicized in DCE documentation, but it is a very dangerous hack, even on systems where it seems to work. You should <i>never</i> try this on any Pthreads system! If your system conforms to POSIX 1003. 1c-1995 (or POSIX 1003.1, 1996 edition, or later), it supports deferred cancellation of, at minimum, kernel functions such as read and write. You do not need asynchronous cancellation, and using it can be extremely dangerous.</p>


<a name=t76></a><h3 class=book>
5.3.3 Cleaning up
</h3>
<p class=book>When you write any library code, design it to handle deferred cancellation gracefully. Disable cancellation where it is not appropriate,and always use cleanup handlers at cancellation points.</p>
<p class=book>If a section of code needs to restore some state when it is canceled, it must use cleanup handlers. When a thread is canceled while waiting for a condition variable, it will wake up with the mutex locked. Before the thread terminates it usually needs to restore invariants, and it always needs to release the mutex.</p>
<p class=book>Each thread may be considered to have a stack of active cleanup handlers. Cleanup handlers are added to the stack by calling pthread_cleanup_push, and the most recently added cleanup handler is removed by calling pthread_cleanup_ pop. When the thread is canceled or when it exits by calling pthread_exit, Pthreads calls each active cleanup handler in turn, beginning with the most recently added cleanup handler. When all active cleanup handlers have returned, the thread is terminated.</p>
<p class=book>Pthreads cleanup handlers are designed so that you can often use the cleanup handler even when the thread wasn't canceled. It is often useful to run the same cleanup function regardless of whether your code is canceled or completes normally. When pthread_cleanup_pop is called with a nonzero value, the cleanup handler is executed even ifthe thread was not canceled.</p>
<p class=book>You cannot push a cleanup handler in one function and pop it in another function. The pthread_cleanup_push and pthread_cleanup_pop operations may be defined as macros, such that pthread_cleanup_push contains the opening brace "{" of ablock, while pthread_cleanup_pop contains the matching closing brace "}" of the block. You must always keep this restriction in mind while using cleanup handlers, if you wish your code to be portable.</p>
<p class=book>The following program, cancel_cleanup.c, shows the use of a cleanup handler to release a mutex when a condition variable wait is canceled.</p>
<p class=book><b>10-17</b> The control structure (control) is used by all threads to maintain shared synchronization objects and invariants. Each thread increases the member counter by one when it starts, and decreases it at termination. The member busy is used as a dummy condition wait predicate — it is initialized to 1, and never cleared, which means that the condition wait loops will never terminate (in this example) until the threads are canceled.</p>
<p class=book><b>24-34</b> The function cleanup_handler is installed as the cancellation cleanup handler for each thread. It is called on normal termination as well as through cancellation, to decrease the count of active threads and unlock the mutex. </p>
<p class=book><b>47</b> The function thread_routine establishes cleanup_handler as the active cancellation cleanup handler.</p>
<p class=book><b>54-58</b> Wait until the control structure's busy member is set to 0, which, in this example, will never occur. The condition wait loop will exit only when the wait is canceled.</p>
<p class=book><b>60</b> Although the condition wait loop in this example will not exit, the function cleans up by removing the active cleanup handler. The nonzero argument to <CODE>pthread_cleanup_pop</CODE>, remember, means that the cleanup handler will be called even though cancellation did not occur.</p>
<p class=book>In some cases, you may omit "unreachable statements" like this <CODE>pthread_cleanup_pop</CODE> call. However, in this case, your code might not compile without it. The <CODE>pthread_cleanup_push</CODE> and <CODE>pthread_cleanup_pop</CODE> macros are special, and may expand to form, respectively, the beginning and ending of a block. Digital UNIX does this, for example, to implement cancellation on top of the common structured exception handling provided by the operating system.</p>
<p class=book>■ <b>cancel_cleanup.c</b></p>
<p class=book><CODE>1 #include &lt;pthread.h&gt;</CODE></p>
<p class=book><CODE>2 #include "errors.h"</CODE></p>
<p class=book><CODE>3</CODE></p>
<p class=book><CODE>4 #define THREADS 5</CODE></p>
<p class=book><CODE>5</CODE></p>
<p class=book><CODE>6 /*</CODE></p>
<p class=book><CODE>7 * Control structure shared by the test threads, containing</CODE></p>
<p class=book><CODE>8 * the synchronization and invariant data.</CODE></p>
<p class=book><CODE>9 */</CODE></p>
<p class=book><CODE>10 typedef struct control_tag {</CODE></p>
<p class=book><CODE>11 	int counter, busy;</CODE></p>
<p class=book><CODE>12 	pthread_mutex_t mutex;</CODE></p>
<p class=book><CODE>13 	pthread_cond_t cv;</CODE></p>
<p class=book><CODE>14 } control_t;</CODE> </p>
<p class=book><CODE>15</CODE></p>
<p class=book><CODE>16 control_t control =</CODE></p>
<p class=book><CODE>17 	{0, 1, PTHREAD_MUTEX_INITIALIZER, PTHREAD_COND_INITIALIZER};</CODE></p>
<p class=book><CODE>18</CODE></p>
<p class=book><CODE>19 /*</CODE></p>
<p class=book><CODE>20 * This routine is installed as the cancellation cleanup</CODE></p>
<p class=book><CODE>21 * handler around the cancelable condition wait. It will</CODE></p>
<p class=book><CODE>22 * be called by the system when the thread is canceled.</CODE></p>
<p class=book><CODE>23 */</CODE></p>
<p class=book><CODE>24 void cleanup_handler (void *arg)</CODE></p>
<p class=book><CODE>25 {</CODE></p>
<p class=book><CODE>26 	control_t *st = (control_t *)arg;</CODE></p>
<p class=book><CODE>27 	int status;</CODE> </p>
<p class=book><CODE>28</CODE></p>
<p class=book><CODE>29 	st-&gt;counter--;</CODE></p>
<p class=book><CODE>30 	printf ("cleanup_handler: counter == %d\n", st-&gt;counter);</CODE></p>
<p class=book><CODE>31 	status = pthread_mutex_unlock (&st-&gt;mutex);</CODE></p>
<p class=book><CODE>32 	if (status != 0)</CODE></p>
<p class=book><CODE>33 		err_abort (status, "Unlock in cleanup handler");</CODE></p>
<p class=book><CODE>34 }</CODE> </p>
<p class=book><CODE>35</CODE></p>
<p class=book><CODE>36 /*</CODE></p>
<p class=book><CODE>37 * Multiple threads are created running this routine (controlled</CODE></p>
<p class=book><CODE>38 * by the THREADS macro). They maintain a "counter" invariant,</CODE></p>
<p class=book><CODE>39 * which expresses the number of running threads. They specify a</CODE></p>
<p class=book><CODE>40 * nonzero value to pthread_cleanup_pop to run the same</CODE></p>
<p class=book><CODE>41 * "finalization" action when cancellation does not occur.</CODE></p>
<p class=book><CODE>42 */</CODE></p>
<p class=book><CODE>43 void *thread_routine (void *arg)</CODE></p>
<p class=book><CODE>44 {</CODE></p>
<p class=book><CODE>45 	int status;</CODE></p>
<p class=book><CODE>46</CODE></p>
<p class=book><CODE>47 	pthread_cleanup_push (cleanup_handler, (void*)&control);</CODE> </p>
<p class=book><CODE>48</CODE></p>
<p class=book><CODE>49 	status = pthread_mutex_lock (&control.mutex);</CODE></p>
<p class=book><CODE>50 	if (status != 0)</CODE></p>
<p class=book><CODE>51 		err_abort (status, "Mutex lock");</CODE></p>
<p class=book><CODE>52 	control.counter++;</CODE></p>
<p class=book><CODE>53</CODE></p>
<p class=book><CODE>54 	while (control.busy) {</CODE></p>
<p class=book><CODE>55 	status = pthread_cond_wait (&control.cv, &control.mutex);</CODE></p>
<p class=book><CODE>56 	if (status != 0)</CODE></p>
<p class=book><CODE>57 		err_abort (status, "Wait on condition");</CODE></p>
<p class=book><CODE>58 	}</CODE></p>
<p class=book><CODE>59</CODE></p>
<p class=book><CODE>60 	pthread_cleanup_pop (1);</CODE></p>
<p class=book><CODE>61 	return NULL;</CODE></p>
<p class=book><CODE>62 }</CODE> </p>
<p class=book><CODE>63</CODE></p>
<p class=book><CODE>64 int main (int argc, char *argv[])</CODE></p>
<p class=book><CODE>65 {</CODE></p>
<p class=book><CODE>66 	pthread_t thread_id[THREADS];</CODE></p>
<p class=book><CODE>67 	int count;</CODE></p>
<p class=book><CODE>68 	void *result;</CODE></p>
<p class=book><CODE>69 	int status;</CODE></p>
<p class=book><CODE>70</CODE></p>
<p class=book><CODE>71 for (count = 0; count &lt; THREADS; count++) {</CODE></p>
<p class=book><CODE>72 	status = pthread_create (</CODE></p>
<p class=book><CODE>73 		&thread_id[count], NULL, thread_routine, NULL);</CODE></p>
<p class=book><CODE>74 	if (status != 0)</CODE></p>
<p class=book><CODE>75 		err_abort (status, "Create thread");</CODE></p>
<p class=book><CODE>76 }</CODE></p>
<p class=book><CODE>77</CODE></p>
<p class=book><CODE>78 sleep (2);</CODE> </p>
<p class=book><CODE>79</CODE></p>
<p class=book><CODE>80 for (count = 0; count &lt; THREADS; count++) {</CODE></p>
<p class=book><CODE>81 	status = pthread_cancel (thread_id[count]);</CODE></p>
<p class=book><CODE>82 if (status != 0)</CODE></p>
<p class=book><CODE>83 	err_abort (status, "Cancel thread"); 84</CODE></p>
<p class=book><CODE>85 status = pthread_join (thread_id[count], &result);</CODE></p>
<p class=book><CODE>86 if (status != 0)</CODE></p>
<p class=book><CODE>87 	err_abort (status, "Join thread");</CODE></p>
<p class=book><CODE>88 if (result == PTHREAD_CANCELED)</CODE></p>
<p class=book><CODE>89 	printf ("thread %d canceled\n", count);</CODE></p>
<p class=book><CODE>90 else</CODE></p>
<p class=book><CODE>91 	printf ("thread %d was not canceled\n", count);</CODE></p>
<p class=book><CODE>92 }</CODE></p>
<p class=book><CODE>93 return 0;</CODE></p>
<p class=book>If one of your threads creates a set of threads to "subcontract" some function, say, a parallel arithmetic operation, and the "contractor" is canceled while the function is in progress, you probably won't want to leave the subcontractor threads running. Instead, you could "pass on" the cancellation to each subcontrator thread, letting them handle their own termination independently.</p>
<p class=book>If you had originally intended to join with the subcontractors, remember that they will continue to consume some resources until they have been joined or detached. When the contractor thread cancels them, you should not delay cancellation by joining with the subcontractors. Instead, you can cancel each thread and immediately detach it using pthread_detach. The subcontractor resources can then be recycled immediately as they finish, while the contractor can wrap things up independently.</p>
<p class=book>The following program, cancel_subcontract.c, shows one way to propagate cancellation to subcontractors. </p>
<p class=book><b>9-12</b> The <CODE>team_t</CODE> structure defines the state of the team of subcontractor threads. The <CODE>join_i</CODE> member records the index of the last subcontractor with which the contractor had joined, so on cancellation from within pthread_join, it can cancel the threads it had not yet joined. The workers member is an array recording the thread identifiers of the subcontractor threads. </p>
<p class=book><b>18-25</b> The subcontractor threads are started running the worker_routine function. This function loops until canceled, calling pthread_testcancel every 1000 iterations.</p>
<p class=book><b>31-46</b> The cleanup function is established as the active cleanup handler within the contractor thread. When the contractor is canceled, cleanup iterates through the remaining (unjoined) subcontractors, cancelling and detaching each. Note that it does not join the subcontractors — in general, it is not a good idea to wait in a cleanup handler. The thread, after all, is expected to clean up and terminate, not to wait around for something to happen. But if your cleanup handler really needs to wait for something, don't be afraid, it will workjust fine.</p>
<p class=book><b>53-76</b> The contractor thread is started running thread_routine. This function creates a set of subcontractors, then joins with each subcontractor. As it joins each thread, it records the current index within the workers array in the team_t member join_i. The cleanup handler is established with a pointer to the team structure so that it can determine the last offset and begin cancelling the remaining subcontractors.</p>
<p class=book><b>78-104</b> The main program creates the contractor thread, running thread_routine, and then sleeps for five seconds. When it wakes up, it cancels the contractor thread, and waits for it to terminate.</p>
<p class=book>■ <b>cancel_subcontract.c</b></p>
<p class=book><CODE>1 #include &lt;pthread.h&gt;</CODE></p>
<p class=book><CODE>2 #include "errors.h" 3</CODE></p>
<p class=book><CODE>4 #define THREADS 5</CODE> </p>
<p class=book><CODE>5</CODE></p>
<p class=book><CODE>6 /*</CODE></p>
<p class=book><CODE>7 * Structure that defines the threads in a "team."</CODE></p>
<p class=book><CODE>8 */</CODE></p>
<p class=book><CODE>9 typedef struct team_tag {</CODE></p>
<p class=book><CODE>10 	int join_i; /* join index */</CODE></p>
<p class=book><CODE>11 	pthread_t workers[THREADS]; /* thread identifiers */</CODE></p>
<p class=book><CODE>12 } team_t;</CODE></p>
<p class=book><CODE>13</CODE></p>
<p class=book><CODE>14 /*</CODE></p>
<p class=book><CODE>15 * Start routine for worker threads. They loop waiting for a</CODE></p>
<p class=book><CODE>16 * cancellation request.</CODE></p>
<p class=book><CODE>17 */</CODE></p>
<p class=book><CODE>18 void *worker_routine (void *arg)</CODE></p>
<p class=book><CODE>19 {</CODE></p>
<p class=book><CODE>20 	int counter;</CODE> </p>
<p class=book><CODE>21</CODE></p>
<p class=book><CODE>22 	for (counter = 0; ; counter++)</CODE></p>
<p class=book><CODE>23 		if ((counter % 1000) == 0)</CODE></p>
<p class=book><CODE>24 			pthread_testcancel ();</CODE></p>
<p class=book><CODE>25 	}</CODE> </p>
<p class=book><CODE>26</CODE></p>
<p class=book><CODE>27 /*</CODE></p>
<p class=book><CODE>28 * Cancellation cleanup handler for the contractor thread. It</CODE></p>
<p class=book><CODE>29 * will cancel and detach each worker in the team.</CODE></p>
<p class=book><CODE>30 */</CODE></p>
<p class=book><CODE>31 void cleanup (void *arg)</CODE></p>
<p class=book><CODE>32 {</CODE></p>
<p class=book><CODE>33 	team_t *team = (team_t *)arg;</CODE></p>
<p class=book><CODE>34 	int count, status;</CODE> </p>
<p class=book><CODE>35</CODE></p>
<p class=book><CODE>36 	for (count = team-&gt;join_i; count &lt; THREADS; count++) {</CODE></p>
<p class=book><CODE>37 		status = pthread_cancel (team-&gt;workers[count]);</CODE></p>
<p class=book><CODE>38 		if (status != 0)</CODE></p>
<p class=book><CODE>39 			err_abort (status, "Cancel worker");</CODE> </p>
<p class=book><CODE>40</CODE></p>
<p class=book><CODE>41 		status = pthread_detach(team-&gt;workers[count]);</CODE></p>
<p class=book><CODE>42 		if (status != 0)</CODE></p>
<p class=book><CODE>43 			err_abort (status, "Detach worker");</CODE></p>
<p class=book><CODE>44 		printf ("Cleanup: canceled %d\n", count);</CODE></p>
<p class=book><CODE>45 	}</CODE></p>
<p class=book><CODE>46 }</CODE> </p>
<p class=book><CODE>47</CODE></p>
<p class=book><CODE>48 /*</CODE></p>
<p class=book><CODE>49 * Thread start routine for the contractor. It creates a team of</CODE></p>
<p class=book><CODE>50 * worker threads, and then joins with them. When canceled, the</CODE></p>
<p class=book><CODE>51 * cleanup handler will cancel and detach the remaining threads.</CODE></p>
<p class=book><CODE>52 */</CODE></p>
<p class=book><CODE>53 void *thread_routine (void *arg)</CODE></p>
<p class=book><CODE>54 {</CODE></p>
<p class=book><CODE>53 	team_t team; /* team info */</CODE></p>
<p class=book><CODE>56 	int count;</CODE></p>
<p class=book><CODE>57 	void *result; /* Return status */</CODE></p>
<p class=book><CODE>58 	int status;</CODE> </p>
<p class=book><CODE>59</CODE></p>
<p class=book><CODE>60 	for (count = 0; count &lt; THREADS; count++) {</CODE></p>
<p class=book><CODE>61 		status = pthread_create (</CODE></p>
<p class=book><CODE>62 			&team.workers[count], NULL, worker_routine, NULL);</CODE></p>
<p class=book><CODE>63 		if (status != 0)</CODE></p>
<p class=book><CODE>64 			err_abort (status, "Create worker");</CODE></p>
<p class=book><CODE>55 	}</CODE></p>
<p class=book><CODE>66 	pthread_cleanup_push (cleanup, (void*)&team);</CODE></p>
<p class=book><CODE>67</CODE></p>
<p class=book><CODE>68 	for (team.join_i = 0; team.join_i &lt; THREADS; team.join_i++) {</CODE></p>
<p class=book><CODE>69 		status = pthread_join (team.workers[team.join_i], &result);</CODE></p>
<p class=book><CODE>70 		if (status != 0)</CODE></p>
<p class=book><CODE>71 			err_abort (status, "Join worker");</CODE></p>
<p class=book><CODE>72 	}</CODE></p>
<p class=book><CODE>73</CODE></p>
<p class=book><CODE>74 	pthread_cleanup_pop (0);</CODE></p>
<p class=book><CODE>75 	return NULL;</CODE></p>
<p class=book><CODE>76 }</CODE></p>
<p class=book><CODE>77</CODE></p>
<p class=book><CODE>78 int main (int argc, char *argv[])</CODE></p>
<p class=book><CODE>79 {</CODE></p>
<p class=book><CODE>80 	pthread_t thread_id;</CODE></p>
<p class=book><CODE>81 	int status;</CODE> </p>
<p class=book><CODE>82</CODE></p>
<p class=book><CODE>83 #ifdef sun</CODE></p>
<p class=book><CODE>84 /*</CODE></p>
<p class=book><CODE>85 * On Solaris 2.5, threads are not timesliced. To ensure</CODE></p>
<p class=book><CODE>86 * that our threads can run concurrently, we need to</CODE></p>
<p class=book><CODE>87 * increase the concurrency level to at least 2 plus THREADS</CODE></p>
<p class=book><CODE>88 * (the number of workers).</CODE></p>
<p class=book><CODE>89 */</CODE></p>
<p class=book><CODE>90 	DPRINTF (("Setting concurrency level to %d\n", THREADS+2));</CODE></p>
<p class=book><CODE>91 	thr_setconcurrency (THREADS+2);</CODE></p>
<p class=book><CODE>92 #endif</CODE></p>
<p class=book><CODE>93 	status = pthread_create (&thread_id, NULL, thread_routine, NULL);</CODE></p>
<p class=book><CODE>94 	if (status != 0)</CODE></p>
<p class=book><CODE>95 		err_abort (status, "Create team");</CODE></p>
<p class=book><CODE>96 	sleep (5);</CODE></p>
<p class=book><CODE>97 	printf ("Cancelling...\n");</CODE></p>
<p class=book><CODE>98 	status = pthread_cancel (thread_id);</CODE></p>
<p class=book><CODE>99 	if (status != 0)</CODE></p>
<p class=book><CODE>100 		err_abort (status, "Cancel team");</CODE></p>
<p class=book><CODE>101	status = pthread_join (thread_id, NULL);</CODE></p>
<p class=book><CODE>102	if (status != 0)</CODE></p>
<p class=book><CODE>103		err_abort (status, "Join team");</CODE></p>
<p class=book><CODE>104 }</CODE></p>



<a name=t77></a><h3 class=book>
5.4 Thread-specific data
</h3>
<blockquote class="epigraph">
<p class=book><b>No,</b> <i><b>I've made up my mind about it: if I'm Mabel, I'll stay down here. It'll be no use their putting their heads down and saying "Come up again, dear!" I shall only look up and say "Who am I, then? Tell me that first, and then, if I like being that person, I'll come up: if not, I'll stay down here till I'm somebody else."</b></i></p>
<blockquote class=book><i>— <i>Lewis Carroll,Alice's Adventures in Wonderland</i></i></blockquote>
</blockquote>

<p class=book>When a function in a single threaded program needs to create private data that persists across calls to that function, the data can be allocated statically in memory. The name's scope can be limited to the function or file that uses it (static) or it can be made global (extern).</p>
<p class=book>It is not quite that simple when you use threads. All threads within a process share the same address space, which means that any variable declared as static or extern, or in the process heap, may be read and written by all threads within the process. That has several important implications for code that wants to store "persistent" data between a series of function calls within a thread:</p>
<p class=book>• The value in a static or extern variable, or in the heap, will be the value last written by any thread. In some cases this may be what you want, for example, to maintain the seed of a pseudorandom number sequence. In other cases, it may not be what you want.</p>
<p class=book>• The only storage a thread has that's truly "private" are processor registers. Even stack addresses can be shared, although only if the "owner" deliberately exposes an address to another thread. In any event, neither registers nor "private" stack can replace uses of persistent static storage in non-threaded code.</p>
<p class=book>So when you need a private variable, you must first decide whether all threads share the same value, or whether each thread should have its own value. If they share, then you can use static or extern data, just as you could in a single threaded program; however, you must synchronize access to the shared data across multiple threads, usually by adding one or more mutexes.</p>
<p class=book>If each thread needs its own value for a private variable, then you must store all the values somewhere, and each thread must be able to locate the proper value. In some cases you might be able to use static data, for example, a table where you can search for a value unique to each thread, such as the thread's pthread_t. In many interesting cases you cannot predict how many threads might call the function—imagine you were implementing a thread-safe library that could be called by arbitrary code, in any number of threads.</p>
<p class=book>The most general solution is to malloc some heap in each thread and store the values there, but your code will need to be able to find the proper private data in any thread. You could create a linked list of all the private values, storing the creating thread's identifier (pthread_t) so it could be found again, but that will be slow if there are many threads. You need to search the list to find the proper value, and it would be difficult to recover the storage that was allocated by terminated threads — your function cannot know when a thread terminates.</p>
<p class=book><b>I</b> New interfaces should not rely on implicit persistent storage!</p>
<p class=book>When you are designing new interfaces, there's a better solution. You should require the caller to allocate the necessary persistent state, and tell you where it is. There are many advantages to this model, including, most importantly:</p>
<p class=book>• In many cases, you can avoid internal synchronization using this model, and, in rare cases where the caller wishes to share the persistent state between threads, the caller can supply the needed synchronization.</p>
<p class=book>• The caller can instead choose to allocate more than one state buffer for use within a single thread. The result is several independent sequences of calls to your function within the same thread, with no conflict.</p>
<p class=book>The problem is that you often need to support <i>implicit</i> persistent states. You may be making an existing interface thread-safe, and cannot add an argument to the functions, or require that the caller maintain a new data structure for your benefit. That's where thread-specific data comes in.</p>
<p class=book>Thread-specific data allows each thread to have a separate copy of a variable, as if each thread has an array of thread-specific data values, which is indexed by a common "key" value. Imagine that the bailing programmers are wearing their corporate ID badges, clipped to their shirt pockets (Figure 5.2). While the information is different for each programmer, you can find the information easily without already knowing which programmer you're examining.</p>
<p class=book>The program creates a <i>key</i> (sort of like posting a corporate regulation that employee identification badges always be displayed clipped to the left breast pocket of the employee's shirt or jacket) and each thread can then independently set or get its own value for that key (although the badge is always on the left pocket, each employee has a unique badge number, and, in most cases, a unique name). The <i>key</i> is the same for all threads, but each thread can associate its own independent <i>value</i> with that shared key. Each thread can change its private value for a key at any time, without affecting the key or any value other threads may have for the key.</p>
<p class=book><img border=0 style='spacing 9px;' src="img_15.png"></p>
<p class=book><b>FIGURE 5.2</b> <i>Thread-specific data analogy</i></p>


<a name=t78></a><h3 class=book>
5.4.1 Creating thread-specific data
</h3>
<p class=book><b>pthread_key_t key;</b></p>
<p class=book><b>int pthread_key_create (</b></p>
<p class=book><b>	pthread_key_t *key,</b> </p>
<p class=book><b>	void (*destructor)(void *));</b></p>
<p class=book><b>int pthread_key_delete (pthread_key_t key);</b></p>
<p class=book>A thread-specific data key is represented in your program by a variable of type <CODE>pthread_key_t</CODE>. Like most Pthreads types, pthread_key_t is <i>opaque</i> and you should never make any assumptions about the structure or content. The easiest way to create a thread-specific data key is to call pthread_key_create before any threads try to use the key, for example early in the program's main function.</p>
<p class=book>If you need to create a thread-specific data key later, you have to ensure that pthread_key_create is called only once for each pthread_key_t variable. That's because if you create a key twice, you are really creating two different keys. The second key will overwrite the first, which will be lost forever along with the values any threads might have set for the first key.</p>
<p class=book>When you can't add code to main, the easiest way to ensure that a thread-specific data key is created only once is to use <CODE>pthread_once</CODE>, the one-time initialization function, as shown in the following program, tsd_once.c.</p>
<p class=book><b>7-10</b> The <CODE>tsd_t</CODE> structure is used to contain per-thread data. Each thread allocates a private <CODE>tsd_t</CODE> structure, and stores a pointer to that structure as its value for the thread-specific data key <CODE>tsd_key</CODE>. The thread_id member holds the thread's identifier (<CODE>pthread_t</CODE>), and the string member holds the pointer to a "name" string for the thread. The variable <CODE>tsd_key</CODE> holds the thread-specific data key used to access the <CODE>tsd_t</CODE> structures.</p>
<p class=book><b>19-27</b> One-time initialization (<CODE>pthread_once</CODE>) is used to ensure that the key tsd_key is created before the first access.</p>
<p class=book><b>33-56</b> The threads begin in the thread start function thread_routine. The argument (arg) is a pointer to a character string naming the thread. Each thread calls pthread_once to ensure that the thread-specific data key has been created. The thread then allocates a tsd_t structure, initializes the thread_id member with the thread's identifier, and copies its argument to the string member.</p>
<p class=book>The thread gets the current thread-specific data value by calling pthread_ getspecific, and prints a message using the thread's name. It then sleeps for a few seconds and prints another message to demonstrate that the thread-specific data value remains the same, even though another thread has assigned a different tsd_t structure address to the same thread-specific data key.</p>
<p class=book>■ <b>tsd_once.c</b></p>
<p class=book><CODE>1 #include &lt;pthread.h&gt;</CODE></p>
<p class=book><CODE>2 #include "errors.h"</CODE></p>
<p class=book><CODE>3</CODE></p>
<p class=book><CODE>4 /*</CODE></p>
<p class=book><CODE>5 * Structure used as the value for thread-specific data key.</CODE></p>
<p class=book><CODE>6 */</CODE></p>
<p class=book><CODE>7 typedef struct tsd_tag {</CODE></p>
<p class=book><CODE>8 	pthread_t thread_id;</CODE></p>
<p class=book><CODE>9 	char *string;</CODE> </p>
<p class=book><CODE>10 } tsd_t;</CODE></p>
<p class=book><CODE>11</CODE></p>
<p class=book><CODE>12 pthread_key_t tsd_key; /* Thread-specific data key */</CODE></p>
<p class=book><CODE>13 pthread_once_t key_once = PTHREAD_ONCE_INIT; 14</CODE></p>
<p class=book><CODE>15 /*</CODE></p>
<p class=book><CODE>16 * One-time initialization routine used with the pthread_once</CODE></p>
<p class=book><CODE>17 * control block.</CODE></p>
<p class=book><CODE>18 */</CODE></p>
<p class=book><CODE>19 void once_routine (void)</CODE></p>
<p class=book><CODE>20 {</CODE></p>
<p class=book><CODE>21 	int status;</CODE></p>
<p class=book><CODE>22</CODE></p>
<p class=book><CODE>23 	printf ("initializing key\n");</CODE></p>
<p class=book><CODE>24 	status = pthread_key_create (&tsd_key, NULL);</CODE></p>
<p class=book><CODE>25 	if (status != 0)</CODE></p>
<p class=book><CODE>26 		err_abort (status, "Create key");</CODE></p>
<p class=book><CODE>27 }</CODE></p>
<p class=book><CODE>28</CODE></p>
<p class=book><CODE>29 /*</CODE></p>
<p class=book><CODE>30 * Thread start routine that uses pthread_once to dynamically</CODE></p>
<p class=book><CODE>31 * create a thread-specific data key.</CODE></p>
<p class=book><CODE>32 */</CODE></p>
<p class=book><CODE>33 void *thread_routine (void *arg)</CODE></p>
<p class=book><CODE>34 {</CODE></p>
<p class=book><CODE>35 	tsd_t *value;</CODE></p>
<p class=book><CODE>36 	int status;</CODE></p>
<p class=book><CODE>37</CODE></p>
<p class=book><CODE>38 	status = pthread_once (&key_once, once_routine);</CODE></p>
<p class=book><CODE>39 	if (status != 0)</CODE></p>
<p class=book><CODE>40 		err_abort (status, "Once init");</CODE></p>
<p class=book><CODE>41 	value = (tsd_t*)malloc (sizeof (tsd_t));</CODE></p>
<p class=book><CODE>42 	if (value == NULL)</CODE></p>
<p class=book><CODE>43 		errno_abort ("Allocate key value");</CODE></p>
<p class=book><CODE>44 	status = pthread_setspecific (tsd_key, value);</CODE></p>
<p class=book><CODE>45 	if (status != 0)</CODE></p>
<p class=book><CODE>46 		err_abort (status, "Set tsd");</CODE></p>
<p class=book><CODE>47 	printf ("%s set tsd value %p\n", arg, value);</CODE></p>
<p class=book><CODE>48 	value-&gt;thread_id = pthread_self ();</CODE></p>
<p class=book><CODE>49 	value-&gt;string = (char*)arg;</CODE></p>
<p class=book><CODE>50 	value = (tsd_t*)pthread_getspecific (tsd_key);</CODE></p>
<p class=book><CODE>51 	printf ("%s starting...\n", value-&gt;string);</CODE></p>
<p class=book><CODE>52 	sleep (2);</CODE></p>
<p class=book><CODE>53 	value = (tsd_t*)pthread_getspecific (tsd_key);</CODE></p>
<p class=book><CODE>54 	printf ("%s done...\n", value-&gt;string);</CODE></p>
<p class=book><CODE>55 	return NULL;</CODE></p>
<p class=book><CODE>56 }</CODE> </p>
<p class=book><CODE>57</CODE></p>
<p class=book><CODE>58 void main (int argc, char *argv[])</CODE></p>
<p class=book><CODE>59 {</CODE></p>
<p class=book><CODE>60 	pthread_t threadl, thread2;</CODE></p>
<p class=book><CODE>61 	int status;</CODE> </p>
<p class=book><CODE>62</CODE></p>
<p class=book><CODE>63 	status = pthread_create (</CODE></p>
<p class=book><CODE>64 		&thread1, NULL, thread_routine, "thread 1");</CODE></p>
<p class=book><CODE>65 	if (status != 0)</CODE></p>
<p class=book><CODE>66 		err_abort (status, "Create thread 1");</CODE></p>
<p class=book><CODE>67 	status = pthread_create (</CODE></p>
<p class=book><CODE>68 		&thread2, NULL, thread_routine, "thread 2");</CODE></p>
<p class=book><CODE>69 	if (status != 0)</CODE></p>
<p class=book><CODE>70 		err_abort (status, "Create thread 2");</CODE></p>
<p class=book><CODE>71 	pthread_exit (NULL);</CODE></p>
<p class=book><CODE>72 }</CODE></p>
<p class=book>Pthreads allows you to <i>destroy</i> a thread-specific data key when your program no longer needs it, by calling pthread_key_delete. The Pthreads standard guarantees only 128 thread-specific data keys at any one time, so it may be useful to destroy a key that you know you aren't using and won't need again. The actual number of keys supported by your Pthreads system is specified by the value of the symbol PTHREAD_KEYS_MAX defined in &lt;limits.h&gt;.</p>
<p class=book>When you destroy a thread-specific data key, it does not affect the current value of that key in any thread, not even in the calling thread. That means your code is completely responsible for freeing any memory that you have associated with the thread-specific data key, in all threads. Of course, any use of the deleted thread-specific data key (pthread_key_t) results in undefined behavior.</p>
<p class=book>Delete thread-specific data keys only when you are sure no thread has a value for that key!</p>
<p class=book>Or,.. don't destroy them at all.</p>
<p class=book>You should never destroy a key while some thread still has a value for that key. Some later call to pthread_key_create, for example, might reuse the pthread_key_t identifier that had been assigned to a deleted key. When an existing thread that had set a value for the old key requests the value of the new key, it will receive the old value. The program will likely react badly to receiving this incorrect data, so you should never delete a thread-specific data key until you are sure that no existing threads have a value for that key, for example, by maintaining a "reference count" for the key, as shown in the program tsd_destructor.c. in Section 5.4.3.</p>
<p class=book>Even better, don't destroy thread-specific data keys. There's rarely any need to do so, and if you try you will almost certainly run into difficulties. Few programs will require even the minimum Pthreads limit of 128 thread-specific data keys. Rarely will you use more than a few. In general, each component that uses thread-specific data will have a small number of keys each maintaining pointers to data structures that contain related data. It would take a lot of components to exhaust the available keys!</p>


<a name=t79></a><h3 class=book>
5.4.2 Using thread-specific data
</h3>
<p class=book><b>int pthread_setspecific (pthread_key_t key, const void *value);</b></p>
<p class=book><b>void *pthread_getspecific (pthread_key_t key);</b></p>
<p class=book>You can use the <CODE>pthread_getspecific</CODE> function to determine the thread's current value for a key, or <CODE>pthread_setspecific</CODE> to change the current value. Take a look at Section 7.3.1 for ideas on using thread-specific data to adapt old libraries that rely on static data to be thread-safe.</p>
<p class=book>A thread-specific data value of NULL means something special to Pthreads—do not set a thread-specific data value of NULL unless you really mean it.</p>
<p class=book>The initial value for any new key (in all threads) is NULL. Also, Pthreads sets the thread-specific data value for a key to NULL before calling that key's destructor (passing the previous value of the key) when a thread terminates<sup><a name=r4><a href="#n4" title="
That is, unfortunately, not what the standard says. This is one of the problems with formal standards — they say what they say, not what they were intended to say. Somehow, an error crept ln, and the sentence specifying that &quot;the implementation clears the thread-specific data value before calling the destructor&quot; was deleted. Nobody noticed, and the standard was approved with the error. So the standard says (by omission) that if you want to write a portable application using thread-speciflc data, that will not hang on thread termination, you must call pthread_setspecific within your destructor function to change the value to NULL. This would be silly, and any serious implementation of Pthreads will violate the standard in this respect. Of course, the standard will be fixed, probably by the 1003. ln amendment (assorted corrections to 1003. 1c-1995). but that will take a while.
">[4]</sup></A>. If your thread-specific data value is the address of heap storage, for example, and you want to free that storage in your destructor, you must use the argument passed to the destructor rather than calling pthread_getspecific.</p>
<p class=book>Pthreads will not call the destructor for a thread-specific data key if the terminating thread has a value of NULL for that key. NULL is special, meaning "this key has no value." If you ever use pthread_setspecific to set the value ofa thread-specific data key to NULL, you need to remember that you are not setting the value NULL, but rather stating that the key no longer has a value in the current thread.</p>
<p class=book>Destructor functions are called only when the thread terminates, not when the value of a thread-specific data key is changed.</p>
<p class=book>Another important thing to remember is that thread-specific data key destructor functions are not called when you replace an existing value for that key. That is, if you allocate a structure in heap and assign a pointer to that structure as the value of a thread-specific data key, and then later allocate a new structure and assign a pointer to that new structure to the same thread-speciflc data key, in the same thread, you are responsible for freeing the old structure. Pthreads will not free the old structure, nor will it call your destructor function with a pointer to the old structure.</p>


<a name=t80></a><h3 class=book>
5.4.3 Using destructor functions
</h3>
<p class=book>When a thread exits while it has a value defined for some thread-specific data key, you usually need to do something about it. If your key's value is a pointer to heap memory, you will need to free the memory to avoid a memory leak each time a thread terminates. Pthreads allows you to define a <i>destructor</i> function when you create a thread-specific data key. When a thread terminates with a non-NULL value for a thread-specific data key, the key's destructor (if any) is called with the current value of the key.</p>
<p class=book>Thread-specific data destructors are called in "unspecified order."</p>
<p class=book>Pthreads checks all thread-specific data keys in the process when a thread exits, and for each thread-specific data key with a value that's not NULL, it sets the value to NULL and then calls the key's destructor function. Going back to our analogy, someone might collect the identity badges of all programmers by removing whatever is hanging from each programmer's left shirt pocket, safe in the knowledge that it will always be the programmer's badge. Be careful, because the order in which destructors are called is undefined. Try to make each destructor as independent as possible.</p>
<p class=book>Thread-specific data destructors can set a new value for the key for which a value is being destroyed or for any other key. You should never do this directly, but it can easily happen indirectly if you call other functions from your destructor. For example, the ANSI C library's destructors might be called before yours— and calling an ANSI C function, for example, using <CODE>fprintf</CODE> to write a log message to a file, could cause a new value to be assigned to a thread-specific data key. The system must recheck the list of thread-specific data values for you after all destructors have been called.</p>
<p class=book>If your thread-specific data destructor creates a new thread-specific data value,you will get another chance. Maybe too many chances!</p>
<p class=book>The standard requires that a Pthreads implementation may recheck the list some fixed number of times and then give up. When it gives up, the final thread-specific data value is not destroyed. If the value is a pointer to heap memory, the result may be a memory leak, so be careful. The &lt;limits.h&gt; header defines _PTHREAD_DESTRUCTOR_ITERATIONS to the number of times the system will check, and the value must be at least 4. Alternately, the system is allowed to keep checking forever, so a destructor function that always sets thread-specific data values may cause an infinite loop.</p>
<p class=book>Usually, new thread-specific data values are set within a destructor only when subsystem 1 uses thread-specific data that depends on another independent subsystem 2 that also uses thread-specific data. Because the order in which destructor functions run is unspecified, the two may be called in the wrong order. If the subsystem 1 destructor needs to call into subsystem 2, it may inadvertently result in allocating new thread-specific data for subsystem 2. Although the subsystem 2 destructor will need to be called again to free the new data, the subsystem 1 thread-specific data remains NULL, so the loop will terminate.</p>
<p class=book>The following program, <CODE>tsd_destructor.c</CODE>, demonstrates using thread-specific data destructors to release memory when a thread terminates. It also keeps track of how many threads are using the thread-specific data, and deletes the thread-speciflc data key when the destructor is run for the final thread. This program is similar in structure to <CODE>tsd_once.c</CODE>, from Section 5.3, so only the relevant differences will be annotated here.</p>
<p class=book><b>12-14</b> In addition to the key value (identity_key), the program maintains a count of threads that are using the key (identity_key_counter), which is protected by a mutex (identity_key_mutex).</p>
<p class=book><b>22-42</b> The function <CODE>identity_key_destructor</CODE> is the thread-specific data key's destructor function. It begins by printing a message so we can observe when it runs in each thread. It frees the storage used to maintain thread-specific data, the private_t structure. Then it locks the mutex associated with the thread-specific data key (identity_key_mutex) and decreases the count of threads using the key. If the count reaches 0, it deletes the key and prints a message.</p>
<p class=book><b>48-63</b> The function identity_key_get can be used anywhere (in this example, it is used only once per thread) to get the value of identity_key for the calling thread. If there is no current value (the value is NULL), then it allocates a new private_t structure and assigns it to the key for future reference.</p>
<p class=book><b>68-78</b> The function thread_routine is the thread start function used by the example. It acquires a value for the key by calling identity_key_get, and sets the members of the structure. The string member is set to the thread's argument, creating a global "name" for the thread, which can be used for printing messages. <b>80-114</b> The main program creates the thread-specific data key tsd_key. Notice that, unlike tsd_once. c, this program does not bother to use pthread_once. As I mentioned in the annotation for that example, in a main program it is perfectly safe, and more efficient, to create the key inside main, before creating any threads, <b>101</b> The main program initializes the reference counter (identity_key_counter) to 3. It is critical that you define in advance how many threads will reference a key that will be deleted based on a reference count, as we intend to do. The counter must be set before any thread using the key can possibly terminate.</p>
<p class=book>You cannot, for example, code identity_key_get so that it dynamically increases the counter when it first assigns a thread-specific value for identity_ key. That is because one thread might assign a thread-specific value for identity_key and then terminate before another thread using the key had a chance to start. If that happened, the first thread's destructor would find no remaining references to the key, and it would delete the key. Later threads would then fail when trying to set thread-specific data values.</p>
<p class=book>■ <b>tsd_destructor.c</b></p>
<p class=book><CODE>1 #include &lt;pthread.h&gt;</CODE></p>
<p class=book><CODE>2 #include "errors.h"</CODE></p>
<p class=book><CODE>3</CODE></p>
<p class=book><CODE>4 /*</CODE></p>
<p class=book><CODE>5 * Structure used as value of thread-specific data key.</CODE></p>
<p class=book><CODE>6 */</CODE></p>
<p class=book><CODE>7 typedef struct private_tag {</CODE></p>
<p class=book><CODE>8 	pthread_t thread_id;</CODE></p>
<p class=book><CODE>9 	char *string;</CODE> </p>
<p class=book><CODE>10 } private_t;</CODE></p>
<p class=book><CODE>11</CODE></p>
<p class=book><CODE>12 pthread_key_t identity_key; /* Thread-specific data key */</CODE></p>
<p class=book><CODE>13 pthread_mutex_t identity_key_mutex = PTHREAD_MUTEX_INITIALIZER;</CODE></p>
<p class=book><CODE>14 long identity_key_counter = 0; 15</CODE></p>
<p class=book><CODE>16 /*</CODE></p>
<p class=book><CODE>17 * This routine is called as each thread terminates with a value</CODE></p>
<p class=book><CODE>18 * for the thread-specific data key. It keeps track of how many</CODE></p>
<p class=book><CODE>19 * threads still have values, and deletes the key when there are</CODE></p>
<p class=book><CODE>20 * no more references.</CODE></p>
<p class=book><CODE>21 */</CODE></p>
<p class=book><CODE>22 void identity_key_destructor (void *value)</CODE></p>
<p class=book><CODE>23 {</CODE></p>
<p class=book><CODE>24 private_t *private = (private_t*)value;</CODE></p>
<p class=book><CODE>25 int status;</CODE> </p>
<p class=book><CODE>26</CODE></p>
<p class=book><CODE>27 printf ("thread \"%s\" exiting...\n", private-&gt;string);</CODE></p>
<p class=book><CODE>28 free (value);</CODE></p>
<p class=book><CODE>29 status = pthread_mutex_lock (&identity_key_mutex);</CODE></p>
<p class=book><CODE>30 if (status != 0)</CODE></p>
<p class=book><CODE>31 	err_abort (status, "Lock key mutex");</CODE></p>
<p class=book><CODE>32 identity_key_counter--;</CODE></p>
<p class=book><CODE>33 if (identity_key_counter &lt;= 0) {</CODE></p>
<p class=book><CODE>34 	status = pthread_key_delete (identity_key);</CODE></p>
<p class=book><CODE>35 	if (status != 0)</CODE></p>
<p class=book><CODE>36 		err_abort (status, "Delete key");</CODE></p>
<p class=book><CODE>37 	printf ("key deleted...\n");</CODE></p>
<p class=book><CODE>38 }</CODE></p>
<p class=book><CODE>39 status = pthread_mutex_unlock (&identity_key_mutex);</CODE></p>
<p class=book><CODE>40 if (status != 0)</CODE></p>
<p class=book><CODE>41 	err_abort (status, "Unlock key mutex");</CODE></p>
<p class=book><CODE>42 }</CODE> </p>
<p class=book><CODE>43</CODE></p>
<p class=book><CODE>44 /*</CODE></p>
<p class=book><CODE>45 * Helper routine to allocate a new value for thread-specific</CODE></p>
<p class=book><CODE>46 * data key if the thread doesn't already have one.</CODE></p>
<p class=book><CODE>47 */</CODE></p>
<p class=book><CODE>48 void *identity_key_get (void)</CODE></p>
<p class=book><CODE>49 {</CODE></p>
<p class=book><CODE>50 void *value;</CODE></p>
<p class=book><CODE>51 int status; 52</CODE></p>
<p class=book><CODE>53 value = pthread_getspecific (identity_key);</CODE></p>
<p class=book><CODE>54 if (value == NULL) {</CODE></p>
<p class=book><CODE>55 	value = malloc (sizeof (private_t));</CODE></p>
<p class=book><CODE>56 	if (value == NULL)</CODE></p>
<p class=book><CODE>57 		errno_abort ("Allocate key value");</CODE></p>
<p class=book><CODE>58 	status = pthread_setspecific (identity_key, (void*)value);</CODE></p>
<p class=book><CODE>59 	if (status != 0)</CODE></p>
<p class=book><CODE>60 		err_abort (status, "Set TSD");</CODE></p>
<p class=book><CODE>61 }</CODE></p>
<p class=book><CODE>62 return value;</CODE></p>
<p class=book><CODE>63 }</CODE> </p>
<p class=book><CODE>64</CODE></p>
<p class=book><CODE>65 /*</CODE></p>
<p class=book><CODE>66 * Thread start routine to use thread-specific data.</CODE></p>
<p class=book><CODE>67 */</CODE></p>
<p class=book><CODE>68 void *thread_routine (void *arg)</CODE></p>
<p class=book><CODE>69 {</CODE></p>
<p class=book><CODE>70 private_t *value; 71</CODE></p>
<p class=book><CODE>72 value = (private_t*)identity_key_get ();</CODE></p>
<p class=book><CODE>73 value-&gt;thread_id = pthread_self ();</CODE></p>
<p class=book><CODE>74 value-&gt;string = (char*)arg;</CODE></p>
<p class=book><CODE>75 printf ("thread \"%s\" starting...\n", value-&gt;string);</CODE></p>
<p class=book><CODE>76 sleep (2);</CODE></p>
<p class=book><CODE>77 return NULL;</CODE></p>
<p class=book><CODE>78 }</CODE></p>
<p class=book><CODE>79</CODE></p>
<p class=book><CODE>80 void main (int argc, char *argv[])</CODE></p>
<p class=book><CODE>81 {</CODE></p>
<p class=book><CODE>82 pthread_t thread_l, thread_2;</CODE></p>
<p class=book><CODE>83 private_t *value;</CODE></p>
<p class=book><CODE>84 int status;</CODE> </p>
<p class=book><CODE>85</CODE></p>
<p class=book><CODE>86 /*</CODE></p>
<p class=book><CODE>87 * Create the TSD key, and set the reference counter to</CODE></p>
<p class=book><CODE>88 * the number of threads that will use it (two thread_routine</CODE></p>
<p class=book><CODE>89 * threads plus main). This must be done before creating</CODE></p>
<p class=book><CODE>90 * the threads! Otherwise, if one thread runs the key's</CODE></p>
<p class=book><CODE>91 * destructor before any other thread uses the key, it will</CODE></p>
<p class=book><CODE>92 * be deleted.</CODE></p>
<p class=book><CODE>93 *</CODE></p>
<p class=book><CODE>94 * Note that there's rarely any good reason to delete a</CODE></p>
<p class=book><CODE>95 * thread-specific data key.</CODE></p>
<p class=book><CODE>96 */</CODE></p>
<p class=book><CODE>97 status = pthread_key_create (</CODE></p>
<p class=book><CODE>98 	&identity_key, identity_key_destructor);</CODE></p>
<p class=book><CODE>99 if (status != 0)</CODE></p>
<p class=book><CODE>100 	err_abort (status, "Create key");</CODE></p>
<p class=book><CODE>101 identity_key_counter = 3;</CODE></p>
<p class=book><CODE>102 value = (private_t*)identity_key_get ();</CODE></p>
<p class=book><CODE>103 value-&gt;thread_id = pthread_self ();</CODE></p>
<p class=book><CODE>104 value-&gt;string = "Main thread";</CODE></p>
<p class=book><CODE>105 status = pthread_create (&thread_1, NULL,</CODE></p>
<p class=book><CODE>106 thread_routine, "Thread 1");</CODE></p>
<p class=book><CODE>107 if (status != 0)</CODE></p>
<p class=book><CODE>108 	err_abort (status, "Create thread 1");</CODE></p>
<p class=book><CODE>109 status = pthread_create (&thread_2, NULL,</CODE></p>
<p class=book><CODE>110 	thread_routine, "Thread 2");</CODE></p>
<p class=book><CODE>111 if (status != 0)</CODE></p>
<p class=book><CODE>112 	err_abort (status, "Create thread 2");</CODE></p>
<p class=book><CODE>113 pthread_exit (NULL);</CODE></p>
<p class=book><CODE>114 }</CODE></p>



<a name=t81></a><h3 class=book>
5.5 Realtime scheduling
</h3>
<blockquote class="epigraph">
<p class=book><i><b>"Well, it's no use</b></i> <b>your</b> <i><b>talking about waking him,"said Tweedledum,</b> <b>"when you're only one of the things in his dream. You know very well you're not real." "I am real!" said Alice, and began to cry.</b></i> </p>
<p class=book><i><b>"You wo'n't make yourself a bit realler by crying," Tweedledee remarked: "there's nothing to cry about."</b></i></p>
<blockquote class=book><i>— <i>Lewis Carroll, Through the Looking-Glass</i></i></blockquote>
</blockquote>

<p class=book>Once upon a time, realtime programming was considered an arcane and rare art. Realtime programmers were doing unusual things, outside of the programming mainstream, like controlling nuclear reactors or airplane navigational systems. But the POSIX. lb realtime extension defines <i>realtime</i> as "the ability of the operating system to provide a required level of service in a bounded response time." What applies to the operating system also applies to your application or library.</p>
<p class=book>"Bounded" response time does not necessarily mean "fast" response, but it does mean "predictable" response. There must be some way to define a span of time during which a sequence of operations is guaranteed to complete. A system controlling a nuclear reactor has more strict response requirements than most programs you will write, and certainly the consequences of failing to meet the reactor's response requirements are more severe. But a lot of code you write will need to provide some "required level of service" within some "bounded response time." Realtime programming just means that the software lives in the real world.</p>
<p class=book>Realtime programming covers such a vast area that it is common to divide it into two separate categories. "Hard realtime" is the traditional sort most people</p>
<p class=book>think of. When your nuclear reactor will go critical if a fuel rod adjustment is delayed by a microsecond or your airplane will crash if the navigation system takes a half second to respond to a wind sheer, that's <i>hard</i> realtime. Hard realtime is unforgiving, because the required level of service and bounded response time are defined by physics or something equally unyielding. "Soft realtime" means that you need to meet your schedule most of the time, but the consequences of failing to meet the schedule are not severe.</p>
<p class=book>Many systems that interact with humans should be designed according to soft realtime principles. Although humans react slowly, in computer terms, they're sensitive to response time. Make your users wait too often while the screen redraws before accepting the next mouse click, and they'll be annoyed. Nobody likes a "busy cursor" — most people expect response to be at least predictable, even when it cannot be fast.</p>
<p class=book>Threads are useful for all types of realtime programming, because coding for predictable response is far easier when you can keep the operations separate. Your "user input function" doesn't have to wait for your sort operation or for your screen update operation because it executes independently.</p>
<p class=book>Achieving predictability requires a lot more than just separating operations into different threads, however. For one thing, you need to make sure that the thread you need to run "soon" won't be left sitting on a run queue somewhere while another thread uses the processor. Most systems, by default, will try to distribute resources more or less fairly between threads. That's nice for a lot of things — but realtime isn't fair. Realtime means carefully giving precedence to the parts of the program that limit external response time.</p>


<a name=t82></a><h3 class=book>
5.5.1 POSIX realtime options
</h3>
<p class=book>The POSIX standards are flexible, because they're designed to be useful in a wide range of environments. In particular, since traditional UNIX systems don't support any form of realtime scheduling control, all of the tools for controlling realtime response are optional. The fact that a given implementation of UNIX "conforms to 1003.1c-1995" does not mean you can write predictable realtime programs.</p>
<p class=book>If the system defines _POSIX_THREAD_PRIORITY_SCHEDULING, it provides support for assigning realtime scheduling priorities to threads. The POSIX priority scheduling model is a little more complicated than the traditional UNIX priority model, but the principle is similar. Priority scheduling allows the programmer to give the system an idea of how important any two threads are, relative to each other. Whenever more than one thread is ready to execute, the system will choose the thread with the highest priority.</p>


<a name=t83></a><h3 class=book>
5.5.2 Scheduling policies and priorities
</h3>
<p class=book><b>int sched_get_priority_max (int policy);</b></p>
<p class=book><b>int sched_get_priority_min (int policy);</b></p>
<p class=book><b>int pthread_attr_getinheritsched (</b></p>
<p class=book><b>	const pthread_attr_t *attr, int *inheritsched);</b> </p>
<p class=book><b>int pthread_attr_setinheritsched (</b></p>
<p class=book><b>	pthread_attr_t *attr, int inheritsched);</b> </p>
<p class=book><b>int pthread_attr_getschedparam (</b></p>
<p class=book><b>	constpthread_attr_t *attr,</b></p>
<p class=book><b>	struct sched_param *param);</b> </p>
<p class=book><b>int pthread_attr_setschedparam (</b></p>
<p class=book><b>	pthread_attr_t *attr,</b></p>
<p class=book><b>	const struct sched_param *param);</b> </p>
<p class=book><b>int pthread_attr_getschedpolicy (</b></p>
<p class=book><b>	const pthread_attr_t *attr, int *policy);</b> </p>
<p class=book><b>int pthread_attr_setschedpolicy (</b></p>
<p class=book><b>	pthread_attr_t *attr, int policy);</b> </p>
<p class=book><b>int pthread_getschedparam (pthread_t thread,</b></p>
<p class=book><b>	int *policy, struct sched_param *param);</b> </p>
<p class=book><b>int pthread_setschedparam (</b></p>
<p class=book><b>	pthread_t thread, int policy,</b></p>
<p class=book><b>	const struct sched_param *param);</b></p>
<p class=book>A Pthreads system that supports _POSIX_THREAD_PRIORITY_SCHEDULING must provide a definition of the struct <CODE>sched_param</CODE> structure that includes at least the member <CODE>sched_priority</CODE>. The <CODE>sched_priority</CODE> member is the only scheduling parameter used by the standard Pthreads scheduling policies, SCHED_FIFO and SCHED_RR. The minimum and maximum priority values (<CODE>sched_priority</CODE> member) that are allowed for each scheduling policy can be determined by calling <CODE>sched_get_priority_min</CODE> or <CODE>sched_get_priority_max</CODE>, respectively, for the scheduling policy. Pthreads systems that support additional, nonstandard scheduling policies may include additional members.</p>
<p class=book>The SCHED_FIFO <i>(first in, first out)</i> policy allows a thread to run until another thread with a higher priority becomes <i>ready,</i> or until it blocks voluntarily. When a thread with SCHED_FIFO scheduling policy becomes <i>ready,</i> it begins executing immediately unless a thread with equal or higher priority is already executing.</p>
<p class=book>The SCHED_RR <i>(round-robin)</i> policy is much the same, except that if a thread with SCHED_RR policy executes for more than a fixed period of time (the <i>timeslice interval)</i> without blocking, and another thread with SCHED_RR or SCHED_FIFO policy and the same priority is <i>ready,</i> the <i>running</i> thread will be preempted so the <i>ready</i> thread can be executed.</p>
<p class=book>When threads with SCHED_FIFO or SCHED_RR policy wait on a condition variable or wait to lock a mutex, they will be awakened in priority order. That is, if a low-priority SCHED_FIFO thread and a high-priority SCHED_FIFO thread are both waiting to lock the same mutex, the high-priority thread will always be unblocked first when the mutex is unlocked.</p>
<p class=book>Pthreads defines the name of an additional scheduling policy, called SCHED_OTHER. Pthreads, however, says nothing at all regarding what this scheduling policy does. This is an illustration of an unofficial POSIX philosophy that has been termed "a standard way to be nonstandard" (or, alternately, "a portable way to be nonportable"). That is, when you use any implementation of Pthreads that supports the priority scheduling option, you can write a portable program that creates threads running in SCHED_OTHER policy, but the behavior of that program is nonportable. (The official explanation of SCHED_OTHER is that it provides a portable way for a program to declare that it does not need a realtime scheduling policy.)</p>
<p class=book>The SCHED_OTHER policy may be an alias for SCHED_FIFO, or it may be SCHED_RR, or it may be something entirely different. The real problem with this ambiguity is not that you don't know what SCHED_OTHER does, but that you have no way of knowing what scheduling parameters it might require. Because the meaning of SCHED_OTHER is undefined, it does not necessarily use the sched_priority member of the struct sched_param structure, and it may require additional, nonstandard members that an implementation may add to the structure. If there's any point to this, it is simply that SCHED_OTHER is not portable. If you write any code that uses SCHED_OTHER you should be aware that the code is not portable — you are, by definition, depending on the SCHED_OTHER of the particular Pthreads implementation for which you wrote the code.</p>
<p class=book>The <i>schedpolicy</i> and <i>schedparam</i> attributes, set respectively by <CODE>pthread_attr_setschedpolicy</CODE> and <CODE>pthread_attr_setschedparam</CODE>, specify the explicit scheduling policy and parameters for the attributes object. Pthreads does not specify a default value for either of these attributes, which means that each implementation may choose some "appropriate" value. A realtime operating system intended for embedded controller applications, for example, might choose to create threads by default with SCHED_FIFO policy, and, perhaps, some medium-range priority.</p>
<p class=book>Most multiuser operating systems are more likely to use a nonstandard "time-share" scheduling policy by default, causing threads to be scheduled more or less as processes have always been scheduled. The system may, for example, temporarily reduce the priority of "CPU hogs" so that they cannot prevent other threads from making progress.</p>
<p class=book>One example of a multiuser operating system is Digital UNIX, which supports two nonstandard timeshare scheduling policies. The <i>foreground</i> policy (SCHED_ FG_NP), which is the default, is used for normal interactive activity, and corresponds to the way nonthreaded processes are scheduled. The <i>background</i> policy (SCHED_BG_NP) can be used for less important support activities.</p>
<p class=book>When you set the scheduling policy or priority attributes in an attributes object,you must also set the inheritsched attribute!</p>
<p class=book>The <i>inheritsched</i> attribute, which you can set by calling <CODE>pthread_attr_setinheritsched</CODE>, controls whether a thread you create inherits scheduling information from the creating thread, or uses the explicit scheduling information in the <i>schedpolicy</i> and <i>schedparam</i> attributes. Pthreads does not specify a default value for <i>inheritsched,</i> either, so if you care about the policy and scheduling parameters of your thread, you must always set this attribute.</p>
<p class=book>Set the <i>inheritsched</i> attribute to PTHREAD_INHERIT_SCHED to cause a new thread to inherit the scheduling policy and parameters of the creating thread. Scheduling inheritance is useful when you're creating "helper" threads that are working on behalf of the creator — it generally makes sense for them to run at the same policy and priority. Whenever you need to control the scheduling policy or parameters of a thread you create, you must set the <i>inheritsched</i> attribute to PTHREAD_EXPLICIT_SCHED.</p>
<p class=book><b>58-118</b> The following program, sched_attr.c, shows how to use an attributes object to create a thread with an explicit scheduling policy and priority. Notice that it uses conditional code to determine whether the priority scheduling feature of Pthreads is supported at compilation time. It will print a message if the option is not supported and continue, although the program in that case will not do much. (It creates a thread with default scheduling behavior, which can only say that it ran.)</p>
<p class=book>Although Solaris 2.5 defines _POSIX_THREAD_PRIORITY_SCHEDULING, it does not support the POSIX realtime scheduling policies, and attempting to set the policy attribute to SCHED_RR would fail. This program treats Solaris as it did not define the _POSIX_THREAD_PRIORITY_SCHEDULING option.</p>
<p class=book>■ <b>sched_attr.c</b></p>
<p class=book>1 <CODE>#include &lt;unistd.h&gt;</CODE></p>
<p class=book><CODE>2 #include &lt;pthread.h&gt;</CODE></p>
<p class=book><CODE>3 #include &lt;sched.h&gt;</CODE></p>
<p class=book><CODE>4 #include "errors.h" 5</CODE></p>
<p class=book><CODE>6 /*</CODE></p>
<p class=book><CODE>7 * Thread start routine. If priority scheduling is supported,</CODE></p>
<p class=book><CODE>8 * report the thread's scheduling attributes.</CODE></p>
<p class=book><CODE>9 */</CODE></p>
<p class=book><CODE>10 void *thread_routine (void *arg)</CODE></p>
<p class=book><CODE>11 {</CODE></p>
<p class=book><CODE>12 	int my_policy;</CODE></p>
<p class=book><CODE>13 	struct sched_param my_param;</CODE></p>
<p class=book><CODE>14 	int status;</CODE> </p>
<p class=book><CODE>15</CODE></p>
<p class=book><CODE>16 /*</CODE></p>
<p class=book><CODE>17 * If the priority scheduling option is not defined, then we</CODE></p>
<p class=book><CODE>18 * can do nothing with the output of pthread_getschedparam,</CODE></p>
<p class=book><CODE>19 * so just report that the thread ran, and exit.</CODE></p>
<p class=book><CODE>20 */</CODE></p>
<p class=book><CODE>21 #if defined (_POSIX_THREAD_PRIORITY_SCHEDULING) && !defined (sun)</CODE></p>
<p class=book><CODE>22 	status = pthread_getschedparam (</CODE></p>
<p class=book><CODE>23 		pthread_self (), &my_policy, &my_param);</CODE></p>
<p class=book><CODE>24 	if (status != 0)</CODE></p>
<p class=book><CODE>25 		err_abort (status, "Get sched");</CODE></p>
<p class=book><CODE>26 	printf ("thread_routine running at %s/%d\n",</CODE></p>
<p class=book><CODE>27 		(my_policy == SCHED_FIFO ? "FIFO"</CODE></p>
<p class=book><CODE>28 		: (my_policy == SCHED_RR ? "RR"</CODE></p>
<p class=book><CODE>29 		: (my_policy == SCHED_OTHER ? "OTHER"</CODE></p>
<p class=book><CODE>30 		: "unknown"))),</CODE></p>
<p class=book><CODE>31 		my_param.sched_priority);</CODE></p>
<p class=book><CODE>32 #else</CODE></p>
<p class=book><CODE>33 	printf ("thread_routine running\n");</CODE></p>
<p class=book><CODE>34 #endif</CODE></p>
<p class=book><CODE>35 	return NULL;</CODE></p>
<p class=book><CODE>36 }</CODE></p>
<p class=book><CODE>37</CODE></p>
<p class=book><CODE>38 int main (int argc, char *argv[])</CODE></p>
<p class=book><CODE>39 {</CODE></p>
<p class=book><CODE>40 	pthread_t thread_id;</CODE></p>
<p class=book><CODE>41 	pthread_attr_t thread_attr;</CODE></p>
<p class=book><CODE>42 	int thread_policy;</CODE></p>
<p class=book><CODE>43 	struct sched_param thread_param;</CODE></p>
<p class=book><CODE>44 	int status, rr_min_priority, rr_max_priority;</CODE></p>
<p class=book><CODE>45</CODE></p>
<p class=book><CODE>46 	status = pthread_attr_init (&thread_attr);</CODE></p>
<p class=book><CODE>47 	if (status != 0)</CODE></p>
<p class=book><CODE>4 8 		err_abort (status, "Init attr");</CODE></p>
<p class=book><CODE>49</CODE></p>
<p class=book><CODE>50 /*</CODE></p>
<p class=book><CODE>51 * If the priority scheduling option is defined, set various</CODE></p>
<p class=book><CODE>52 * scheduling parameters. Note that it is particularly important</CODE></p>
<p class=book><CODE>53 * that you remember to set the inheritsched attribute to</CODE></p>
<p class=book><CODE>54 * PTHREAD_EXPLICIT_SCHED, or the policy and priority that you've</CODE></p>
<p class=book><CODE>55 * set will be ignored! The default behavior is to inherit</CODE></p>
<p class=book><CODE>56 * scheduling information from the creating thread.</CODE></p>
<p class=book><CODE>57 */</CODE></p>
<p class=book><CODE>58 #if defined (_POSIX_THREAD_PRIORITY_SCHEDULING) && !defined (sun)</CODE></p>
<p class=book><CODE>59 	status = pthread_attr_getschedpolicy (</CODE></p>
<p class=book><CODE>60 		&thread_attr, &thread_policy);</CODE></p>
<p class=book><CODE>61 	if (status 1= 0)</CODE></p>
<p class=book><CODE>62 		err_abort (status, "Get policy");</CODE></p>
<p class=book><CODE>63 	status = pthread_attr_getschedparam (</CODE></p>
<p class=book><CODE>64 		&thread_attr, &thread_param);</CODE></p>
<p class=book><CODE>65 	if (status != 0)</CODE></p>
<p class=book><CODE>66 		err_abort (status, "Get sched param");</CODE></p>
<p class=book><CODE>67 	printf (</CODE></p>
<p class=book><CODE>68 		"Default policy is %s, priority is %d\n",</CODE></p>
<p class=book><CODE>69 		(thread_policy == SCHED_FIFO ? "FIFO"</CODE></p>
<p class=book><CODE>70 		: (thread_policy == SCHED_RR ? "RR"</CODE></p>
<p class=book><CODE>71 		: (thread_policy == SCHED_OTHER ? "OTHER" 72 : "unknown"))),</CODE></p>
<p class=book><CODE>73 		thread_param.sched_priority);</CODE></p>
<p class=book><CODE>74</CODE></p>
<p class=book><CODE>75  	status = pthread_attr_setschedpolicy (</CODE></p>
<p class=book><CODE>76 		&thread_attr, SCHED_RR);</CODE></p>
<p class=book><CODE>77 	if (status != 0)</CODE></p>
<p class=book><CODE>78 		printf ("Unable to set SCHED_RR policy.\n");</CODE></p>
<p class=book><CODE>79 	else {</CODE></p>
<p class=book><CODE>80 /*</CODE></p>
<p class=book><CODE>81 * Just for the sake of the exercise, we'll use the</CODE></p>
<p class=book><CODE>82 * middle of the priority range allowed for</CODE></p>
<p class=book><CODE>83 * SCHED_RR. This should ensure that the thread will be</CODE></p>
<p class=book><CODE>84 * run, without blocking everything else. Because any</CODE></p>
<p class=book><CODE>85 * assumptions about how a thread's priority interacts</CODE></p>
<p class=book><CODE>86 * with other threads (even in other processes) are</CODE></p>
<p class=book><CODE>87 * nonportable, especially on an implementation that</CODE></p>
<p class=book><CODE>88 * defaults to System contention scope, you may have to</CODE></p>
<p class=book><CODE>89 * adjust this code before it will work on some systems.</CODE></p>
<p class=book><CODE>90 */</CODE></p>
<p class=book><CODE>91 		rr_min_priority = sched_get_priority_min (SCHED_RR);</CODE></p>
<p class=book><CODE>92 	if (rr_min_priority == -1)</CODE></p>
<p class=book><CODE>93 		errno_abort ("Get SCHED_RR min priority");</CODE></p>
<p class=book><CODE>94 	rr_max_priority = sched_get_priority_max (SCHED_RR);</CODE></p>
<p class=book><CODE>95 	if (rr_max_priority == -1)</CODE></p>
<p class=book><CODE>96 		errno_abort ("Get SCHED_RR max priority");</CODE></p>
<p class=book><CODE>97 	thread_param.sched_priority =</CODE></p>
<p class=book><CODE>98 		(rr_min_priority + rr_max_priority)/2;</CODE></p>
<p class=book><CODE>99 	printf (</CODE></p>
<p class=book><CODE>100 		"SCHED_RR priority range is %d to %d: using %d\n",</CODE></p>
<p class=book><CODE>101 		rr_min_priority,</CODE></p>
<p class=book><CODE>102 		rr_max_priority,</CODE></p>
<p class=book><CODE>103 		thread_param.sched_priority);</CODE></p>
<p class=book><CODE>104  	status = pthread_attr_setschedparam (</CODE></p>
<p class=book><CODE>105 		&thread_attr, &thread_param);</CODE></p>
<p class=book><CODE>106 	if (status != 0)</CODE></p>
<p class=book><CODE>107 		err_abort (status, "Set params");</CODE></p>
<p class=book><CODE>108 	printf (</CODE></p>
<p class=book><CODE>109 		"Creating thread at RR/%d\n",</CODE></p>
<p class=book><CODE>110 		thread_param.sched_priority);</CODE></p>
<p class=book><CODE>111 	status = pthread_attr_setinheritsched (</CODE></p>
<p class=book><CODE>112 		&thread_attr, PTHREAD_EXPLICIT_SCHED);</CODE></p>
<p class=book><CODE>113 	if (status != 0)</CODE></p>
<p class=book><CODE>114 		err_abort (status, "Set inherit");</CODE></p>
<p class=book><CODE>115 }</CODE></p>
<p class=book><CODE>116 #else</CODE></p>
<p class=book><CODE>117 	printf ("Priority scheduling not supported\n");</CODE></p>
<p class=book><CODE>118 #endif</CODE></p>
<p class=book><CODE>119 	status = pthread_create (</CODE></p>
<p class=book><CODE>120 		&thread_id, &thread_attr, thread_routine, NULL);</CODE></p>
<p class=book><CODE>121 	if (status != 0)</CODE></p>
<p class=book><CODE>122 		err_abort (status, "Create thread");</CODE></p>
<p class=book><CODE>123 	status = pthread_join (thread_id, NULL);</CODE></p>
<p class=book><CODE>124 	if (status != 0)</CODE></p>
<p class=book><CODE>125 		err_abort (status, "Join thread");</CODE></p>
<p class=book><CODE>126 	printf ("Main exiting\n");</CODE></p>
<p class=book><CODE>127 return 0;</CODE></p>
<p class=book><CODE>128 }</CODE></p>
<p class=book>The next program, sched_thread.c, shows how to modify the realtime scheduling policy and parameters for a running thread. When changing the scheduling policy and parameters in a thread attributes object, remember, you use two separate operations: one to modify the scheduling policy and the other to modify the scheduling parameters.</p>
<p class=book>You cannot modify the scheduling policy of a running thread separately from the thread's parameters, because the policy and parameters must always be consistent for scheduling to operate correctly. Each scheduling policy may have a unique range of valid scheduling priorities, and a thread cannot operate at a priority that isn't valid for its current policy. To ensure consistency of the policy and parameters, they are set with a single call. </p>
<p class=book><b>55</b> Unlike sched_attr.c, sched_thread.c does not check the compile-time feature macro _POSIX_THREAD_PRIORITY_SCHEDULING<b>.</b> That means it will probably not compile, and almost certainly won't run correctly, on a system that does not support the option. There's nothing wrong with writing a program that way — in fact, that's what you are likely to do most of the time. If you need priority scheduling, you would document that your application requires the _POSIX_THREAD_ PRIORITY_SCHEDULING option, and use it. </p>
<p class=book><b>57-62</b> Solaris 2.5, despite defining _POSIX_THREAD_PRIORITY_SCHEDULING<b>,</b> does not support realtime scheduling policies. For this reason, the ENOSYS from <CODE>sched_get_priority_min</CODE> is handled as a special case.</p>
<p class=book>■ <b>sched_thread.c</b></p>
<p class=book><CODE>1 #include &lt;unistd.h&gt;</CODE></p>
<p class=book><CODE>2 #include &lt;pthread.h&gt;</CODE></p>
<p class=book><CODE>3 #include &lt;sched.h&gt;</CODE></p>
<p class=book><CODE>4 #include "errors.h" 5</CODE></p>
<p class=book><CODE>6 #define THREADS 5 7</CODE></p>
<p class=book><CODE>8 /*</CODE></p>
<p class=book><CODE>9 * Structure describing each thread.</CODE> </p>
<p class=book><CODE>10 */</CODE></p>
<p class=book><CODE>11 typedef struct thread_tag {</CODE></p>
<p class=book><CODE>12 	int index;</CODE></p>
<p class=book><CODE>13 	pthread_t id;</CODE></p>
<p class=book><CODE>14 } thread_t;</CODE></p>
<p class=book><CODE>15</CODE></p>
<p class=book><CODE>16 thread_t threads[THREADS];</CODE></p>
<p class=book><CODE>17 int rr_min_priority; 18</CODE></p>
<p class=book><CODE>19 /*</CODE></p>
<p class=book><CODE>20 * Thread start routine that willset its own priority.</CODE></p>
<p class=book><CODE>21 */</CODE></p>
<p class=book><CODE>22 void *thread_routine (void *arg)</CODE></p>
<p class=book><CODE>23 {</CODE></p>
<p class=book><CODE>24 	thread_t *self = (thread_t*)arg;</CODE></p>
<p class=book><CODE>25 	int my_policy;</CODE></p>
<p class=book><CODE>26 	struct sched_param my_param;</CODE></p>
<p class=book><CODE>27 	int status;</CODE> </p>
<p class=book><CODE>28</CODE></p>
<p class=book><CODE>29 	my_param.sched_priority = rr_min_priority + self-&gt;index;</CODE></p>
<p class=book><CODE>30 	DPRINTF ((</CODE></p>
<p class=book><CODE>31 		"Thread %d will set SCHED_FIFO, priority %d\n",</CODE></p>
<p class=book><CODE>32 		self-&gt;index, my_param.sched_priority));</CODE></p>
<p class=book><CODE>33 	status = pthread_setschedparam (</CODE></p>
<p class=book><CODE>34 		self-&gt;id, SCHED_RR, &my_param);</CODE></p>
<p class=book><CODE>35 	if (status != 0) </CODE></p>
<p class=book><CODE>36 		err_abort (status, "Set sched");</CODE></p>
<p class=book><CODE>37 	status = pthread_getschedparam (</CODE></p>
<p class=book><CODE>38 		self-&gt;id, &my_policy, &my_param);</CODE></p>
<p class=book><CODE>39 	if (status != 0)</CODE></p>
<p class=book><CODE>40 		err_abort (status, "Get sched");</CODE></p>
<p class=book><CODE>41 	printf ("thread_routine %d running at %s/%d\n",</CODE></p>
<p class=book><CODE>42 		self-&gt;index,</CODE></p>
<p class=book><CODE>43 		(my_policy == SCHED_FIFO ? "FIFO"</CODE></p>
<p class=book><CODE>44 		: (my_policy == SCHED_RR ? "RR"</CODE></p>
<p class=book><CODE>45 		: (my_policy == SCHED_OTHER ? "OTHER" 46 : "unknown"))),</CODE></p>
<p class=book><CODE>47 		my_param.sched_priority);</CODE></p>
<p class=book><CODE>48 	return NULL;</CODE></p>
<p class=book><CODE>49 }</CODE> </p>
<p class=book><CODE>50</CODE></p>
<p class=book><CODE>51 int main (int argc, char *argv[])</CODE></p>
<p class=book><CODE>52 {</CODE></p>
<p class=book><CODE>53 	int count, status;</CODE> </p>
<p class=book><CODE>54</CODE></p>
<p class=book><CODE>55 	rr_min_priority = sched_get_priority_min (SCHED_RR);</CODE></p>
<p class=book><CODE>56 	if (rr_min_priority == -1) {</CODE></p>
<p class=book><CODE>57 #ifdef sun</CODE></p>
<p class=book><CODE>58 		if (errno == ENOSYS) {</CODE></p>
<p class=book><CODE>59 			fprintf (stderr, "SCHED_RR is not supported.\n");</CODE></p>
<p class=book><CODE>60 			exit (0);</CODE></p>
<p class=book><CODE>61 		}</CODE></p>
<p class=book><CODE>62 #endif</CODE></p>
<p class=book><CODE>63 		errno_abort ("Get SCHED_RR min priority");</CODE></p>
<p class=book><CODE>64 	}</CODE></p>
<p class=book><CODE>65 	for (count = 0; count &lt; THREADS; count++) {</CODE></p>
<p class=book><CODE>66 		threads[count].index = count;</CODE></p>
<p class=book><CODE>67 		status = pthread_create (</CODE></p>
<p class=book><CODE>68 			&threads[count].id, NULL,</CODE></p>
<p class=book><CODE>69 			thread_routine, (void*)&threads[count]);</CODE></p>
<p class=book><CODE>70 		if (status != 0)</CODE></p>
<p class=book><CODE>71 			err_abort (status, "Create thread");</CODE></p>
<p class=book><CODE>72 	}</CODE></p>
<p class=book><CODE>73 	for (count = 0; count &lt; THREADS; count++) {</CODE></p>
<p class=book><CODE>74 		status = pthread_join (threads[count].id, NULL);</CODE></p>
<p class=book><CODE>75 		if (status != 0)</CODE></p>
<p class=book><CODE>76 			err_abort (status, "Join thread");</CODE></p>
<p class=book><CODE>77 	}</CODE></p>
<p class=book><CODE>78 	printf ("Main exiting\n");</CODE></p>
<p class=book><CODE>79 	return 0;</CODE></p>
<p class=book><CODE>80 }</CODE></p>


<a name=t84></a><h3 class=book>
<b>5.5.3 Contention scope and allocation domain</b>
</h3>
<p class=book><b>int pthread_attr_getscope (</b></p>
<p class=book><b>	const pthread_attr_t *attr, int *contentionscope);</b></p>
<p class=book><b>int pthread_attr_setscope (</b></p>
<p class=book><b>	pthread_attr_t *attr, int contentionscope);</b></p>
<p class=book>Besides scheduling policy and parameters, two other controls are important in realtime scheduling. Unless you are writing a realtime application, they probably don't matter. If you are writing a realtime application, you will need to find out which settings of these controls are supported by a system.</p>
<p class=book>The first control is called <i>contention scope.</i> It is a description of how your threads compete for processor resources. <i>System contention scope</i> means that your thread competes for processor resources against threads outside your process. A high-priority system contention scope thread in your process can keep system contention scope threads in other processes from running (or vice versa). <i>Process contention scope</i> means that your threads compete only among themselves. Usually, process contention scope means that the operating system chooses a process to execute, possibly using only the traditional UNIX priority, and some additional scheduler within the process applies the POSIX scheduling rules to determine which thread to execute.</p>
<p class=book>Pthreads provides the thread <i>scope</i> attribute so that you can specify whether each thread you create should have process or system contention scope. A Pthreads system may choose to support PTHREAD_SCOPE_PROCESS, PTHREAD_ SCOPE_SYSTEM, or both. If you try to create a thread with a scope that is not supported by the system, <CODE>pthread_attr_setscope</CODE> will return ENOTSUP.</p>
<p class=book>The second control is <i>allocation domain.</i> An allocation domain is the set of processors within the system for which threads may compete. A system may have one or more allocation domains, each containing one or more processors. In a uniprocessor system, an allocation domain will contain only one processor, but you may still have more than one allocation domain. On a multiprocessor, each allocation domain may contain from one processor to the number of processors in the system.</p>
<p class=book>There is no Pthreads interface to set a thread's allocation domain. The POSIX.14 (Multiprocessor Profile) working group considered proposing standard interfaces, but the effort was halted by the prospect of dealing with the wide range of hardware architectures and existing software interfaces. Despite the lack of a standard, any system supporting multiprocessors will have interfaces to affect the allocation domain of a thread.</p>
<p class=book>Because there is no standard interface to control allocation domain, there is no way to describe precisely all the effects of any particular hypothetical situation. Still, you may need to be concerned about these things if you use a system that supports multiprocessors. A few things to think about:</p>
<p class=book>1. How do system contention scope threads and process contention scope threads, within the same allocation domain, interact with each other? They are competing for resources in some manner, but the behavior is not defined by the standard.</p>
<p class=book>2. If the system supports "overlapping" allocation domains, in other words, if a processor can appear in more than one allocation domain within the system, and you have one system contention scope thread in each of two overlapping allocation domains, what happens?</p>
<p class=book>System contention scope is <i>predictable.</i></p>
<p class=book>Process contention scope is <i>cheap.</i></p>
<p class=book>On most systems, you will get better performance, and lower cost, by using only <i>process</i> contention scope. Context switches between system contention scope threads usually require at least one call into the kernel, and those calls are relatively expensive compared to the cost of saving and restoring thread state in user mode. Each system contention scope thread will be permanently associated with one "kernel entity," and the number ofkernel entities is usually more limited than the number of Pthreads threads. Process contention scope threads may share one kernel entity, or some small number of kernel entities. On a given system configuration, for example, you may be able to create thousands of process contention scope threads, but only hundreds ofsystem contention scope threads.</p>
<p class=book>On the other hand, process contention scope gives you no real control over the scheduling priority of your thread — while a high priority may give it precedence over other threads in the process, it has no advantage over threads in other processes with lower priority. System contention scope gives you better predictability by allowing control, often to the extent of being able to make your thread "more important" than threads running within the operating system kernel.</p>
<p class=book>System contention scope is less predictable with an allocation domain greater than one.</p>
<p class=book>When a thread is assigned to an allocation domain with more than a single processor, the application can no longer rely on completely predictable scheduling behavior. Both high- and low-priority threads may run at the same time, for example, because the scheduler will not allow processors to be idle just because a high-priority thread is running. The uniprocessor behavior would make little sense on a multiprocessor.</p>
<p class=book>When thread 1 awakens thread 2 by unlocking a mutex, and thread 2 has a higher priority than thread 1, thread 2 will preempt thread 1 and begin running immediately. However, if thread 1 and thread 2 are running simultaneously in an allocation domain greater than one, and thread 1 awakens thread 3, which has lower priority than thread 1 but higher priority than thread 2, thread 3 may not immediately preempt thread 2. Thread 3 may remain <i>ready</i> until thread 2 blocks.</p>
<p class=book>For some applications, the predictability afforded by guaranteed preemption in the case outlined in the previous paragraph may be important. In most cases, it is not that important as long as thread 3 will eventually run. Although POSIX does not require any Pthreads system to implement this type of "cross processor preemption," you are more likely to find it when you use system contention scope threads. If predictability is critical, of course, you should be using system contention scope anyway.</p>


<a name=t85></a><h3 class=book>
5.5.4 Problems  with realtime scheduling
</h3>
<p class=book>One of the problems of relying on realtime scheduling is that it is not modular. In real applications you will generally be working with libraries from a variety of sources, and those libraries may rely on threads for important functions like network communication and resource management. Now, it may seem reasonable to make "the most important thread" in your library run with SCHED_FIFO policy and maximum priority. The resulting thread, however, isn't just the most important thread for your library — it is (or, at least, behaves as) the most important thread in the entire process, including the main program and any other libraries. Your high-priority thread may prevent all other libraries, and in some cases even the operating system, from performing work on which the application relies.</p>
<p class=book>Another problem, which really isn't a problem with priority scheduling, but with the way many people think about priority scheduling, is that it doesn't do what many people expect. Many people think that "realtime priority" threads somehow "go faster" than other threads, and that's not true. Realtime priority threads may actually go slower, because there is more overhead involved in making all of the required preemption checks at all the right times — especially on a multiprocessor.</p>
<p class=book>A more severe problem with fixed priority scheduling is called <i>priority inversion.</i> Priority inversion is when a low-priority thread can prevent a high-priority thread from running — a nasty interaction between <i>scheduling</i> and <i>synchronization.</i> Scheduling rules state that one thread should run, but synchronization requires that another thread run, so that the priorities of the two threads appear to be reversed.</p>
<p class=book>Priority inversion occurs when low-priority thread acquires a shared resource (such as a mutex), and is preempted by a high-priority thread that then blocks on that same resource. With only two threads, the low-priority thread would then be allowed to run, eventually (we assume) releasing the mutex. However, if a third thread with a priority between those two is ready to run, it can prevent the low-priority thread from running. Because the low-priority thread holds the mutex that the high-priority thread needs, the middle-priority thread is also keeping the higher-priority thread from running.</p>
<p class=book>There are a number of ways to prevent priority inversion. The simplest is to avoid using realtime scheduling, but that's not always practical. Pthreads provides several mutex locking protocols that help avoid priority inversion, <i>priority ceiling</i> and <i>priority inheritance.</i> These are discussed in Section 5.5.5.</p>
<p class=book><b>I</b> Most threaded programs do not need realtime scheduling.</p>
<p class=book>A final problem is that priority scheduling isn't completely portable. Pthreads defines the priority scheduling features under an option, and many implementations that are not primarily intended for realtime programming may choose not to support the option. Even if the option is supported, there are many important aspects of priority scheduling that are not covered by the standard. When you use system contention scope, for example, where your threads may compete directly against threads within the operating system, setting a high priority on your threads might prevent kernel I/O drivers from functioning on some systems.</p>
<p class=book>Pthreads does not specify a thread's default scheduling policy or priority, or how the standard scheduling policies interact with nonstandard policies. So when you set the scheduling policy and priority of your thread, using "portable" interfaces, the standard provides no way to predict how that setting will affect any other threads in the process or the system itself.</p>
<p class=book>If you really need priority scheduling, then use it — and be aware that it has special requirements beyond simply Pthreads. If you need priority scheduling, keep the following in mind:</p>
<p class=book>1. Process contention scope is "nicer" than system contention scope, because you will not prevent a thread in another process, or in the kernel, from running.</p>
<p class=book>2. SCHED_RR is "nicer" than SCHED_FIFO, and slightly more portable, because SCHED_RR threads will be preempted at intervals to share the available processor time with other threads at the same priority.</p>
<p class=book>3. Lower priorities for SCHED_FIFO and SCHED_RR policies are nicer than higher priorities, because you are less likely to interfere with something else that's important.</p>
<p class=book>Unless your code really needs priority scheduling, avoid it. In most cases, introducing priority scheduling will cause more problems than it will solve.</p>


<a name=t86></a><h3 class=book>
5.5.5 Priority-aware mutexes
</h3>

<p class=book><b>#if defined (_POSIX_THREAD_PRIO_PROTECT) \</b></p>
<p class=book><b>	|| defined (_POSIX_THREAD_PRIO_INHERIT)</b></p>
<p class=book><b>int pthread_mutexattr_getprotocol (</b></p>
<p class=book><b>	const pthread_mutexattr_t *attr, int *protocol);</b></p>
<p class=book><b>int pthread_mutexattr_setprotocol (</b></p>
<p class=book><b>	pthread_mutexattr_t *attr, int protocol);</b> </p>
<p class=book><b>#endif</b></p>
<p class=book><b>#ifdef _POSIX_THREAD_PRIO_PROTECT</b></p>
<p class=book><b>int pthread_mutexattr_getprioceiling (</b></p>
<p class=book><b>	const pthread_attr_t *attr, int *prioceiling);</b></p>
<p class=book><b>int pthread_mutexattr_setprioceiling (</b></p>
<p class=book><b>	pthread_mutexattr_t *attr, int prioceiling);</b></p>
<p class=book><b>int pthread_mutex_getprioceiling (</b></p>
<p class=book><b>	const pthread_mutex_t *mutex, int *prioceiling);</b></p>
<p class=book><b>int pthread_mutex_setprioceiling (</b></p>
<p class=book><b>	pthread_mutex_t *mutex,</b></p>
<p class=book><b>int prioceiling, int *old_ceiling);</b></p>
<p class=book><b>#endif</b></p>
<p class=book>Pthreads provides several special mutex attributes that can help to avoid priority inversion deadlocks. Locking, or waiting for, a mutex with one of these attributes may change the priority of the thread — or the priority of other threads— to ensure that the thread that owns the mutex cannot be preempted by another thread that needs to lock the same mutex.</p>
<p class=book>These mutex attributes may not be supported by your implementation of Pthreads, because they are optional features. If your code needs to function with or without these options, you can conditionally compile references based on the feature test macros _POSIX_THREAD_PRIO_PROTECT or _POSIX_THREAD_PRIO_ INHERIT, defined in &lt;unistd.h&gt;, or you can call sysconf during program execution to check for SC_THREAD_PRIO_PROTECT or SC_THREAD_PRIO_INHERIT.</p>
<p class=book>Once you've created a mutex using one of these attributes, you can lock and unlock the mutex exactly like any other mutex. As a consequence, you can easily convert any mutex you create by changing the code that initializes the mutex. (You must call pthread_mutex_init, however, because you cannot statically initialize a mutex with nondefault attributes.)</p>
<p class=book>"Priority ceiling" protocol means that while a thread owns the mutex, it runs at the specified priority.</p>
<p class=book>If your system defines <b>_POSIX_THREAD_PRIO_PROTECT</b> then it supports the <i>protocol</i> and <i>prioceiling</i> attributes. You set the <i>protocol</i> attribute by calling pthread_mutexattr_setprotocol. If you set the <i>protocol</i> attribute to the value <b>PTHREAD_PRIO_PROTECT,</b> then you can also specify the priority ceiling for mutexes created using the attributes object by setting the <i>prioceiling</i> attribute.</p>
<p class=book>You set the <i>prioceiling</i> attribute by calling the function pthread_mutexattr_ setprioceiling. When any thread locks a mutex defined with such an attributes object, the thread's priority will be set to the priority ceiling of the mutex, unless the thread's priority is already the same or higher. Note that locking the mutex in a thread running at a priority above the priority ceiling of the mutex breaks the protocol, removing the protection against priority inversion.</p>
<p class=book>"Priority inheritance" means that when a thread waits on a mutex owned by a lower-priority thread,the priority of the owner is increased to that of the waiter.</p>
<p class=book>If your system defines <b>_POSIX_THREAD_PRIO_INHERIT</b> then it supports the <i>protocol</i> attribute. If you set the <i>protocol</i> attribute to the value <b>PTHREAD</b>_PRIO_ <b>INHERIT,</b> then no thread holding the mutex can be preempted by another thread with a priority lower than that of any thread waiting for the mutex. When any thread attempts to lock the mutex while a lower-priority thread holds the mutex, the priority of the thread currently holding the mutex will be raised to the priority of the waiter as long as it owns the mutex.</p>
<p class=book>If your system does not define either <b>_POSIX_THREAD_PRIO_PROTECT</b> or <b>_POSIX_ THREAD_PRIO_INHERIT</b> then the <i>protocol</i> attribute may not be defined. The default value of the <i>protocol</i> attribute (or the effective value ifthe attribute isn't defined) is <b>POSIX_PRIO_NONE,</b> which means that thread priorities are not modified by the act of locking (or waiting for) a mutex.</p>


<a name=t87></a><h3 class=book>
5.5.5.1 Priority ceiling mutexes
</h3>
<p class=book>The simplest of the two types of "priority aware" mutexes is the <i>priority ceiling</i> (or "priority protection") protocol (Figure 5.3). When you create a mutex using a priority ceiling, you specify the highest priority at which a thread will ever be running when it locks the mutex. Any thread locking that mutex will have its</p>
<p class=book><img border=0 style='spacing 9px;' src="img_16.png"></p>
<p class=book><b>FIGURE 5.3</b> <i>Priority ceiling mutex operation</i></p>
<p class=book>priority automatically raised to that value, which will allow it to finish with the mutex before it can be preempted by any other thread that might try to lock the mutex. You can also examine or modify the priority ceiling of a mutex that was created with the priority ceiling <i>(protect)</i> protocol.</p>
<p class=book>A priority ceiling mutex is not useful within a library that can be called by threads you don't control. If any thread that is running at a priority above the ceiling locks the priority ceiling mutex, the protocol is broken. This doesn't necessarily guarantee a priority inversion, but it removes all protection against priority inversion. Since the priority ceiling protocol adds overhead to each mutex operation compared to a normal "unprotected" mutex, you may have wasted processor time accomplishing nothing.</p>
<p class=book>Priority ceiling is perfect for an embedded realtime application where the developers control all synchronization within the system. The priority ceiling can be safely determined when the code is designed, and you can avoid priority inversion with a relatively small cost in performance compared to more general solutions. Of course it is always most efficient to avoid priority inversion, either by avoiding priority scheduling or by using any given mutex only within threads of equal priority. Equally, of course, these alternatives rarely prove practical when you need them most.</p>
<p class=book>You can use priority ceiling within almost any main program, even when you don't control the code in libraries you use. That's because while it is common for threads that call into library functions to lock library mutexes, it is not common for threads created by a library to call into application code and lock application mutexes. If you use a library that has "callbacks" into your code, you must either ensure that those callbacks (and any functions they call) don't use the priority ceiling mutexes or that no thread in which the callback might be invoked will run at a priority above the ceiling priority of the mutex.</p>


<a name=t88></a><h3 class=book>
5.5.5.2 Priority inheritance mutexes
</h3>
<p class=book>The other Pthreads mutex protocol is <i>priority inheritance.</i> In the priority inheritance protocol, when a thread locks a mutex the thread's priority is controlled through the mutex (Figure 5.4). When another thread needs to block on that mutex, it looks at the priority of the thread that owns the mutex. If the thread that owns the mutex has a lower priority than the thread attempting to block on the mutex, the priority of the owner is raised to the priority of the blocking thread.</p>
<p class=book>The priority increase ensures that the thread that has the mutex locked cannot be preempted unless the waiting thread would also have been preempted — in a sense, the thread owning the mutex is working on behalf of the higher-priority thread. When the thread unlocks the mutex, the thread's priority is automatically lowered to its normal priority and the highest-priority waiter is awakened. If a second thread of even higher priority blocks on the mutex, the thread that has the mutex blocked will again have its priority increased. The thread will still be returned to its original priority when the mutex is unlocked.</p>
<p class=book>The priority inheritance protocol is more general and powerful than priority ceiling, but also more complicated and expensive. If a library package must make use of priority scheduling, and cannot avoid use of a mutex from threads of differ-ent priority, then priority inheritance is the only currently available solution. If you are writing a main program, and know that none of your mutexes can be locked by threads created within a library, then priority ceiling will accomplish the same result as priority inheritance, and with less overhead.</p>
<p class=book><b>FIGURE 5.4</b> <i>Priority inheritance mutex operation</i></p>
<p class=book><img border=0 style='spacing 9px;' src="img_17.png"></p>




<a name=t89></a><h3 class=book>
5.6 Threads and kernel entities
</h3>
<blockquote class="epigraph">
<p class=book>"Two llnesl" cried the Mock Turtle. "Seals, turtles, salmon, and so on:</p>
<p class=book>then, when you've cleared all the jelly-fish out of the way—" </p>
<p class=book>"That generally takes some time,"interrupted the Gryphon, "</p>
<p class=book>—you advance twice—"</p>
<p class=book>"Each with a lobster as a partner!" cried the Gryphon.</p>
<blockquote class=book><i>— <i>Lewis Carroll Alice's Adventures in Wonderland</i></i></blockquote>
</blockquote>

<p class=book>Pthreads deliberately says very little about implementation details. This leaves each vendor free to make decisions based on the needs of their users and to allow the state of the art to advance by permitting innovation. The standard places a few essential requirements on the implementation — enough that you can write strictly conforming POSIX applications that do useful work with threads and will be able to run correctly on all conforming implementations of the standard.</p>
<p class=book>Any Pthreads implementation must ensure that "system services invoked by one thread do not suspend other threads" so that you do not need to worry that calling read might block all threads in the process on some systems. On the other hand, this does not mean that your process will always have the maximum possible level of concurrency.</p>
<p class=book>Nevertheless, when using a system it is often useful to understand the ways in which the system may be implemented. When writing ANSI C expressions, for example, it is often helpful to understand what the code generator, and even the hardware, will do with those expressions. With that in mind, the following sections describe, briefly, a few of the main variations you're likely to encounter.</p>
<p class=book>The important terms used in these sections are "Pthreads thread," "kernel entity," and "processor." "Pthreads thread" means a thread that you created by calling pthread_create, represented by an identifier of type pthread_t. These are the threads that you control using Pthreads interfaces. By "processor," I refer to the physical hardware, the particular thing of which a "multiprocessor" has more than one.</p>
<p class=book>Most operating systems have at least one additional level of abstraction between "Pthreads thread" and "processor" and I refer to that as a "kernel entity," because that is the term used by Pthreads. In some systems, "kernel entity" may be a traditional UNIX process. It may be a Digital UNIX Mach thread, or a Solaris 2.x LWP, or an IRLX <i>sproc</i> process. The exact meaning of "kernel entity," and how it interacts with the Pthreads thread, is the crucial difference between the three models described in the following sections.</p>
<p class=book><i><b>*</b> Strictly conforming</i> is used by POSIX to mean something quite specific: a strictly conforming application is one that does not rely on any options or extensions to the standard and requires only the specified minimum value for all implementation limits (but will work correctly with any allowed value).</p>


<a name=t90></a><h3 class=book>
5.6.1 Many-to-one (user level)
</h3>
<p class=book>The many-to-one method is also sometimes called a "library implementation." In general, "many-to-one" implementations are designed for operating systems with no support for threads. Pthreads implementations that run on generic UNIX kernels usually fall into this category—for example, the classic DCE threads reference implementation, or the SunOS 4.x LWP package (no relation to the Solaris 2.x LWP, which is a kernel entity).</p>
<p class=book>Many-to-one implementations cannot take advantage of parallelism on a multiprocessor, and any blocking system service, for example, a call to read, will block all threads in the process. Some implementations may help you avoid this problem by using features such as UNIX nonblocking I/O, or POSIX.1b asynchronous I/O, where available. However, these features have limitations; for example, not all device drivers support nonblocking I/O, and traditional UNIX disk file system response is usually considered "instantaneous" and will ignore the nonblocking I/O mode.</p>
<p class=book>Some many-to-one implementations may not be tightly integrated with the ANSI C library's support functions, and that can cause serious trouble. The <i>stdio</i> functions, for example, might block the entire process (and all threads) while one thread waits for you to enter a command. Any many-to-one implementation that conforms to the Pthreads standard, however, has gotten around these problems, perhaps by including a special version of <i>stdio</i> and other functions.</p>
<p class=book>When you require concurrency but do not need parallelism, a many-to-one implementation may provide the best thread creation performance, as well as the best context switch performance for voluntary blocking using mutexes and condition variables. It is fast because the Pthreads library saves and restores thread context entirely in user mode. You can, for example, create a lot of threads and block most of them on condition variables (waiting for some external event) very quickly, without involving the kernel at all.</p>
<p class=book>Figure 5.5 shows the mapping ofPthreads threads (left column) to the kernel entity (middle column), which is a process, to physical processors (right column). In this case, the process has four Pthreads threads, labeled "Pthread 1" through "Pthread 4." The Pthreads library schedules the four threads onto the single process in user mode by swapping register state (SP, general registers, and so forth). The library may use a timer to preempt a Pthreads thread that runs too long. The kernel schedules the process onto one of the two physical processors, labeled "processor 1" and "processor 2." The important characteristics of this model are shown in Table 5.2.</p>
<img border=0 style='spacing 9px;' src="img_18.png">
<p class=book><b>FIGURE 5.5</b> <i>Many-to-one thread mapping</i></p>
<TABLE>
<TR>
<TD align = "left" ><b>Advantages</b></TD>
<TD align = "left" ><b>Disadvantages</b></TD>
</TR>
<TR>
<TD align = "left" >Fastest context switch time.</TD>
<TD align = "left" >Potentially long latency during system service blocking.</TD>
</TR>
<TR>
<TD align = "left" >Simple; the implementation may even be (mostly) portable.*<sup><a name=r5><a href="#n5" title="
The DCE threads user-mode scheduler can usually be ported to new operating systems in a few days, involving primarily new assembly language for the register context switching routines. We use the motto &quot;Some Assembly Required.&quot;
">[5]</sup></A></TD>
<TD align = "left" >Single-process applications cannot take advantage of multiprocessor hardware.</TD>
</TR>
</TABLE>
<p class=book><b>TABLE 5.2</b> <i>Many-to-one thread scheduling</i></p>


<a name=t91></a><h3 class=book>
5.6.2 One-to-one (kernel level)
</h3>
<p class=book>One-to-one thread mapping is also sometimes called a "kernel thread" implementation. The Pthreads library assigns each thread to a kernel entity. It generally must use blocking kernel functions to wait on mutexes and condition variables. While synchronization may occur either within the kernel or in user mode, thread scheduling occurs within the kernel.</p>
<p class=book>Pthreads threads can take full advantage of multiprocessor hardware in a one-to-one implementation without any extra effort on your part, for example, separating your code into multiple processes. When a thread blocks in the kernel,</p>
<br>
<p class=book>it does not affect other threads any more than the blocking of a normal UNIX process affects other processes. One thread can even process a page fault without affecting other threads.</p>
<p class=book>One-to-one implemenations suffer from two main problems. The first is that they do not scale well. That is, each thread in your application is a kernel entity. Because kernel memory is precious, kernel objects such as processes and threads are often limited by preallocated arrays, and most implementations will limit the number of threads you can create. It will also limit the number of threads that can be created on the entire system — so depending on what other processes are doing, your process may not be able to reach its own limit.</p>
<p class=book>The second problem is that blocking on a mutex and waiting on a condition variable, which happen frequently in many applications, are substantially more expensive on most one-to-one implementations, because they require entering the machine's protected kernel mode. Note that locking a mutex, when it was not already locked, or unlocking a mutex, when there are no waiting threads, may be no more expensive than on a many-to-one implementation, because on most systems those functions can be completed in user mode.</p>
<p class=book>A one-to-one implementation can be a good choice for CPU-bound applications, which don't block very often. Many high-performance parallel applications begin by creating a worker thread for each physical processor in the system, and. once started, the threads run independently for a substantial time period. Such applications will work well because they do not strain the kernel by creating a lot of threads, and they don't require a lot of calls into the kernel to block and unblock their threads.</p>
<p class=book>Figure 5.6 shows the mapping ofPthreads threads (left column) to kernel entities (middle column) to physical processors (right column). In this case, the process has four Pthreads threads, labeled "Pthread 1" through "Pthread 4.* Each Pthreads thread is permanently bound to the corresponding kernel entity. The kernel schedules the four kernel entities (along with those from other processes) onto the two physical processors, labeled "processor 1" and "processor 2." The important characteristics of this model are shown in Table 5.3.</p>
<img border=0 style='spacing 9px;' src="img_19.png">
<p class=book><b>FIGURE 5.6</b> <i>One-to-one thread mapping</i></p>
<TABLE>
<TR>
<TD align = "left" ><b>Advantages</b></TD>
<TD align = "left" ><b>Disadvantages</b></TD>
</TR>
<TR>
<TD align = "left" >Can take advantage of multiprocessor hardware within a single process.</TD>
<TD align = "left" >Relatively slow thread context switch (calls into kernel).</TD>
</TR>
<TR>
<TD align = "left" >No latency during system service blocking.</TD>
<TD align = "left" >Poor scaling when many threads are used, because each Pthreads thread takes kernel resources from the system.</TD>
</TR>
</TABLE>
<p class=book><b>TABLE 5.3</b> <i>One-to-one thread scheduling</i></p>


<a name=t92></a><h3 class=book>
5.6.3 Many-to-few (two level)
</h3>
<p class=book>The many-to-few model tries to merge the advantages of both the many-to-one and one-to-one models, while avoiding their disadvantages. This model requires cooperation between the user-level Pthreads library and the kernel. They share scheduling responsibilities and may communicate information about the threads between each other.</p>
<p class=book>When the Pthreads library needs to switch between two threads, it can do so directly, in user mode. The new Pthreads thread runs on the same kernel entity without intervention from the kernel. This gains the performance benefit of many-to-one implementations for the most common cases, when a thread blocks on a mutex or condition variable, and when a thread terminates.</p>
<p class=book>When the kernel needs to block a thread, to wait for an I/O or other resource, it does so. The kernel may inform the Pthreads library, as in Digital UNIX 4.0, so that the library can preserve process concurrency by immediately scheduling a new Pthreads thread, somewhat like the original "scheduler activations" model proposed by the famous University of Washington research [Anderson, 1991]. Or. the kernel may simply block the kernel entity, in which case it may allow programmers to increase the number of kernel entities that are allocated to the process, as in Solaris 2.5 — otherwise the process could be stalled when all kernel entities have blocked, even though other user threads are ready to run.</p>
<p class=book>Many-to-few implementations excel in most real-world applications, because in most applications, threads perform a mixture of CPU-bound and I/O-bound operations, and block both in I/O and in Pthreads synchronization. Most applications also create more threads than there are physical processors, either directly or because an application that creates a few threads also uses a parallel library that creates a few threads, and so forth.</p>
<p class=book>Figure 5.7 shows the mapping of Pthreads threads (left column) to kernel entities (middle column) to physical processors (right column). In this case, the process has four Pthreads threads, labeled "Pthread 1" through "Pthread 4." The Pthreads library creates some number of kernel entities at initialization (and may create more later). Typically, the library will start with one kernel entity (labeled "kernel entity 1" and "kernel entity 2") for each physical processor. The kernel schedules these kernel entities (along with those from other processes) onto the</p>
<img border=0 style='spacing 9px;' src="img_20.png">
<p class=book><b>FIGURE 5.7</b> <i>Many-to-few thread mapping</i></p>
<br>
<p class=book>two physical processors, labeled "processor 1" and "processor 2." The important characteristics ofthis model are shown in Table 5.4.</p>
<TABLE>
<TR>
<TD align = "left" ><b>Advantages</b></TD>
<TD align = "left" ><b>Disadvantages</b></TD>
</TR>
<TR>
<TD align = "left" >Can take advantage of multiprocessor hardware within a process.</TD>
<TD align = "left" >More complicated than other models.</TD>
</TR>
<TR>
<TD align = "left" >Most context switches are in user mode (fast).</TD>
<TD align = "left" >Programmers lose direct control over kernel entities, since the thread's priority may be meaningful only in user mode.</TD>
</TR>
<TR>
<TD align = "left" >Scales well; a process may use one kernel entity per physical processor, or "a few" more.</TD>
<TD></TD>
</TR>
<TR>
<TD align = "left" >Little latency during system service blocking.</TD>
<TD></TD>
</TR>
</TABLE>
<p class=book><b>TABLE 5.4</b> <i>Many-to few thread scheduling</i></p>




<a name=t93></a><h3 class=book>
6 POSIX adjusts to threads
</h3>
<blockquote class="epigraph">
<p class=book>"Who are you?" said the Caterpillar.</p>
<p class=book>This was not an encouraging opening for a conversation.</p>
<p class=book>Alice replied, rather shyly, "I—I hardly know, Sir,</p>
<p class=book>just at present - at least I know who I was when I got up this morning, but</p>
<p class=book>I think I must have been changed several times since then."</p>
<blockquote class=book><i>— <i>Lewis Carroll, Alice's Adventures in Wonderland</i></i></blockquote>
</blockquote>

<p class=book>Pthreads changes the meaning of a number of traditional POSIX process functions. Most of the changes are obvious, and you'd probably expect them even if the standard hadn't added specific wording. When a thread blocks for I/O, for example, only the calling thread blocks, while other threads in the process can continue to run.</p>
<p class=book>But there's another class of POSIX functions that doesn't extend into the threaded world quite so unambiguously. For example, when you fork a threaded process, what happens to the threads? What does exec do in a threaded process? What happens when one of the threads in a threaded process calls exit?</p>


<a name=t94></a><h3 class=book>
6.1 fork
</h3>

<p class=book>Avoid using fork in a threaded program (if you can) unless you intend to exec a new program immediately.</p>
<p class=book>When a threaded process calls fork to create a child process, Pthreads specifies that only the thread calling fork exists in the child. Although only the calling thread exists on return from fork in the child process, all other Pthreads states remain as they were at the time of the call to fork. In the child process, the thread has the same thread state as in the parent. It owns the same mutexes, has the same value for all thread-specific data keys, and so forth. All mutexes and condition variables exist, although any threads that were waiting on a synchronization object at the time of the fork are no longer waiting. (They don't exist in the child process, so how could they be waiting?)</p>
<p class=book>Pthreads does not "terminate" the other threads in a forked process, as ifthey exited with pthread_exit or even as if they were canceled. They simply cease to exist. That is, the threads do not run thread-specific data destructors or cleanup handlers. This is not a problem if the child process is about to call exec to run a new program, but if you use fork to clone a threaded program, beware that you may lose access to memory, especially heap memory stored only as thread-specific data values.</p>
<p class=book>The state of mutexes is not affected by a fork. If it was locked in the parent it is locked in the child!</p>
<p class=book>If a mutex was locked at the time of the call to fork, then it is still locked in the child. Because a locked mutex is <i>owned</i> by the thread that locked it, the mutex can be unlocked in the child only if the thread that locked the mutex was the one that called fork. This is important to remember — if another thread has a mutex locked when you call fork, you will lose access to that mutex and any data controlled by that mutex.</p>
<p class=book>Despite the complications, you can fork a child that continues running and even continues to use Pthreads. You must use fork handlers carefully to protect your mutexes and the shared data that the mutexes are protecting. Fork handlers are described in Section 6.1.1.</p>
<p class=book>Because thread-specific data destructors and cleanup handlers are not called, you may need to worry about memory leaks. One possible solution would be to cancel threads created by your subsystem in the <i>prepare</i> fork handler, and wait for them to terminate before allowing the fork to continue (by returning), and then create new threads in the <i>parent</i> handler that is called after fork completes. This could easily become messy, and I am not recommending it as a solution. Instead, take another look at the warning back at the beginning of this section: Avoid using fork in threaded code except where the child process will immediately exec a new program.</p>
<p class=book>POSIX specifies a small set of functions that may be called safely from within signal-catching functions ("async-signal safe" functions), and fork is one ofthem. However, none of the POSIX threads functions is async-signal safe (and there are good reasons for this, because being async-signal safe generally makes a function substantially more expensive). With the introduction offork handlers, however, a call to fork is also a call to some set of fork handlers.</p>
<p class=book>The purpose of a fork handler is to allow threaded code to protect synchronization state and data invariants across a fork, and in most cases that requires locking mutexes. But you cannot lock mutexes from a signal-catching function. So while it is legal to call fork from within a signal-catching function, doing so may fbeyond the control or knowledge of the caller) require performing other operations that cannot be performed within a signal-catching function.</p>
<p class=book>This is an inconsistency in the POSIX standard that will need to be fixed. Nobody yet knows what the eventual solution will be. My advice is to avoid using fork in a signal-catching function.</p>


<a name=t95></a><h3 class=book>
6.1.1 Fork handlers
</h3>
<p class=book><b>int pthread_atfork (void (*prepare)(void),</b></p>
<p class=book><b>void (*parent)(void), void (*child)(void));</b></p>
<p class=book>Pthreads added the pthread_atfork "fork handler" mechanism to allow your code to protect data invariants across fork. This is somewhat analogous to atexit, which allows a program to perform cleanup when a process terminates. With pthread_atfork you supply three separate handler addresses. The <i>prepare</i> fork handler is called before the fork takes place in the parent process. The <i>parent</i> fork handler is called after the fork in the parent process, and the <i>child</i> fork handler is called after the fork in the child process.</p>
<p class=book>|If you write a subsystem that uses mutexes and does not establish fork handlers,then that subsystem will not function correctly in a child process after a fork.</p>
<p class=book>Normally a <i>prepare</i> fork handler locks all mutexes used by the associated code (for a library or an application) in the correct order to prevent deadlocks. The thread calling fork will <i>block</i> in the <i>prepare</i> fork handler until it has locked all the mutexes. That ensures that no other threads can have the mutexes locked or be modifying data that the child might need. The <i>parent</i> fork handler need only unlock all of those mutexes, allowing the parent process and all threads to continue normally.</p>
<p class=book>The <i>child</i> fork handler may often be the same as the <i>parent</i> fork handler; but sometimes you'll need to reset the program or library state. For example, if you use "daemon" threads to perform functions in the background you'll need to either record the fact that those threads no longer exist or create new threads to perform the same function in the child. You may need to reset counters, free heap memory, and so forth.</p>
<p class=book>Your fork handlers are only as good as everyone else's fork handlers.</p>
<p class=book>The system will run all <i>prepare</i> fork handlers declared in the process when any thread calls fork. If you code your <i>prepare</i> and <i>child</i> fork handlers correctly then, in principle, you will be able to continue operating in the child process. But what if someone else didn't supply fork handlers or didn't do it right? The ANSI C library on a threaded system, for example, must use a set ofmutexes to synchronize internal data, such as <i>stdio</i> file streams.</p>
<p class=book>If you use an ANSI C library that doesn't supply fork handlers to prepare those mutexes properly for a fork, for example, then, sometimes, you may find that</p>
<p class=book>your child process hangs when it calls printf, because another thread in the parent process had the mutex locked when your thread called fork. There's often nothing you can do about this type of problem except to file a problem report against the system. These mutexes are usually private to the library, and aren't visible to your code — you can't lock them in your <i>prepare</i> handler or before calling fork.</p>
<p class=book>The program atfork.c shows the use of fork handlers. When run with no argument, or with a nonzero argument, the program will install fork handlers. When run with a zero argument, such as atfork 0, it will not.</p>
<p class=book>With fork handlers installed, the result will be two output lines reporting the result of the fork call and, in parentheses, the pid of the current process. Without fork handlers, the child process will be created while the initial thread owns the mutex. Because the initial thread does not exist in the child, the mutex cannot be unlocked, and the child process will hang — only the parent process will print its message.</p>
<p class=book>13-25 Function fork_prepare is the <i>prepare</i> handler. This will be called by fork, in the parent process, before creating the child process. Any state changed by this function, in particular, mutexes that are locked, will be copied into the child process. The fork_prepare function locks the program's mutex.</p>
<p class=book>31-42 Function fork_parent is the <i>parent</i> handler. This will be called by fork, in the parent process, after creating the child process. In general, a <i>parent</i> handler should undo whatever was done in the <i>prepare</i> handler, so that the parent process can continue normally. The fork_parent function unlocks the mutex that was locked by fork_prepare.</p>
<p class=book>48-60 Function fork_child is the <i>child</i> handler. This will be called by fork, in the child process. In most cases, the <i>child</i> handler will need to do whatever was done in the fork_parent handler to "unlock" the state so that the child can continue. It may also need to perform additional cleanup, for example, fork_child sets the self_pid variable to the child process's pid as well as unlocking the process mutex.</p>
<p class=book>65-91 After creating a child process, which will continue executing the thread_ routine code, the thread_routine function locks the mutex. When run with fork handlers, the fork call will be blocked (when the <i>prepare</i> handler locks the mutex) until the mutex is available. Without fork handlers, the thread will fork before main unlocks the mutex, and the thread will hang in the child at this point. 99-106 The main program declares fork handlers unless the program is run with an argument of 0.</p>
<p class=book>108-123 The main program locks the mutex before creating the thread that will fork. It then sleeps for several seconds, to ensure that the thread will be able to call fork while the mutex is locked, and then unlocks the mutex. The thread running thread_routine will always succeed in the parent process, because it will simply block until main releases the lock.</p>
<p class=book>However, without the fork handlers, the child process will be created while the mutex is locked. The thread (main) that locked the mutex does not exist in the child, and cannot unlock the mutex in the child process. Mutexes can be unlocked</p>
<p class=book>in the child only if they were locked by the thread that called fork — and fork handlers provide the best way to ensure that.</p>
<p class=book>■ <b>atfork.c</b></p>
<p class=book><CODE>1 #include &lt;sys/types.h&gt;</CODE></p>
<p class=book><CODE>2 #include &lt;pthread.h&gt;</CODE></p>
<p class=book><CODE>3 #include &lt;sys/wait.h&gt;</CODE></p>
<p class=book><CODE>4 #include "errors.h"</CODE> </p>
<p class=book><CODE>5</CODE></p>
<p class=book><CODE>6 pid_t self_pid; /* pid of current process */</CODE></p>
<p class=book><CODE>7 pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;</CODE> </p>
<p class=book><CODE>8</CODE></p>
<p class=book><CODE>9 /*</CODE></p>
<p class=book><CODE>10 * This routine will be called prior to executing the fork,</CODE></p>
<p class=book><CODE>11 * within the parent process.</CODE></p>
<p class=book><CODE>12 */</CODE></p>
<p class=book><CODE>13 void fork_prepare (void)</CODE></p>
<p class=book><CODE>14 {</CODE></p>
<p class=book><CODE>15 int status;</CODE> </p>
<p class=book><CODE>16</CODE></p>
<p class=book><CODE>17 /*</CODE></p>
<p class=book><CODE>18 * Lock the mutex in the parent before creating the child,</CODE></p>
<p class=book><CODE>19 * to ensure that no other thread can lock it (or change any</CODE></p>
<p class=book><CODE>20 * associated shared state) until after the fork completes.</CODE></p>
<p class=book><CODE>21 */</CODE></p>
<p class=book><CODE>22 status = pthread_mutex_lock (&mutex);</CODE></p>
<p class=book><CODE>23 if (status != 0)</CODE></p>
<p class=book><CODE>24 err_abort (status, "Lock in prepare handler");</CODE></p>
<p class=book><CODE>25 }</CODE> </p>
<p class=book><CODE>26</CODE></p>
<p class=book><CODE>27 /*</CODE></p>
<p class=book><CODE>28 * This routine will be called after executing the fork, within</CODE></p>
<p class=book><CODE>29 * the parent process</CODE></p>
<p class=book><CODE>30 */</CODE></p>
<p class=book><CODE>31 void fork_parent (void)</CODE></p>
<p class=book><CODE>32 {</CODE></p>
<p class=book><CODE>33 int status;</CODE> </p>
<p class=book><CODE>34</CODE></p>
<p class=book><CODE>35 /*</CODE></p>
<p class=book><CODE>36 * Unlock the mutex in the parent after the child has been</CODE></p>
<p class=book><CODE>37 * created.</CODE></p>
<p class=book><CODE>38 */</CODE></p>
<p class=book><CODE>39 status = pthread_mutex_unlock (&mutex);</CODE></p>
<p class=book><CODE>40 if (status != 0)</CODE></p>
<p class=book><CODE>41 	err_abort (status, "Unlock in parent handler");</CODE></p>
<p class=book><CODE>42 }</CODE> </p>
<p class=book><CODE>43</CODE></p>
<p class=book><CODE>44 /*</CODE></p>
<p class=book><CODE>45 * This routine will be called after executing the fork, within</CODE></p>
<p class=book><CODE>46 * the child process.</CODE></p>
<p class=book><CODE>47 */</CODE></p>
<p class=book><CODE>48 void fork_child (void)</CODE></p>
<p class=book><CODE>49 {</CODE></p>
<p class=book><CODE>50 int status; 51</CODE></p>
<p class=book><CODE>52 /*</CODE></p>
<p class=book><CODE>53 * Update the file scope "self_pid" within the child process, and</CODE></p>
<p class=book><CODE>54 * unlock the mutex.</CODE></p>
<p class=book><CODE>55 */</CODE></p>
<p class=book><CODE>56 self_pid = getpid ();</CODE></p>
<p class=book><CODE>57 status = pthread_mutex_unlock (&mutex);</CODE></p>
<p class=book><CODE>58 if (status != 0)</CODE></p>
<p class=book><CODE>59 err_abort (status, "Unlock in child handler");</CODE></p>
<p class=book><CODE>60 }</CODE> </p>
<p class=book><CODE>61</CODE></p>
<p class=book><CODE>62 /*</CODE></p>
<p class=book><CODE>63 * Thread start routine, which will fork a new child process.</CODE></p>
<p class=book><CODE>64 */</CODE></p>
<p class=book><CODE>65 void *thread_routine (void *arg)</CODE></p>
<p class=book><CODE>66 {</CODE></p>
<p class=book><CODE>67 pid_t child_pid;</CODE></p>
<p class=book><CODE>68 int status;</CODE> </p>
<p class=book><CODE>69</CODE></p>
<p class=book><CODE>70 child_pid = fork ( );</CODE></p>
<p class=book><CODE>71 if (child_pid == (pid_t)-l)</CODE></p>
<p class=book><CODE>72 errno_abort ("Fork");</CODE></p>
<p class=book><CODE>73</CODE></p>
<p class=book><CODE>74 /*</CODE></p>
<p class=book><CODE>75 * Lock the mutex — without the atfork handlers, the mutex will</CODE></p>
<p class=book><CODE>76 * remain locked in the child process and this lock attempt will</CODE></p>
<p class=book><CODE>77 * hang (or fail with EDEADLK) in the child.</CODE></p>
<p class=book><CODE>78 */</CODE></p>
<p class=book><CODE>79 status = pthread_mutex_lock (&mutex);</CODE></p>
<p class=book><CODE>80 if (status != 0)</CODE></p>
<p class=book><CODE>81 	err_abort (status, "Lock in child");</CODE></p>
<p class=book><CODE>82 status = pthread_mutex_unlock (&mutex);</CODE></p>
<p class=book><CODE>83 if (status != 0)</CODE></p>
<p class=book><CODE>84 	err_abort (status, "Unlock in child");</CODE></p>
<p class=book><CODE>85 printf ("After fork: %d (%d)\n", child_pid, self_pid);</CODE></p>
<p class=book><CODE>86 if (child_pid != 0) {</CODE></p>
<p class=book><CODE>87 if ((pid_t)-l == waitpid (child_pid, (int<b>*)0, 0))</b></CODE></p>
<p class=book><CODE>88 errno_abort ("Wait for child");</CODE></p>
<p class=book><CODE>89 }</CODE></p>
<p class=book><CODE>90 return NULL;</CODE></p>
<p class=book><CODE>91 }</CODE> </p>
<p class=book><CODE>92</CODE></p>
<p class=book><CODE>93 int main (int argc, char *argv[])</CODE></p>
<p class=book><CODE>94 {</CODE></p>
<p class=book><CODE>95	pthread_t fork_thread;	</CODE></p>
<p class=book><CODE>96	int atfork_flag = 1;	</CODE></p>
<p class=book><CODE>97	int status;	</CODE></p>
<p class=book><CODE>98</CODE> </p>
<p class=book><CODE>99	if (argc &gt; 1)	</CODE></p>
<p class=book><CODE>100	atfork_flag = atoi (argv[l]);	</CODE></p>
<p class=book><CODE>101	if (atfork_flag) {	</CODE></p>
<p class=book><CODE>102	status = pthread_atfork (	</CODE></p>
<p class=book><CODE>103	fork_prepare, fork_parent, fork_child);	</CODE></p>
<p class=book><CODE>104	if (status != 0)	</CODE></p>
<p class=book><CODE>105	err_abort (status, "Register fork handlers");</CODE></p>
<p class=book><CODE>106	<b>}	</b></CODE></p>
<p class=book><CODE>107	self_pid = getpid ();	</CODE></p>
<p class=book><CODE>108	status = pthread_mutex_lock (&mutex);	</CODE></p>
<p class=book><CODE>109	if (status != 0)	</CODE></p>
<p class=book><CODE>110	err_abort (status, "Lock mutex");	</CODE></p>
<p class=book><CODE>111	/*	</CODE></p>
<p class=book><CODE>112	* Create a thread while the mutex is locked. It	will fork a</CODE></p>
<p class=book><CODE>113	* process, which (without atfork handlers) will	run with the</CODE></p>
<p class=book><CODE>114	* mutex locked.	</CODE></p>
<p class=book><CODE>115	*/	</CODE></p>
<p class=book><CODE>116	status = pthread_create (	</CODE></p>
<p class=book><CODE>117	&fork_thread, NULL, thread_routine, NULL);	</CODE></p>
<p class=book><CODE>118	if (status != 0)	</CODE></p>
<p class=book><CODE>119	err_abort (status, "Create thread");	</CODE></p>
<p class=book><CODE>120	sleep (5);	</CODE></p>
<p class=book><CODE>121	status = pthread_mutex_unlock (&mutex);	</CODE></p>
<p class=book><CODE>122	if (status != 0)	</CODE></p>
<p class=book><CODE>123	err_abort (status, "Unlock mutex");	</CODE></p>
<p class=book><CODE>124	status = pthread_join (fork_thread, NULL);	</CODE></p>
<p class=book><CODE>125	if (status != 0)	</CODE></p>
<p class=book><CODE>126	err_abort (status, "Join thread");	</CODE></p>
<p class=book><CODE>127	return 0;	</CODE></p>
<p class=book><CODE>128 }		</CODE></p>
<p class=book>■ <b>atfork.c</b></p>
<p class=book>Now, imagine you are writing a library that manages network server connections, and you create a thread for each network connection that listens for service requests. In your <i>prepare</i> fork handler you lock all of the library's mutexes to make sure the child's state is consistent and recoverable. In your <i>parent</i> fork handler you unlock those mutexes and return. When designing the child fork handler, you need to decide exactly what a fork means to your library. If you want to retain all network connections in the child, then you would create a new listener thread for each connection and record their identifiers in the appropriate data structures before releasing the mutexes. If you want the child to begin with no open connections, then you would locate the existing parent connection data structures and free them, closing the associated files that were propagated by fork.</p>



<a name=t96></a><h3 class=book>
6.2 exec
</h3>
<p class=book>The exec function isn't affected much by the presence of threads. The function of exec is to wipe out the current program context and replace it with a new program. A call to exec immediately terminates all threads in the process except the thread calling exec. They do not execute cleanup handlers or thread-specific data destructors — the threads simply cease to exist.</p>
<p class=book>All synchronization objects also vanish, except for <i>pshared</i> mutexes (mutexes created using the PTHREAD_PROCESS_SHARED attribute value) and <i>pshared</i> condition variables, which remain usable as long as the shared memory is mapped by some process. You should, however, unlock any <i>pshared</i> mutexes that the current process may have locked — the system will not unlock them for you.</p>


<a name=t97></a><h3 class=book>
6.3 Process exit
</h3>
<p class=book>In a nonthreaded program, an explicit call to the exit function has the same effect as returning from the program's main function. The process exits. Pthreads adds the pthread_exit function, which can be used to cause a single thread to exit while the process continues. In a threaded program, therefore, you call exit when you want the process to exit, or pthread_exit when you want only the calling thread to exit.</p>
<p class=book>In a threaded program, main is effectively the "thread start function" for the process's initial thread. Although returning from the start function of any other thread terminates that thread just as if it had called pthread_exit, returning from main terminates the <i>process.</i> All memory (and threads) associated with the process evaporate. Threads do not run cleanup handlers or thread-specific data destructors. Calling exit has the same effect.</p>
<p class=book>When you don't want to make use of the initial thread or make it wait for other threads to complete, you can exit from main by calling pthread_exit rather than by returning or calling exit. Calling pthread_exit from main will terminate the initial thread without affecting the other threads in the process, allowing them to continue and complete normally.</p>
<p class=book>The exit function provides a simple way to shut down the entire process. For example, if a thread determines that data has been severely corrupted by some error, it may be dangerous to allow the program to continue to operate on the data. When the program is somehow broken, it might be dangerous to attempt to shut down the application threads cleanly. In that case, you might call exit to stop all processing immediately.</p>


<a name=t98></a><h3 class=book>
6.4 <i>Stdio</i>
</h3>

<p class=book>Pthreads specifies that the ANSI C standard I/O <i>(stdio)</i> functions are thread-safe. Because the <i>stdio</i> package requires static storage for output buffers and file</p>
<p class=book>state, <i>stdio</i> implementations will use synchronization, such as mutexes or semaphores.</p>


<a name=t99></a><h3 class=book>
6.4.1 flockfile and funlockfile
</h3>
<p class=book><b>void flockfile (FILE *file);</b> </p>
<p class=book><b>int ftrylockfile (FILE *file);</b> </p>
<p class=book><b>void funlockfile (FILE *file);</b></p>
<p class=book>In some cases, it is important that a sequence of <i>stdio</i> operations occur in uninterrupted sequence; for example, a prompt followed by a read from the terminal, or two writes that need to appear together in the output file even if another thread attempts to write data between the two <i>stdio</i> calls. Therefore, Pthreads adds a mechanism to lock a file and specifies how file locking interacts with internal <i>stdio</i> locking. To write a prompt string to stdin and read a response from stdout without allowing another thread to read from stdin or write to stdout between the two, you would need to lock both stdin and stdout around the two calls as shown in the following program, flock.c. <b>19-20</b> This is the important part: Two separate calls to flockfile are made, one for each of the two file streams. To avoid possible deadlock problems within <i>stdio,</i> Pthreads recommends always locking input streams before output streams, when you must lock both. That's good advice, and I've taken it by locking stdin before stdout.</p>
<p class=book>29-30 The two calls to funlockfile must, ofcourse, be made in the opposite order. Despite the specialized call, you are effectively locking mutexes within the <i>stdio</i> library, and you should respect a consistent lock hierarchy.</p>
<p class=book>■ <b>flock.c</b></p>
<p class=book><CODE>1 #include &lt;pthread.h&gt;</CODE></p>
<p class=book><CODE>2 #include "errors.h"</CODE> </p>
<p class=book><CODE>3</CODE></p>
<p class=book><CODE>4 /*</CODE></p>
<p class=book><CODE>5 * This routine writes a prompt to stdout (passed as the thread's</CODE></p>
<p class=book><CODE>6 * "arg"), and reads a response. All other I/O to stdin and stdout</CODE></p>
<p class=book><CODE>7 * is prevented by the file locks until both prompt and fgets are</CODE></p>
<p class=book><CODE>8 * complete.</CODE></p>
<p class=book><CODE>9 */</CODE></p>
<p class=book><CODE>10 void *prompt_routine (void *arg)</CODE></p>
<p class=book><CODE>11 {</CODE></p>
<p class=book><CODE>12 char *prompt = (char*)arg;</CODE></p>
<p class=book><CODE>13 char *string;</CODE></p>
<p class=book><CODE>14 int len;</CODE> </p>
<p class=book><CODE>15</CODE></p>
<p class=book><CODE>16 string = (char*)malloc (128);</CODE></p>
<p class=book><CODE>17 if (string == NULL)</CODE></p>
<p class=book><CODE>18 	errno_abort ("Alloc string");</CODE></p>
<p class=book><CODE>19 flockfile (stdin);</CODE></p>
<p class=book><CODE>20 flockfile (stdout);</CODE></p>
<p class=book><CODE>21 printf (prompt);</CODE></p>
<p class=book><CODE>22 if (fgets (string, 128, stdin) == NULL)</CODE></p>
<p class=book><CODE>23 	string[0] = '\0' ;</CODE></p>
<p class=book><CODE>24 else {</CODE></p>
<p class=book><CODE>25 	len = strlen (string);</CODE></p>
<p class=book><CODE>26 	if (len &gt; 0 && string[len-l] == '\n')</CODE></p>
<p class=book><CODE>27 		string[len-l] = '\0';</CODE></p>
<p class=book><CODE>28 	}</CODE></p>
<p class=book><CODE>29 funlockfile (stdout);</CODE></p>
<p class=book><CODE>30 funlockfile (stdin);</CODE></p>
<p class=book><CODE>31 return (void*)string;</CODE></p>
<p class=book><CODE>32 }</CODE> </p>
<p class=book><CODE>33</CODE></p>
<p class=book><CODE>34 int main (int argc, char *argv[])</CODE></p>
<p class=book><CODE>35 {</CODE></p>
<p class=book><CODE>36 pthread_t threadl, thread2, thread3;</CODE></p>
<p class=book><CODE>37 char *string;</CODE></p>
<p class=book><CODE>38 int status;</CODE> </p>
<p class=book><CODE>39</CODE></p>
<p class=book><CODE>40 #ifdef sun</CODE></p>
<p class=book><CODE>41 /*</CODE></p>
<p class=book><CODE>42 * On Solaris 2.5, threads are not timesliced. To ensure</CODE></p>
<p class=book><CODE>43 * that our threads can run concurrently, we need to</CODE></p>
<p class=book><CODE>44 * increase the concurrency level.</CODE></p>
<p class=book><CODE>45 */</CODE></p>
<p class=book><CODE>46 DPRINTF (("Setting concurrency level to 4\n"));</CODE></p>
<p class=book><CODE>47 thr_setconcurrency (4);</CODE></p>
<p class=book><CODE>48 #endif</CODE></p>
<p class=book><CODE>49 status = pthread_create (</CODE></p>
<p class=book><CODE>50 &threadl, NULL, prompt_routine, "Thread 1&gt; ");</CODE></p>
<p class=book><CODE>51 if (status != 0)</CODE></p>
<p class=book><CODE>52 	err_abort (status, "Create thread");</CODE></p>
<p class=book><CODE>53 status = pthread_create (</CODE></p>
<p class=book><CODE>54 	&thread2, NULL, prompt_routine, "Thread 2&gt; ");</CODE></p>
<p class=book><CODE>55 if (status != 0)</CODE></p>
<p class=book><CODE>56 	err_abort (status, "Create thread");</CODE></p>
<p class=book><CODE>57 status = pthread_create (</CODE></p>
<p class=book><CODE>58 	&thread3, NULL, prompt_routine, "Thread 3&gt; ");</CODE></p>
<p class=book><CODE>59 if (status != 0)</CODE></p>
<p class=book><CODE>60 	err_abort (status, "Create thread");</CODE></p>
<p class=book><CODE>61 status = pthread_join (threadl, (void**)&string);</CODE></p>
<p class=book><CODE>62 if (status != 0)</CODE></p>
<p class=book><CODE>63 	err_abort (status, "Join thread");</CODE></p>
<p class=book><CODE>64 printf ("Thread 1: \"%s\"\n", string);</CODE></p>
<p class=book><CODE>65 free (string);</CODE></p>
<p class=book><CODE>66 status = pthread_join (thread2, (void**)&string);</CODE></p>
<p class=book><CODE>67 if (status != 0)	</CODE></p>
<p class=book><CODE>68 err_abort (status,	"Join thread");</CODE></p>
<p class=book><CODE>69 printf ("Thread 1: \"%	s\"\n", string);</CODE></p>
<p class=book><CODE>70 free (string);	</CODE></p>
<p class=book><CODE>71 status = pthread_join	(thread3, (void**)&string);</CODE></p>
<p class=book><CODE>72 if (status != 0)	</CODE></p>
<p class=book><CODE>73 err_abort (status,	"Join thread");</CODE></p>
<p class=book><CODE>74 printf ("Thread 1: \"%	s\"\n", string);</CODE></p>
<p class=book><CODE>75 free (string);	</CODE></p>
<p class=book><CODE>76 return 0;	</CODE></p>
<p class=book><CODE>77 }		</CODE></p>
<p class=book>You can also use the flockfile and funlockfile functions to ensure that a series of writes is not interrupted by a file access from some other thread. The ftrylockfile function works like pthread_mutex_trylock in that it attempts to lock the file and, if the file is already locked, returns an error status instead of blocking.</p>


<a name=t100></a><h3 class=book>
6.4.2 getchar unlocked and putchar unlocked
</h3>
<p class=book><b>int getc_unlocked (FILE *stream);</b></p>
<p class=book><b>int getchar_unlocked (void);</b></p>
<p class=book><b>int putc_unlocked (int c, FILE *stream);</b></p>
<p class=book><b>int putchar_unlocked (int c);</b></p>
<p class=book>ANSI C provides functions to get and put single characters efficiently into <i>stdio</i> buffers. The functions <CODE>getchar</CODE> and <CODE>putchar</CODE> operate on <CODE>stdin</CODE> and <CODE>stdout</CODE>, respectively, and <CODE>getc</CODE> and <CODE>putc</CODE> can be used on any <i>stdio</i> file stream. These are traditionally implemented as macros for maximum performance, directly reading or writing the file stream's data buffer. Pthreads, however, requires these functions to lock the <i>stdio</i> stream data, to prevent code from accidentally corrupting the <i>stdio</i> buffers.</p>
<p class=book>The overhead of locking and unlocking mutexes will probably vastly exceed the time spent performing the character copy, so these functions are no longer high performance. Pthreads could have defined new functions that provided the locked variety rather than redefining the existing functions; however, the result would be that existing code would be unsafe for use in threads. The working group decided that it was preferable to make existing code slower, rather than to make it incorrect.</p>
<p class=book>Pthreads adds new functions that replace the old high-performance macros with essentially the same implementation as the traditional macros. The functions <CODE>getc_unlocked</CODE>, <CODE>putc_unlocked</CODE>, <CODE>getchar_unlocked</CODE>, and <CODE>putchar_unlocked</CODE> do not perform any locking, so you must use <CODE>flockfile</CODE> and <CODE>funlockfile</CODE> around any sequence of these operations. If you want to read or write a single character, you should usually use the locked variety rather than locking the file stream, calling the new unlocked get or put function, and then unlocking the file stream.</p>
<p class=book>If you want to perform a sequence of fast character accesses, where you would have previously used getchar and putchar, you can now use getchar_unlocked and putchar_unlocked. The following program, putchar.c, shows the difference between using putchar and using a sequence of putchar_unlocked calls within a file lock.</p>
<p class=book><b>9-20</b> When the program is run with a nonzero argument or no argument at all, it creates threads running the lock_routine function. This function locks the stdout file stream, and then writes its argument (a string) to stdout one character at a time using putchar_unlocked. </p>
<p class=book><b>28-37</b> When the program is run with a zero argument, it creates threads running the unlock_routine function. This function writes its argument to stdout one character at a time using putchar. Although putchar is internally synchronized to ensure that the <i>stdio</i> buffer is not corrupted, the individual characters may appear in any order.</p>
<p class=book>■ <b>putchar.c</b></p>
<p class=book><CODE>1 #include &lt;pthread.h&gt;</CODE></p>
<p class=book><CODE>2 #include "errors.h"</CODE> </p>
<p class=book><CODE>3</CODE></p>
<p class=book><CODE>4 /*</CODE></p>
<p class=book><CODE>5 * This function writes a string (the function's arg) to stdout,</CODE></p>
<p class=book><CODE>6 * by locking the file stream and using putchar_unlocked to write</CODE></p>
<p class=book><CODE>7 * each character individually.</CODE></p>
<p class=book><CODE>8 */</CODE></p>
<p class=book><CODE>9 void *lock_routine (void *arg)</CODE></p>
<p class=book><CODE>10 {</CODE></p>
<p class=book><CODE>11 char *pointer;</CODE> </p>
<p class=book><CODE>12</CODE></p>
<p class=book><CODE>13 flockfile (stdout);</CODE></p>
<p class=book><CODE>14 for (pointer = arg; *pointer != '\0'; pointer++) {</CODE></p>
<p class=book><CODE>15 	putchar_unlocked (*pointer);</CODE></p>
<p class=book><CODE>16 	sleep (1);</CODE></p>
<p class=book><CODE>17 }</CODE></p>
<p class=book><CODE>18 funlockfile (stdout);</CODE></p>
<p class=book><CODE>19 return NULL;</CODE></p>
<p class=book><CODE>20 }</CODE> </p>
<p class=book><CODE>21</CODE></p>
<p class=book><CODE>22 /*</CODE></p>
<p class=book><CODE>23 * This function writes a string (the function's arg) to stdout,</CODE></p>
<p class=book><CODE>24 * by using putchar to write each character individually.</CODE></p>
<p class=book><CODE>25 * Although the internal locking of putchar prevents file stream</CODE></p>
<p class=book><CODE>26 * corruption, the writes of various threads may be interleaved.</CODE></p>
<p class=book><CODE>27 */</CODE></p>
<p class=book><CODE>28 void *unlock_routine (void *arg)</CODE></p>
<p class=book><CODE>29 {</CODE></p>
<p class=book><CODE>30 char *pointer;</CODE> </p>
<p class=book><CODE>31</CODE></p>
<p class=book><CODE>32 for (pointer = arg; *pointer != '\0'; pointer++) {</CODE></p>
<p class=book><CODE>33 	putchar (*pointer);</CODE></p>
<p class=book><CODE>34 	sleep (1);</CODE></p>
<p class=book><CODE>35 }</CODE></p>
<p class=book><CODE>36 return NULL;</CODE></p>
<p class=book><CODE>37 }</CODE> </p>
<p class=book><CODE>38</CODE></p>
<p class=book><CODE>39 int main (int argc, char *argv[])</CODE></p>
<p class=book><CODE>40 {</CODE></p>
<p class=book><CODE>41 	pthread_t thread1, thread2, thread3;</CODE></p>
<p class=book><CODE>42 	int flock_flag = 1;</CODE></p>
<p class=book><CODE>43 	void *(*thread_func)(void *);</CODE></p>
<p class=book><CODE>44 	int status; 	</CODE></p>
<p class=book><CODE>45</CODE></p>
<p class=book><CODE>46 	if (argc &gt; 1)</CODE></p>
<p class=book><CODE>47 		flock_flag = atoi (argv[l]);</CODE></p>
<p class=book><CODE>48 	if (flock_flag)</CODE></p>
<p class=book><CODE>49 		thread_func = lock_routine;</CODE></p>
<p class=book><CODE>50 	else</CODE></p>
<p class=book><CODE>51 		thread_func = unlock_routine;</CODE></p>
<p class=book><CODE>52 	status = pthread_create (</CODE></p>
<p class=book><CODE>53 		&thread1, NULL, thread_func, "this is thread 1\n");</CODE></p>
<p class=book><CODE>54 	if (status != 0)</CODE></p>
<p class=book><CODE>55 		err_abort (status, "Create thread");</CODE></p>
<p class=book><CODE>56 	status = pthread_create (</CODE></p>
<p class=book><CODE>57 		&thread2, NULL, thread_func, "this is thread 2\n");</CODE></p>
<p class=book><CODE>58 	if (status != 0)</CODE></p>
<p class=book><CODE>59 		err_abort (status, "Create thread");</CODE></p>
<p class=book><CODE>60 	status = pthread_create (</CODE></p>
<p class=book><CODE>61 		&thread3, NULL, thread_func, "this is thread 3\n");</CODE></p>
<p class=book><CODE>62 	if (status != 0)</CODE></p>
<p class=book><CODE>63 		err_abort (status, "Create thread");</CODE></p>
<p class=book><CODE>64 	pthread_exit (NULL);</CODE></p>
<p class=book><CODE>65 }</CODE></p>



<a name=t101></a><h3 class=book>
6.5 Thread-safe functions
</h3>

<p class=book>Although ANSI C and POSIX 1003.1-1990 were not developed with threads in mind, most of the functions they define can be made thread-safe without changing the external interface. For example, although malloc and free must be changed to support threads, code calling these functions need not be aware of the changes. When you call malloc, it locks a mutex (or perhaps several mutexes) to perform the operation, or may use other equivalent synchronization mechanisms. But your code just calls malloc as it always has, and it does the same thing as always.</p>
<p class=book>In two main classes of functions, this is not true:</p>
<p class=book>• Functions that traditionally return pointers to internal static buffers, for example, asctime. An internal mutex wouldn't help, since the caller will read the formatted time string some time after the function returns and, therefore, after the mutex has been unlocked.</p>
<p class=book>• Functions that require static context between a series of calls, for example, strtok, which stores the current position within the token string in a local static variable. Again, using a mutex within strtok wouldn't help, because other threads would be able to overwrite the current location between two calls.</p>
<p class=book>In these cases, Pthreads has defined variants of the existing functions that are thread-safe, which are designated by the suffix "_r" at the end of the function name. These variants move context outside the library, under the caller's control. When each thread uses a private buffer or context, the functions are thread-safe. You can also share context between threads if you want — but the caller must provide synchronization between the threads. If you want two threads to search a directory in parallel, you must synchronize their use of the shared struct dirent passed to readdir_r.</p>
<p class=book>A few existing functions, such as ctermid, are already thread-safe as long as certain restrictions are placed on parameters. These restrictions are noted in the following sections.</p>


<a name=t102></a><h3 class=book>
6.5.1 User and terminal identification
</h3>
<p class=book><b>int getlogin_r (char *name, size_t namesize);</b></p>
<p class=book><b>char *ctermid (char *s);</b> </p>
<p class=book><b>int ttyname_r (int fildes, char *name, size_t namesize);</b></p>
<p class=book>These functions return data to a caller-specified buffer. For <CODE>getlogin_r</CODE>, <CODE>namesize</CODE> must be at least LOGIN_NAME_MAX characters. For <CODE>ttyname_r</CODE>, <CODE>namesize</CODE> must be at least TTY_NAME_MAX characters. Either function returns a value of 0 on success, or an error number on failure. In addition to errors that might be returned by <CODE>getlogin</CODE> or <CODE>ttyname</CODE>, <CODE>getlogin_r</CODE> and <CODE>ttyname_r</CODE> may return ERANGE to indicate that the name buffer is too small.</p>
<p class=book>Pthreads requires that when <CODE>ctermid</CODE> (which has not changed) is used in a threaded environment, the <CODE>s</CODE> return argument must be specified as a pointer to a character buffer having at least <CODE>L_ctermid</CODE> bytes. It was felt that this restriction was sufficient, without defining a new variant to also specify the size of the buffer. Program <CODE>getlogin.c</CODE> shows how to call these functions. Notice that these functions do not depend on threads, or &lt;pthread.h&gt;, in any way, and may even be provided on systems that don't support threads.</p>
<p class=book>■ <b>getlogin.c</b></p>
<p class=book><CODE>1 #include &lt;limits.h&gt;</CODE></p>
<p class=book><CODE>2 #include "errors.h"</CODE> </p>
<p class=book><CODE>3</CODE></p>
<p class=book><CODE>4 /*</CODE></p>
<p class=book><CODE>5 * If either TTY_NAME_MAX or LOGIN_NAME_MAX are undefined</CODE></p>
<p class=book><CODE>6 * (this means they are "indeterminate" values), assume a</CODE></p>
<p class=book><CODE>7 * reasonable size (for simplicity) rather than using sysconf</CODE></p>
<p class=book><CODE>8 * and dynamically allocating the buffers.</CODE></p>
<p class=book><CODE>9 */</CODE></p>
<p class=book><CODE>10 #ifndef TTY_NAME_MAX</CODE></p>
<p class=book><CODE>11 # define TTY_NAME_MAX 128</CODE></p>
<p class=book><CODE>12 #endif</CODE></p>
<p class=book><CODE>13 #ifndef LOGIN_NAME_MAX</CODE></p>
<p class=book><CODE>14 # define LOGIN_NAME_MAX 32</CODE></p>
<p class=book><CODE>15 #endif</CODE> </p>
<p class=book><CODE>16</CODE></p>
<p class=book><CODE>17 int main (int argc, char *argv[])</CODE></p>
<p class=book><CODE>18 {</CODE></p>
<p class=book><CODE>19 char login_str[LOGIN_NAME_MAX];</CODE></p>
<p class=book><CODE>20 char stdin_str[TTY_NAME_MAX];</CODE></p>
<p class=book><CODE>21 char cterm_str[L_ctermid], *cterm_str_ptr;</CODE></p>
<p class=book><CODE>22 int status;</CODE> </p>
<p class=book><CODE>23</CODE></p>
<p class=book><CODE>24 status = getlogin_r (login_str, sizeof (login_str));</CODE></p>
<p class=book><CODE>25 if (status != 0)</CODE></p>
<p class=book><CODE>26 err_abort (status, "Get login");</CODE></p>
<p class=book><CODE>27 cterm_str_ptr = ctermid (cterm_str);</CODE></p>
<p class=book><CODE>28 if (cterm_str_ptr == NULL)</CODE></p>
<p class=book><CODE>29 errno_abort ("Get cterm");</CODE></p>
<p class=book><CODE>30 status = ttyname_r (0, stdin_str, sizeof (stdin_str));</CODE></p>
<p class=book><CODE>31 if (status != 0)</CODE></p>
<p class=book><CODE>32 err_abort (status, "Get stdin");</CODE></p>
<p class=book><CODE>33 printf ("User: %s, cterm: %s, fd 0: %s\n",</CODE></p>
<p class=book><CODE>34 login_str, cterm_str, stdin_str);</CODE></p>
<p class=book><CODE>35 return 0;</CODE></p>


<a name=t103></a><h3 class=book>
<b>6.5.2 Directory searching</b>
</h3>
<p class=book><b>int readdir_r (DIR *dirp, struct dirent *entry, struct dirent **result);</b></p>
<p class=book>This function performs essentially the same action as readdir. That is, it returns the next directory entry in the directory stream specified by dirp. The difference is that instead of returning a pointer to that entry, it copies the entry into the buffer specified by entry. On success, it returns 0 and sets the pointer specified by result to the buffer entry. On reaching the end of the directory stream, it returns 0 and sets result to NULL. On failure, it returns an error number such as</p>
<p class=book>EBADF.</p>
<p class=book>Refer to program pipe .c, in Section 4.1, for a demonstration of using readdir_r to allow your threads to search multiple directories concurrently.</p>


<a name=t104></a><h3 class=book>
6.5.3 String token
</h3>
<p class=book><b>char *strtok_r ( char *s, const char *sep, char **lasts);</b></p>
<p class=book>This function returns the next token in the string s. Unlike strtok, the context (the current pointer within the original string) is maintained in lasts, which is specified by the caller, rather than in a static pointer internal to the function.</p>
<p class=book>In the first call of a series, the argument s gives a pointer to the string. In subsequent calls to return successive tokens of that string, s must be specified as NULL. The value lasts is set by strtok_r to maintain the function's position within the string, and on each subsequent call you must return that same value of lasts. The strtok_r function returns a pointer to the next token, or NULL when there are no more tokens to be found in the original string.</p>


<a name=t105></a><h3 class=book>
6.5.4 Time representation
</h3>
<p class=book><b>char *asctime_r (const struct tm *tm, char *buf);</b> </p>
<p class=book><b>char *ctime_r (const time_t *clock, char *buf);</b> </p>
<p class=book><b>struct tm *gmtime_r (const time_t *clock, struct tm *result);</b></p>
<p class=book><b>struct tm *localtime_r (const time_t *clock, struct tm *result);</b></p>
<p class=book>The output buffers (buf and result) are supplied by the caller, instead of returning a pointer to static storage internal to the functions. Otherwise, they are identical to the traditional variants. The asctime_r and ctime_r routines, which return ASCII character representations of a system time, both require that their buf argument point to a character string of at least 26 bytes.</p>


<a name=t106></a><h3 class=book>
6.5.5 Random number generation
</h3>
<p class=book><b>int rand_r (unsigned int *seed);</b></p>
<p class=book>The seed is maintained in caller-supplied storage (seed) rather than using static storage internal to the function. The main problem with this interface is that it is not usually practical to have a single seed shared by all application and library code within a program. As a result, the application and each library will generally have a separate "stream" of random numbers. Thus, a program converted to use rand_r instead of rand is likely to generate different results, even if no threads are created. (Creating threads would probably change the order of calls to rand, and therefore change results anyway.)</p>


<a name=t107></a><h3 class=book>
6.5.6 Group and user database
</h3>
<p class=book><b>Group database:</b></p>
<p class=book><b>int getgrgid_r (gid_t gid, struct group *grp, char *buffer,</b></p>
<p class=book><b>	size_t bufsize, struct group **result);</b> </p>
<p class=book><b>int getgrnam_r (</b></p>
<p class=book><b>	const char *name, struct group *grp,</b></p>
<p class=book><b>	char *buffer, size_t bufsize,</b></p>
<p class=book><b>	struct group **result);</b></p>
<p class=book><b>User database:</b></p>
<p class=book><b>int getpwuid_r (</b></p>
<p class=book><b>uid_t uid, struct passwd *pwd, char *buffer,</b></p>
<p class=book><b>size_t bufsize, struct passwd **result); int getpwnam_r (</b></p>
<p class=book><b>const char *name, struct passwd *pwd,</b></p>
<p class=book><b>char *buffer, size_t bufsize,</b></p>
<p class=book><b>struct passwd **result);</b></p>
<p class=book>These functions store a copy of the group or user record (grp or pwd, respectively) for the specified group or user (gid, uid, or name) in a buffer designated by</p>
<p class=book>the arguments buffer and bufsize. The function return value is in each case either 0 for success, or an error number (such as ERANGE when the buffer is too small) to designate an error. If the requested record is not present in the group or passwd database, the functions may return success but store the value NULL into the result pointer. If the record is found and the buffer is large enough, result becomes a pointer to the struct group or struct passwd record within buffer.</p>
<p class=book>The maximum required size for buffer can be determined by calling sysconf with the argument _SC_GETGR_R_SIZE_MAX (for group data) or with the argument _SC_GETPW_R_SIZE MAX(for user data).</p>



<a name=t108></a><h3 class=book>
6.6 Signals
</h3>
<blockquote class="epigraph">
<p class=book>Beware the Jabberwock, my son!</p>
<p class=book>The jaws that bite, the claws that catch!</p>
<p class=book>Beware the Jubjub bird, and shun </p>
<p class=book>The frumious Bandersnatch!</p>
<blockquote class=book><i>— <i>Lewis Carroll, Through the Looking-Glass</i></i></blockquote>
</blockquote>

<p class=book>The history of the Pthreads signal-handling model is the most convoluted and confusing part of the standard. There were several different viewpoints, and it was difficult to devise a compromise that would satisfy everyone in the working group (much less the larger and more diverse balloting group). This isn't surprising, since signals are complicated anyway, and have a widely divergent history in the industry.</p>
<p class=book>There were two primary conflicting goals:</p>
<p class=book>• First, "signals should be completely compatible with traditional UNIX." That means signal handlers and masks should remain associated with the process. That makes them virtually useless with multiple threads, which is as it should be since signals have complicating semantics that make it difficult for signals and threads to coexist peacefully. Tasks should be accomplished synchronously using threads rather than asynchronously using signals.</p>
<p class=book>• Second, "signals should be completely compatible with traditional UNIX." This time, "compatible" means signal handlers and masks should be completely thread-private. Most existing UNIX code would then function essentially the same running within a thread as it had within a process. Code migration would be simplified.</p>
<p class=book>The problem is that the definitions of "compatible" were incompatible. Although many people involved in the negotiation may not agree with the final result, nearly everyone would agree that those who devised the compromise did an extraordinarily good job, and that they were quite courageous to attempt the feat.</p>
<p class=book>When writing threaded code,treat signals as Jabberwocks— curious and potentially dangerous creatures to be approached with caution,if at all.</p>
<p class=book>It is always best to avoid using signals in conjunction with threads. At the same time, it is often not possible or practical to keep them separate. When signals and threads meet, beware. If at all possible, use only pthread_sigmask to mask signals in the main thread, and sigwait to handle signals synchronously within a single thread dedicated to that purpose. If you must use sigaction (or equivalent) to handle synchronous signals (such as <b>SIGSEGV</b>) within threads, be especially cautious. Do as little work as possible within the signal-catching function.</p>
<p class=book>All signal actions are process-wide. A program must coordinate any use of sigaction between threads. This is nonmodular, but also relatively simple, and signals have never been modular. A function that dynamically modifies signal actions, for example, to catch or ignore <b>SIGFPE</b> while it performs floating-point operations, or <b>SIGPIPE</b> while it performs network I/O, will be tricky to code on a threaded system.</p>
<p class=book>While modifying the process signal action for a signal number is itself thread-safe, there is no protection against some other thread setting a new signal action immediately afterward. Even if the code tries to be "good" by saving the original signal action and restoring it, it may be foiled by another thread, as shown in Figure 6.1.</p>
<p class=book>Signals that are not "tied" to a specific hardware execution context are delivered to one arbitrary thread within the process. That means a <b>SIGCHLD</b> raised by a child process termination, for example, may not be delivered to the thread that created the child. Similarly, a call to kill results in a signal that may be delivered to any thread.</p>
<p class=book><b>6.6.1 Signal actions</b></p>
<TABLE>
<TR>
<TD align = "left" ><b>Thread 1</b></TD>
<TD align = "left" ><b>Thread 2</b></TD>
<TD align = "left" ><b>Comments</b></TD>
</TR>
<TR>
<TD align = "left" >sigaction(<b>SIGFPE)</b></TD>
<TD></TD>
<TD align = "left" >Thread 1's signal action active.</TD>
</TR>
<TR>
<TD></TD>
<TD align = "left" ><b>sigaction(SIGFPE)</b></TD>
<TD align = "left" > Thread 2's signal action active.</TD>
</TR>
<TR>
<TD align = "left" >Generate <b>SIGFPE</b></TD>
<TD></TD>
<TD align = "left" >Thread 1 signal is handled by the thread 2 signal action (but still in the context of thread 1).</TD>
</TR>
<TR>
<TD align = "left" >Restore action</TD>
<TD></TD>
<TD align = "left" >Thread 1 restores original signal action</TD>
</TR>
<TR>
<TD></TD>
<TD align = "left" >restore action</TD>
<TD align = "left" >Thread 2 restores thread 1 's signal action-original action is lost</TD>
</TR>
</TABLE>
<p class=book> <b>FIGURE 6.1</b> <i>Nonmodularity of signal actions</i></p>
<p class=book>The synchronous "hardware context" signals, including <b>SIGFPE, SIGSEGV,</b> and <b>SIGTRAP,</b> are delivered to the thread that caused the hardware condition, never to another thread.</p>
<p class=book>You cannot kill a thread by sending it a SIGKILL or stop a thread by sending it a SIGSTOR</p>
<p class=book>Any signal that affected a process still affects the process when multiple threads are active, which means that sending a <b>SIGKILL</b> to a process or to any specific thread in the process (using pthread_kill, which we'll get to in Section 6.6.3) will terminate the process. Sending a <b>SIGSTOP</b> will cause all threads to stop until a <b>SIGCONT</b> is received. This ensures that existing process control functions continue to work — otherwise most threads in a process could continue running when you stopped a command by sending a <b>SIGSTOP.</b> This also applies to the default action of the other signals, for example, <b>SIGSEGV,</b> if not handled, will terminate the process and generate a core file — it will not terminate only the thread that generated the <b>SIGSEGV.</b></p>
<p class=book>What does this mean to a programmer? It has always been common wisdom that library code should not change signal actions — that this is exclusively the province of the main program. This philosophy becomes even more wise when you are programming with threads. Signal actions must always be under the control of a single component, at least, and to assign that responsibility to the main program makes the most sense in nearly all situations.</p>


<a name=t109></a><h3 class=book>
6.6.2 Signal masks
</h3>
<p class=book><b>int pthread_sigmask (int how, const sigset_t *set, sigset_t *oset);</b></p>
<p class=book>Each thread has its own private signal mask, which is modified by calling <CODE>pthread_sigmask</CODE>. Pthreads does not specify what <CODE>sigprocmask</CODE> does within a threaded process — it may do nothing. Portable threaded code does not call <CODE>sigprocmask</CODE>. A thread can block or unblock signals without affecting the ability of other threads to handle the signal. This is particularly important for synchronous signals. It would be awkward if thread A were unable to process a <b>SIGFPE</b> because thread B was currently processing its own <b>SIGFPE</b> or. even worse, because thread C had blocked <b>SIGFPE.</b> When a thread is created, it inherits the signal mask of the thread that created it — if you want a signal to be masked everywhere, mask it first thing in main.</p>


<a name=t110></a><h3 class=book>
6.6.3 pthread_kill
</h3>
<p class=book><b>int pthread_kill (pthread_t thread, int sig);</b></p>
<p class=book>Within a process, one thread can send a signal to a specific thread (including itself) by calling <CODE>pthread_kill</CODE>. When calling <CODE>pthread_kill</CODE>, you specify not only the signal number to be delivered, but also the <CODE>pthread_t</CODE> identifier for the thread to which you want the signal sent. You cannot use <CODE>pthread_kill</CODE> to send a signal to a thread in another process, however, because a thread identifier (<CODE>pthread_t</CODE>) is meaningful only within the process that created it.</p>
<p class=book>The signal sent by <CODE>pthread_kill</CODE> is handled like any other signal. If the "target" thread has the signal masked, it will be marked pending against that thread. If the thread is waiting for the signal in <CODE>sigwait</CODE> (covered in Section 6.6.4), the thread will receive the signal. If the thread does not have the signal masked, and is not blocked in <CODE>sigwait</CODE>, the current signal action will be taken.</p>
<p class=book>Remember that, aside from signal-catching functions, signal actions affect the process. Sending the <b>SIGKILL</b> signal to a specific thread using <CODE>pthread_kill</CODE> will kill the process, not just the specified thread. Use <CODE>pthread_cancel</CODE> to get rid of a particular thread (see Section 5.3). Sending <b>SIGSTOP</b> to a thread will stop all threads in the process until a <b>SIGCONT</b> is sent by some other process.</p>
<p class=book>The <CODE>raise</CODE> function specified by ANSI C has traditionally been mapped to a kill for the current process. That is, <CODE>raise(SIGABRT)</CODE> is usually the same as <CODE>kill(getpid (), SIGABRT)</CODE><b>.</b></p>
<p class=book>With multiple threads, code calling raise is most likely to intend that the signal be sent to the calling thread, rather than to some arbitrary thread within the process. Pthreads specifies that raise <b>(SIGABRT)</b> is the same as <CODE>pthread_kill(pthread_self(),SIGABRT)</CODE><b>.</b></p>
<p class=book>The following program, susp.c, uses <CODE>pthread_kill</CODE> to implement a portable "suspend and resume" (or, equivalently, "suspend and continue") capability much like that provided by the Solaris "UI threads" interfaces <CODE>thr_suspend</CODE> and <CODE>thr_continue</CODE><sup><a name=r6><a href="#n6" title="
The algorithm (and most of the code) for susp.c was developed by a coworker of mine, Brian Silver. The code shown here is a simplified version for demonstration purposes.
">[6]</sup></A>. You call the <CODE>thd_suspend</CODE> function with the <CODE>pthread_t</CODE> of a thread, and when the function returns, the specified thread has been <i>suspended</i> from execution. The thread cannot execute until a later call to <CODE>thd_continue</CODE> is made with the same <CODE>pthread_t</CODE>.</p>
<p class=book>A request to suspend a thread that is already suspended has no effect. Calling <CODE>thd_continue</CODE> a single time for a suspended thread will cause it to resume execution, even if it had been suspended by multiple calls to <CODE>thd_suspend</CODE>. Calling <CODE>thd_continue</CODE> for a thread that is not currently suspended has no effect.</p>
<p class=book>Suspend and resume are commonly used to solve some problems, for example, multithread garbage collectors, and may even work sometimes if the programmer is very careful. This emulation of suspend and resume may therefore be valuable to the few programmers who really need these functions. Beware, however, that should you suspend a thread while it holds some resource (such as a mutex), application deadlock can easily result. </p>
<p class=book><b>6</b> The symbol ITERATIONS defines how many times the "target" threads will loop. If this value is set too small, some or all of the threads will terminate before the main thread has been able to suspend and continue them as it desires. If that happens, the program will fail with an error message — increase the value of ITERATIONS until the problem goes away. </p>
<p class=book><b>12</b> The variable sentinel is used to synchronize between a signal-catching function and another thread. "Oh?" you may ask, incredulously. This mechanism is not perfect — the suspending thread (the one calling thd_suspend) waits in a loop, yielding the processor until this sentinel changes state. The volatile storage attribute ensures that the signal-catching function will write the value to memory. Remember, you cannot use a mutex within a signal-catching function. </p>
<p class=book><b>22-40</b> The suspend_signal_handler function will be established as the signal-catching function for the "suspend" signal, SIGUSR1. It initializes a signal mask to block all signals except SIGUSR2, which is the "resume" signal, and then waits for that signal by calling sigsuspend. Just before suspending itself, it sets the sentinel variable to inform the suspending thread that it is no longer executing user code — for most practical purposes, it is already suspended.</p>
<p class=book>The purpose for this synchronization between the signal-catching function and thd_suspend is that, to be most useful, the thread calling thd_suspend must be able to know when the target thread has been successfully suspended. Simply calling pthread_kill is not enough, because the system might not deliver the signal for a substantial period of time; we need to know when the signal has been received.</p>
<p class=book>47-51 The resume_signal_handler function will be established as the signal-catching function for the "resume" signal, <b>SIGUSR1.</b> The function isn't important, since the signal is sent only to interrupt the call to sigsuspend in suspend_signal_handler.</p>
<p class=book>■ <b>susp.c</b> <b>part1 	signal-catching functions</b></p>
<p class=book><CODE>1 #include &lt;pthread.h&gt;</CODE></p>
<p class=book><CODE>2 #include &lt;signal.h&gt;</CODE></p>
<p class=book><CODE>3 #include "errors.h"</CODE></p>
<p class=book><CODE>4</CODE></p>
<p class=book><CODE>5 #define THREAD_COUNT 20</CODE></p>
<p class=book><CODE>6 #define ITERATIONS 40000</CODE></p>
<p class=book><CODE><b>*</b>A semaphore, as described later in Section 6.6.6, would provide cleaner, and somewhat safer, synchronization. The thd_suspend would call sem_wait on a semaphore with an inltial value of 0, and the signal-catching function would call sem_post to wake it.</CODE></p>
<p class=book><CODE>7</CODE></p>
<p class=book><CODE>8 unsigned long thread_count = THREAD_COUNT;</CODE></p>
<p class=book><CODE>9 unsigned long iterations = ITERATIONS;</CODE></p>
<p class=book><CODE>10 pthread_mutex_t the_mutex = PTHREAD_MUTEX_INITIALIZER;</CODE></p>
<p class=book><CODE>11 pthread_mutex_t mut = PTHREAD_MUTEX_INITIALIZER;</CODE></p>
<p class=book><CODE>12 volatile int sentinel = 0;</CODE></p>
<p class=book><CODE>13 pthread_once_t once = PTHREAD_ONCE_INIT;</CODE></p>
<p class=book><CODE>14 pthread_t *array = NULL, null_pthread = {0};</CODE></p>
<p class=book><CODE>15 int bottom = 0;</CODE></p>
<p class=book><CODE>16 int inited = 0; 17</CODE></p>
<p class=book><CODE>18 /*</CODE></p>
<p class=book><CODE>19 * Handle SIGUSR1 in the target thread, to suspend it until</CODE></p>
<p class=book><CODE>20 * receiving SIGUSR2 (resume).</CODE></p>
<p class=book><CODE>21 */</CODE></p>
<p class=book><CODE>22 void</CODE></p>
<p class=book><CODE>23 suspend_signal_handler (int sig)</CODE></p>
<p class=book><CODE>24 {</CODE></p>
<p class=book><CODE>25 	sigset_t signal_set;</CODE> </p>
<p class=book><CODE>26</CODE></p>
<p class=book><CODE>27 /*</CODE></p>
<p class=book><CODE>28 * Block all signals except SIGUSR2 while suspended.</CODE></p>
<p class=book><CODE>29 */</CODE></p>
<p class=book><CODE>30 	sigfillset (&signal_set);</CODE></p>
<p class=book><CODE>31 	sigdelset (&signal_set, SIGUSR2);</CODE></p>
<p class=book><CODE>32 	sentinel = 1;</CODE></p>
<p class=book><CODE>33 	sigsuspend (&signal_set);</CODE></p>
<p class=book><CODE>34</CODE></p>
<p class=book><CODE>35 /*</CODE></p>
<p class=book><CODE>36 * Once I'm here, I've been resumed, and the resume signal</CODE></p>
<p class=book><CODE>37 * handler has been run to completion.</CODE></p>
<p class=book><CODE>38 */</CODE></p>
<p class=book><CODE>39 	return;</CODE></p>
<p class=book><CODE>40 }</CODE> </p>
<p class=book><CODE>41</CODE></p>
<p class=book><CODE>42 /*</CODE></p>
<p class=book><CODE>43 * Handle SIGUSR2 in the target thread, to resume it. Note that</CODE></p>
<p class=book><CODE>44 * the signal handler does nothing. It exists only because we need</CODE></p>
<p class=book><CODE>45 * to cause sigsuspend() to return.</CODE></p>
<p class=book><CODE>46 */</CODE></p>
<p class=book><CODE>47 void</CODE></p>
<p class=book><CODE>48 resume_signal_handler (int sig)</CODE></p>
<p class=book><CODE>49 {</CODE></p>
<p class=book><CODE>50 	return;</CODE></p>
<p class=book><CODE>51 }</CODE></p>
<p class=book>The <CODE>suspend_init_routine</CODE> function dynamically initializes the suspend/ resume package when the first call to thd_suspend is made. It is actually called indirectly by pthread_once.</p>
<p class=book><b>15-16</b> It allocates an initial array of thread identifiers, which is used to record the identifiers of all threads that have been suspended. This array is used to ensure that multiple calls to thd_suspend have no additional effect on the target thread, and that calling thd_continue for a thread that is not suspended has no effect.</p>
<p class=book><b>21-35</b> It sets up signal actions for the <b>SIGUSR1</b> and <b>SIGUSR2</b> signals, which will be used, respectively, to suspend and resume threads.</p>
<p class=book>■ <b>susp.c</b> <b>part 2 initialization</b></p>
<p class=book><CODE>1 /*</CODE></p>
<p class=book><CODE>2 * Dynamically initialize the "suspend package" when first used</CODE></p>
<p class=book><CODE>3 * (called by pthread_once).</CODE></p>
<p class=book><CODE>4 */</CODE></p>
<p class=book><CODE>5 void</CODE></p>
<p class=book><CODE>6 suspend_init_routine (void)</CODE></p>
<p class=book><CODE>7 {</CODE></p>
<p class=book><CODE>8 	int status;</CODE></p>
<p class=book><CODE>9 	struct sigaction sigusrl, sigusr2;</CODE></p>
<p class=book><CODE>10</CODE></p>
<p class=book><CODE>11 /*</CODE></p>
<p class=book><CODE>12 * Allocate the suspended threads array. This array is used</CODE></p>
<p class=book><CODE>13 * to guarentee idempotency</CODE></p>
<p class=book><CODE>14 */</CODE></p>
<p class=book><CODE>15 	bottom = 10;</CODE></p>
<p class=book><CODE>16 	array = (pthread_t*) calloc (bottom, sizeof (pthread_t)); 17</CODE></p>
<p class=book><CODE>18 /*</CODE></p>
<p class=book><CODE>19 * Install the signal handlers for suspend/resume.</CODE></p>
<p class=book><CODE>20 */</CODE></p>
<p class=book><CODE>21 	sigusrl.sa_flags = 0;</CODE></p>
<p class=book><CODE>22 	sigusrl.sa_handler = suspend_signal_handler; 23</CODE></p>
<p class=book><CODE>24 	sigemptyset (&sigusrl.sa_mask);</CODE></p>
<p class=book><CODE>25 	sigusr2.sa_flags = 0;</CODE></p>
<p class=book><CODE>26 	sigusr2.sa_handler = resume_signal_handler;</CODE></p>
<p class=book><CODE>27 	sigusr2.sa_mask = sigusrl.sa_mask;</CODE></p>
<p class=book><CODE>28</CODE></p>
<p class=book><CODE>29 	status = sigaction (SIGUSR1, &sigusrl, NULL);</CODE></p>
<p class=book><CODE>30 	if (status == -1)</CODE></p>
<p class=book><CODE>31 		errno_abort ("Installing suspend handler"); 32</CODE></p>
<p class=book><CODE>33 	status = sigaction (SIGUSR2, &sigusr2, NULL);</CODE></p>
<p class=book><CODE>34 	if (status == -1)</CODE></p>
<p class=book><CODE>35 		errno_abort ("Installing resume handler");</CODE></p>
<p class=book><CODE>36</CODE></p>
<p class=book><CODE>37 	inited = 1;</CODE></p>
<p class=book><CODE>38 	return;</CODE></p>
<p class=book><CODE>39 }</CODE></p>
<p class=book><b>9-40</b> The <CODE>thd_suspend</CODE> function suspends a thread, and returns when that thread has ceased to execute user code. It first ensures that the suspend/resume package is initialized by calling <CODE>pthread_once</CODE>. Under protection of a mutex, it searches for the target thread's identifier in the array of suspended thread identifiers. If the thread is already suspended, <CODE>thd_suspend</CODE> returns successfully.</p>
<p class=book><b>47-60</b> Determine whether there is an empty entry in the array of suspended threads and, if not, <CODE>realloc</CODE> the array with an extra entry.</p>
<p class=book><b>65-78</b> The sentinel variable is initialized to 0, to detect when the target thread suspension occurs. The thread is sent a <b>SIGUSR1</b> signal by calling <CODE>pthread_kill</CODE>, and <CODE>thd_suspend</CODE> loops, calling <CODE>sched_yield</CODE> to avoid monopolizing a processor, until the target thread responds by setting sentinel. Finally, the suspended thread's identifier is stored in the array.</p>
<p class=book>■ <b>susp.c part 3 thd_suspend</b> </p>
<p class=book><CODE>1 /*</CODE></p>
<p class=book><CODE>2 * Suspend a thread by sending it a signal (SIGUSR1), which will</CODE></p>
<p class=book><CODE>3 * block the thread until another signal (SIGUSR2) arrives.</CODE></p>
<p class=book><CODE>4 *</CODE></p>
<p class=book><CODE>5 * Multiple calls to thd_suspend for a single thread have no</CODE></p>
<p class=book><CODE>6 * additional effect on the thread — a single thd_continue</CODE></p>
<p class=book><CODE>7 * call will cause it to resume execution.</CODE></p>
<p class=book><CODE>8 */</CODE></p>
<p class=book><CODE>9 int</CODE></p>
<p class=book><CODE>10 thd_suspend (pthread_t target_thread)</CODE></p>
<p class=book><CODE>11 {</CODE></p>
<p class=book><CODE>12 int status;</CODE></p>
<p class=book><CODE>13 int i = 0;</CODE></p>
<p class=book><CODE>14</CODE></p>
<p class=book><CODE>15 /*</CODE></p>
<p class=book><CODE>16 * The first call to thd_suspend will initialize the</CODE></p>
<p class=book><CODE>17 * package.</CODE></p>
<p class=book><CODE>18 */</CODE></p>
<p class=book><CODE>19 status = pthread_once (&once, suspend_init_routine);</CODE></p>
<p class=book><CODE>20 if (status != 0)</CODE></p>
<p class=book><CODE>21 	return status;</CODE> </p>
<p class=book><CODE>22</CODE></p>
<p class=book><CODE>23 /*</CODE></p>
<p class=book><CODE>24 * Serialize access to suspend, makes life easier.</CODE></p>
<p class=book><CODE>25 */</CODE></p>
<p class=book><CODE>26 status = pthread_mutex_lock (&mut);</CODE></p>
<p class=book><CODE>27 if (status != 0)</CODE></p>
<p class=book><CODE>28 	return status;</CODE> </p>
<p class=book><CODE>29</CODE></p>
<p class=book><CODE>30 /*</CODE></p>
<p class=book><CODE>31 * Threads that are suspended are added to the target_array;</CODE></p>
<p class=book><CODE>32 * a request to suspend a thread already listed in the array</CODE></p>
<p class=book><CODE>33 * is ignored. Sending a second SIGUSR1 would cause the</CODE></p>
<p class=book><CODE>34 * thread to resuspend itself as soon as it is resumed.</CODE></p>
<p class=book><CODE>35 */</CODE></p>
<p class=book><CODE>36 while (i &lt; bottom)</CODE></p>
<p class=book><CODE>37 	if (array[i++] == target_thread) {</CODE></p>
<p class=book><CODE>38 	status = pthread_mutex_unlock (&mut);</CODE></p>
<p class=book><CODE>39 	return status;</CODE></p>
<p class=book><CODE>40 }</CODE> </p>
<p class=book><CODE>41</CODE></p>
<p class=book><CODE>42 /*</CODE></p>
<p class=book><CODE>43 * Ok, we really need to suspend this thread. So, let's find</CODE></p>
<p class=book><CODE>44 * the location in the array that we'll use. If we run off</CODE></p>
<p class=book><CODE>45 * the end, realloc the array for more space.</CODE></p>
<p class=book><CODE>46 */</CODE></p>
<p class=book><CODE>47 i = 0;</CODE></p>
<p class=book><CODE>48 while (array[i] != 0)</CODE></p>
<p class=book><CODE>49 	i++;</CODE> </p>
<p class=book><CODE>50</CODE></p>
<p class=book><CODE>51 if (i == bottom) {</CODE></p>
<p class=book><CODE>52 	array = (pthread_t*) realloc (</CODE></p>
<p class=book><CODE>53 		array, (++bottom * sizeof (pthread_t)));</CODE></p>
<p class=book><CODE>54 	if (array == NULL) {</CODE></p>
<p class=book><CODE>55 		pthread_mutex_unlock (&mut);</CODE></p>
<p class=book><CODE>56 		return errno;</CODE></p>
<p class=book><CODE>57 	}</CODE> </p>
<p class=book><CODE>58</CODE></p>
<p class=book><CODE>59 	array[bottom] = null_pthread; /* Clear new entry */</CODE></p>
<p class=book><CODE>60 }</CODE> </p>
<p class=book><CODE>61</CODE></p>
<p class=book><CODE>62 /*</CODE></p>
<p class=book><CODE>63 * Clear the sentinel and signal the thread to suspend.</CODE></p>
<p class=book><CODE>64 */</CODE></p>
<p class=book><CODE>65 sentinel = 0;</CODE></p>
<p class=book><CODE>66 status = pthread_kill (target_thread, SIGUSR1);</CODE></p>
<p class=book><CODE>67 if (status != 0) {</CODE></p>
<p class=book><CODE>68 	pthread_mutex_unlock (&mut);</CODE></p>
<p class=book><CODE>69 	return status;</CODE></p>
<p class=book><CODE>70 }</CODE></p>
<p class=book><CODE>71</CODE></p>
<p class=book><CODE>72 /*</CODE></p>
<p class=book><CODE>73 * Wait for the sentinel to change.</CODE></p>
<p class=book><CODE>74 */</CODE></p>
<p class=book><CODE>75 while (sentinel == 0)</CODE></p>
<p class=book><CODE>76 	sched_yield ();</CODE></p>
<p class=book><CODE>77</CODE></p>
<p class=book><CODE>78 array[i] = target_thread;</CODE></p>
<p class=book><CODE>79</CODE></p>
<p class=book><CODE>80 	status = pthread_mutex_unlock (&mut);</CODE></p>
<p class=book><CODE>81 	return status;</CODE></p>
<p class=book><CODE>82 }</CODE></p>
<p class=book><b>23-26</b>  <CODE>The thd_continue</CODE> function first checks whether the suspend/resume package has been initialized (<CODE>inited</CODE> is not 0). If it has not been initialized, then no threads are suspended, and <CODE>thd_continue</CODE> returns with success.</p>
<p class=book><b>33-39</b> If the specified thread identifier is not found in the array of suspended threads, then it is not suspended — again, return with success.</p>
<p class=book><b>45-51</b> Send the resume signal, SIGUSR2. There's no need to wait — the thread will resume whenever it can, and the thread calling thd_continue doesn't need to know.</p>
<p class=book>■ susp.c part 4 thd_continue</p>
<p class=book><CODE>1 /*</CODE></p>
<p class=book><CODE>2 * Resume a suspended thread by sending it SIGUSR2 to break</CODE></p>
<p class=book><CODE>3 * it out of the sigsuspend() in which it's waiting. If the</CODE></p>
<p class=book><CODE>4 * target thread isn't suspended, return with success.</CODE></p>
<p class=book><CODE>5 */</CODE></p>
<p class=book><CODE>6 int</CODE></p>
<p class=book><CODE>7 thd_continue (pthread_t target_thread)</CODE></p>
<p class=book><CODE>8 {</CODE></p>
<p class=book><CODE>9 int status;</CODE></p>
<p class=book><CODE>10 int i = 0;</CODE> </p>
<p class=book><CODE>11</CODE></p>
<p class=book><CODE>12 /*</CODE></p>
<p class=book><CODE>13 * Serialize access to suspend, makes life easier.</CODE></p>
<p class=book><CODE>14 */</CODE></p>
<p class=book><CODE>15 status = pthread_mutex_lock (&mut);</CODE></p>
<p class=book><CODE>16 if (status != 0)</CODE></p>
<p class=book><CODE>17 	return status;</CODE> </p>
<p class=book><CODE>18</CODE></p>
<p class=book><CODE>19 /*</CODE></p>
<p class=book><CODE>20 * If we haven't been initialized, then the thread must be</CODE></p>
<p class=book><CODE>21 * "resumed"; it couldn't have been suspended!</CODE></p>
<p class=book><CODE>22 */</CODE></p>
<p class=book><CODE>23 if (!inited) {</CODE></p>
<p class=book><CODE>24 	status = pthread_mutex_unlock (&mut);</CODE></p>
<p class=book><CODE>25 	return status;</CODE></p>
<p class=book><CODE>26 }</CODE> </p>
<p class=book><CODE>27</CODE></p>
<p class=book><CODE>28 /*</CODE></p>
<p class=book><CODE>29 * Make sure the thread is in the suspend array. If not, it</CODE></p>
<p class=book><CODE>30 * hasn't been suspended (or it has already been resumed) and</CODE></p>
<p class=book><CODE>31 * we can just carry on.</CODE></p>
<p class=book><CODE>32 */</CODE></p>
<p class=book><CODE>33 while (array[i] != target_thread && i &lt; bottom)</CODE></p>
<p class=book><CODE>34 	i++;</CODE></p>
<p class=book><CODE>35</CODE></p>
<p class=book><CODE>36 if (i &gt;= bottom) {</CODE></p>
<p class=book><CODE>37 	pthread_mutex_unlock (&mut);</CODE></p>
<p class=book><CODE>38 	return 0;</CODE></p>
<p class=book><CODE>39 }</CODE> </p>
<p class=book><CODE>40</CODE></p>
<p class=book><CODE>41 /*</CODE></p>
<p class=book><CODE>42 * Signal the thread to continue, and remove the thread from</CODE></p>
<p class=book><CODE>43 * the suspended array.</CODE></p>
<p class=book><CODE>44 */</CODE></p>
<p class=book><CODE>45 status = pthread_kill (target_thread, SIGUSR2);</CODE></p>
<p class=book><CODE>46 if (status != 0) {</CODE></p>
<p class=book><CODE>47 	pthread_mutex_unlock (&mut);</CODE></p>
<p class=book><CODE>48 	return status;</CODE></p>
<p class=book><CODE>49 }</CODE> </p>
<p class=book><CODE>50</CODE></p>
<p class=book><CODE>51 array[i] = 0; /* Clear array element */</CODE></p>
<p class=book><CODE>52 status = pthread_mutex_unlock (&mut);</CODE></p>
<p class=book><CODE>53 return status;</CODE></p>
<p class=book><CODE>54 }</CODE></p>
<p class=book><b>2-25</b> The thread_routine function is the thread start routine for each of the "target" threads created by the program. It simply loops for a substantial period of time, periodically printing a status message. On each iteration, it yields to other threads to ensure that the processor time is apportioned "fairly" across all the threads.</p>
<p class=book>Notice that instead of calling <CODE>printf</CODE>, the function formats a message with <CODE>sprintf</CODE> and then displays it on <CODE>stdout</CODE> (file descriptor 1) by calling write. This illustrates one of the problems with using suspend and resume (<CODE>thd_suspend</CODE> and <CODE>thd_continue</CODE>) for synchronization. Suspend and resume are scheduling functions, not synchronization functions, and using scheduling and synchronization controls together can have severe consequences.</p>
<p class=book> Incautious use of suspend and resume can deadlock your application.</p>
<p class=book>In this case, if a thread were suspended while modifying a <i>stdio</i> stream, all other threads that tried to modify that <i>stdio</i> stream might block, waiting for a mutex that is locked by the suspended thread. The write function, on the other hand, is usually a call to the kernel — the kernel is atomic with respect to signals, and therefore can't be suspended. Use of write, therefore, cannot cause a deadlock.</p>
<p class=book>In general, you cannot suspend a thread that may possibly hold any resource, if that resource may be required by some other thread before the suspended thread is resumed. In particular, the result is a <i>deadlock</i> if the thread that would resume the suspended thread first needs to acquire the resource. This prohibition includes, especially, mutexes used by libraries you call — such as the mutexes used by malloc and free, or the mutexes used by <i>stdio.</i></p>
<p class=book><b>36-42</b> Threads are created with an attributes object set to create threads detached, rather than joinable. The result is that threads will cease to exist as soon as they terminate, rather than remaining until main calls <CODE>pthread_join</CODE>. The <CODE>pthread_kill</CODE> function does not necessarily fail if you attempt to send a signal to a terminated thread (the standard is silent on this point), and you may be merely setting a pending signal in a thread that will never be able to act on it. If this were to occur, the <CODE>thd_suspend</CODE> routine would hang waiting for the thread to respond. Although <CODE>pthread_kill</CODE> may not fail when sending to a terminated thread, it will fail when sending to a thread that doesn't exist — so this attribute converts a possible hang, when the program is run with ITERATIONS set too low, into an abort with an error message.</p>
<p class=book><b>51-85</b> The main thread sleeps for two seconds after creating the threads to allow them to reach a "steady state." It then loops through the first half of the threads, suspending each of them. It waits an additional two seconds and then resumes each of the threads it had suspended. It waits another two seconds, suspends each of the remaining threads (the second half), and then after another two seconds resumes them.</p>
<p class=book>By watching the status messages printed by the individual threads, you can see the pattern of output change as the threads are suspended and resumed.</p>
<p class=book>■ susp.c  part 5 sample program</p>
<p class=book>1<CODE> static void *</CODE></p>
<p class=book><CODE>2 thread_routine (void *arg)</CODE></p>
<p class=book><CODE>3 {</CODE></p>
<p class=book><CODE>4 int number = (int)arg;</CODE></p>
<p class=book><CODE>5 int status;</CODE></p>
<p class=book><CODE>6 int i;</CODE></p>
<p class=book><CODE>7 char buffer[128] ;</CODE> </p>
<p class=book><CODE>8</CODE></p>
<p class=book><CODE>9 for (i = 1; i &lt;= iterations; i++) {</CODE></p>
<p class=book><CODE>10 /*</CODE></p>
<p class=book><CODE>11 * Every time each thread does 5000 interations, print</CODE></p>
<p class=book><CODE>12 * a progress report.</CODE></p>
<p class=book><CODE>13 */</CODE></p>
<p class=book><CODE>14 if (i % 2000 == 0) {</CODE></p>
<p class=book><CODE>15 	sprintf (</CODE></p>
<p class=book><CODE>16 		buffer, "Thread %02d: %d\n",</CODE></p>
<p class=book><CODE>17 		number, i);</CODE></p>
<p class=book><CODE>18 	write (1, buffer, strlen (buffer));</CODE></p>
<p class=book><CODE>19 }</CODE> </p>
<p class=book><CODE>20</CODE></p>
<p class=book><CODE>21 sched_yield ();</CODE></p>
<p class=book><CODE>22 }</CODE> </p>
<p class=book><CODE>23</CODE></p>
<p class=book><CODE>24 return (void *)0;</CODE></p>
<p class=book><CODE>25 }</CODE> </p>
<p class=book><CODE>26</CODE></p>
<p class=book><CODE>27 int</CODE></p>
<p class=book><CODE>28 main (int argc, char *argv[])</CODE></p>
<p class=book><CODE>29 {</CODE></p>
<p class=book><CODE>30 pthread_t threads[THREAD_COUNT];</CODE></p>
<p class=book><CODE>31 pthread_attr_t detach;</CODE></p>
<p class=book><CODE>32 int status;</CODE></p>
<p class=book><CODE>33 void *result;</CODE></p>
<p class=book><CODE>34 int i;</CODE> </p>
<p class=book><CODE>35</CODE></p>
<p class=book><CODE>36 status = pthread_attr_init (&detach);</CODE></p>
<p class=book><CODE>37 if (status != 0)</CODE></p>
<p class=book><CODE>38 	err_abort (status, "Init attributes object");</CODE></p>
<p class=book><CODE>39 status = pthread_attr_setdetachstate (</CODE></p>
<p class=book><CODE>40 	&detach, PTHREAD_CREATE_DETACHED);</CODE></p>
<p class=book><CODE>41 if (status != 0)</CODE></p>
<p class=book><CODE>42 	err_abort (status, "Set create-detached"); 43</CODE></p>
<p class=book><CODE>44 for (i = 0; i&lt; THREAD_COUNT; i++) {</CODE></p>
<p class=book><CODE>45 	status = pthread_create (</CODE></p>
<p class=book><CODE>46 		&threads[i], &detach, thread_routine, (void *)i);</CODE></p>
<p class=book><CODE>47 	if (status != 0)</CODE></p>
<p class=book><CODE>48 		err_abort (status, "Create thread");</CODE></p>
<p class=book><CODE>49 }</CODE> </p>
<p class=book><CODE>50</CODE></p>
<p class=book><CODE>51 sleep (2);</CODE> </p>
<p class=book><CODE>52</CODE></p>
<p class=book><CODE>53 for (i = 0; i &lt; THREAD_COUNT/2; i++) {</CODE></p>
<p class=book><CODE>54 	printf ("Suspending thread %d.\n", i);</CODE></p>
<p class=book><CODE>55 	status = thd_suspend (threads[i]);</CODE></p>
<p class=book><CODE>56 	if (status != 0)</CODE></p>
<p class=book><CODE>57 		err_abort (status, "Suspend thread");</CODE></p>
<p class=book><CODE>58 }</CODE> </p>
<p class=book><CODE>59</CODE></p>
<p class=book><CODE>60 printf ("Sleeping ...\n");</CODE></p>
<p class=book><CODE>61 sleep (2);</CODE> </p>
<p class=book><CODE>62</CODE></p>
<p class=book><CODE>63 for (i = 0; i &lt; THREAD_COUNT/2; i++) {</CODE></p>
<p class=book><CODE>64 	printf ("Continuing thread %d.\n", i);</CODE></p>
<p class=book><CODE>65 	status = thd_continue (threads[i]);</CODE></p>
<p class=book><CODE>66 	if (status != 0)</CODE></p>
<p class=book><CODE>67 		err_abort (status, "Suspend thread");</CODE></p>
<p class=book><CODE>68 }</CODE> </p>
<p class=book><CODE>69</CODE></p>
<p class=book><CODE>70 for (i = THREAD_COUNT/2; i &lt; THREAD_COUNT; i++) {</CODE></p>
<p class=book><CODE>71 	printf ("Suspending thread %d.\n", i);</CODE></p>
<p class=book><CODE>72 	status = thd_suspend (threads[i]);</CODE></p>
<p class=book><CODE>73 	if (status != 0)</CODE></p>
<p class=book><CODE>74 		err_abort (status, "Suspend thread");</CODE></p>
<p class=book><CODE>75 }</CODE> </p>
<p class=book><CODE>76</CODE></p>
<p class=book><CODE>77 printf ("Sleeping ...\n");</CODE></p>
<p class=book><CODE>78 sleep (2);</CODE> </p>
<p class=book><CODE>79</CODE></p>
<p class=book><CODE>80 for (i = THREAD_COUNT/2; i &lt; THREAD_COUNT; i++) {</CODE></p>
<p class=book><CODE>81 	printf ("Continuing thread %d.\n", i);</CODE></p>
<p class=book><CODE>82 	status = thd_continue (threads[i]);</CODE></p>
<p class=book><CODE>83 	if (status != 0)</CODE></p>
<p class=book><CODE>84 		err_abort (status, "Continue thread");</CODE></p>
<p class=book><CODE>85 	}</CODE> </p>
<p class=book><CODE>86</CODE></p>
<p class=book><CODE>87 pthread_exit (NULL); /* Let threads finish */</CODE></p>
<p class=book><CODE>88 }</CODE></p>
<p class=book>■ susp.c part 5 sampleprogram</p>


<a name=t111></a><h3 class=book>
6.6.4 sigwait and sigwaitinfo
</h3>
<p class=book><b>int sigwait (const sigset_t *set, int *sig);</b></p>
<p class=book><b>#ifdef _POSIX_REALTIME_SIGNALS</b></p>
<p class=book><b>int sigwaitinfo (const sigset_t *set, siginfo_t *info);</b></p>
<p class=book><b>int sigtimedwait (const sigset_t *set, siginfo_t *info, const struct timespec *timeout);</b></p>
<p class=book><b>#endif</b></p>
<p class=book>Always use <CODE>sigwait</CODE> to work with asynchronous signals within threaded code.</p>
<p class=book>Pthreads adds a function to allow threaded programs to deal with "asynchronous" signals synchronously. That is, instead of allowing a signal to interrupt a thread at some arbitrary point, a thread can choose to receive a signal synchronously. It does this by calling <CODE>sigwait</CODE>, or one of sigwait's siblings.</p>
<p class=book>The signals for which you <CODE>sigwait</CODE> must be masked in the sigwaiting thread,and should usually be masked in all threads.</p>
<p class=book>The <CODE>sigwait</CODE> function takes a signal set as its argument, and returns a signal number when any signal in that set occurs. You can create a thread that waits for some signal, for example, <b>SIGINT,</b> and causes some application activity when it occurs. The non-obvious rule is that the signals for which you wait must be masked before calling <CODE>sigwait</CODE>. In fact, you should ideally mask these signals in main, at the start of the program. Because signal masks are inherited by threads you create, all threads will (by default) have the signal masked. This ensures that the signal will never be delivered to any thread except the one that calls <CODE>sigwait</CODE>.</p>
<p class=book>Signals are delivered only once. If two threads are blocked in <CODE>sigwait</CODE>, only one of them will receive a signal that's sent to the process. This means you can't, for example, have two independent subsystems using <CODE>sigwait</CODE> that catch <b>SIGINT.</b> It also means that the signal will not be caught by <CODE>sigwait</CODE> in one thread and also delivered to some signal-catching function in another thread. That's not so bad, since you couldn't do that in the old nonthreaded model either — only one signal action can be active at a time.</p>
<p class=book>While <CODE>sigwait</CODE>, a Pthreads function, reports errors by returning an error number, its siblings, <CODE>sigwaitinfo</CODE> and <CODE>sigtimedwait</CODE>, were added to POSIX prior to Pthreads, and use the older <CODE>errno</CODE> mechanism. This is confusing and awkward, and that is unfortunate. The problem is that they deal with the additional information supplied by the POSIX realtime signals option (&lt;unistd.h&gt; defines the symbol <b>_POSIX_REALTIME_SIGNALS),</b> and the POSIX realtime amendment, POSIX.1b, was completed before the Pthreads amendment.</p>
<p class=book>Both <CODE>sigwaitinfo</CODE> and <CODE>sigtimedwait</CODE> return the realtime signal information, <CODE>siginfo_t</CODE>, for signals received. In addition, <CODE>sigtimedwait</CODE> allows the caller to specify that <CODE>sigtimedwait</CODE> should return with the error <b>EAGAIN</b> in the event that none of the selected signals is received within the specified interval.</p>
<p class=book>The sigwait.c program creates a "sigwait thread" that handles SIGINT. </p>
<p class=book><b>23-41</b> The signal_waiter thread repeatedly calls sigwait, waiting for a <b>SIGINT</b> signal. It counts five occurrences of <b>SIGINT</b> (printing a message each time), and then signals a condition variable on which main is waiting. At that time, main will exit. </p>
<p class=book><b>61-65</b> The main program begins by masking <b>SIGINT</b>. Because all threads inherit their initial signal mask from their creator, <b>SIGINT</b> will be masked in all threads. This prevents SIGINT from being delivered at any time except when the signal_ waiter thread is blocked in sigwait and ready to receive the signal.</p>
<p class=book>■ <b>sigwait.c</b></p>
<p class=book><CODE>1 #include &lt;sys/types.h&gt;</CODE></p>
<p class=book><CODE>2 #include &lt;unistd.h&gt;</CODE></p>
<p class=book><CODE>3 #include &lt;pthread.h&gt;</CODE></p>
<p class=book><CODE>4 #include &lt;signal.h&gt;</CODE></p>
<p class=book><CODE>5 #include "errors.h"</CODE> </p>
<p class=book><CODE>6</CODE></p>
<p class=book><CODE>7 pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;</CODE></p>
<p class=book><CODE>8 pthread_cond_t cond = PTHREAD_COND_INITIALIZER;</CODE></p>
<p class=book><CODE>9 int interrupted = 0;</CODE> </p>
<p class=book><CODE>10 sigset_t signal set;</CODE></p>
<p class=book><CODE>12 /*</CODE></p>
<p class=book><CODE>13 * Wait for the SIGINT signal. When it has occurred 5 times, set the</CODE></p>
<p class=book><CODE>14 * "interrupted" flag (the main thread's wait predicate) and signal a</CODE></p>
<p class=book><CODE>15 * condition variable. The main thread will exit.</CODE></p>
<p class=book><CODE>16 */</CODE></p>
<p class=book><CODE>17 void *signal_waiter (void *arg)</CODE></p>
<p class=book><CODE>18 {</CODE></p>
<p class=book><CODE>19 int sig_number;</CODE></p>
<p class=book><CODE>20 int signal_count = 0;</CODE></p>
<p class=book><CODE>21 int status;</CODE> </p>
<p class=book><CODE>22</CODE></p>
<p class=book><CODE>23 while (1) {</CODE></p>
<p class=book><CODE>24 	sigwait (&signal_set, &sig_number);</CODE></p>
<p class=book><CODE>25 	if (sig_number == SIGINT) {</CODE></p>
<p class=book><CODE>26 		printf ("Got SIGINT (%d of 5)\n", signal_count+l);</CODE></p>
<p class=book><CODE>27 		if (++signal_count &gt;= 5) {</CODE></p>
<p class=book><CODE>28 		status = pthread_mutex_lock (&mutex);</CODE></p>
<p class=book><CODE>29 		if (status != 0)</CODE></p>
<p class=book><CODE>30 			err_abort (status, "Lock mutex");</CODE></p>
<p class=book><CODE>31 		interrupted = 1;</CODE></p>
<p class=book><CODE>32 		status = pthread_cond_signal (&cond);</CODE></p>
<p class=book><CODE>33 		if (status != 0)</CODE></p>
<p class=book><CODE>34 			err_abort (status, "Signal condition");</CODE></p>
<p class=book><CODE>35 		status = pthread_mutex_unlock (&mutex);</CODE></p>
<p class=book><CODE>36 		if (status != 0)</CODE></p>
<p class=book><CODE>37 			err_abort (status, "Unlock mutex");</CODE></p>
<p class=book><CODE>38 		break;</CODE></p>
<p class=book><CODE>39 	}</CODE></p>
<p class=book><CODE>40 }</CODE></p>
<p class=book><CODE>41 }</CODE></p>
<p class=book><CODE>42 return NULL;</CODE></p>
<p class=book><CODE>43 }</CODE></p>
<p class=book><CODE>44</CODE></p>
<p class=book><CODE>45 int main (int argc, char *argv[])</CODE></p>
<p class=book><CODE>46 {</CODE></p>
<p class=book><CODE>47 pthread_t signal_thread_id;</CODE></p>
<p class=book><CODE>48 int status;</CODE> </p>
<p class=book><CODE>49</CODE></p>
<p class=book><CODE>50 /*</CODE></p>
<p class=book><CODE>51 * Start by masking the "interesting" signal, SIGINT in the</CODE></p>
<p class=book><CODE>52 * initial thread. Because all threads inherit the signal mask</CODE></p>
<p class=book><CODE>53 * from their creator, all threads in the process will have</CODE></p>
<p class=book><CODE>54 * SIGINT masked unless one explicitly unmasks it. The</CODE></p>
<p class=book><CODE>55 * semantics of sigwait requires that all threads (including</CODE></p>
<p class=book><CODE>56 * the thread calling sigwait) have the signal masked, for</CODE></p>
<p class=book><CODE>57 * reliable operation. Otherwise, a signal that arrives</CODE></p>
<p class=book><CODE>58 * while the sigwaiter is not blocked in sigwait might be</CODE></p>
<p class=book><CODE>59 * delivered to another thread.</CODE></p>
<p class=book><CODE>60 */</CODE></p>
<p class=book><CODE>61 sigemptyset (&signal_set);</CODE></p>
<p class=book><CODE>62 sigaddset (&signal_set, SIGINT);</CODE></p>
<p class=book><CODE>63 status = pthread_sigmask (SIG_BLOCK, &signal_set, NULL);</CODE></p>
<p class=book><CODE>64 if (status != 0)</CODE></p>
<p class=book><CODE>65 	err_abort (status, "Set signal mask"); 66</CODE></p>
<p class=book><CODE>67 /*</CODE></p>
<p class=book><CODE>68 * Create the sigwait thread.</CODE></p>
<p class=book><CODE>69 */</CODE></p>
<p class=book><CODE>70 status = pthread_create (&signal_thread_id, NULL,</CODE></p>
<p class=book><CODE>71 	signal_waiter, NULL);</CODE></p>
<p class=book><CODE>72 if (status != 0)</CODE></p>
<p class=book><CODE>73 	err_abort (status, "Create sigwaiter");</CODE></p>
<p class=book><CODE>74</CODE></p>
<p class=book><CODE>75 /*</CODE></p>
<p class=book><CODE>76 * Wait for the sigwait thread to receive SIGINT and signal</CODE></p>
<p class=book><CODE>77 * the condition variable.</CODE></p>
<p class=book><CODE>78 */</CODE></p>
<p class=book><CODE>79 status = pthread_mutex_lock (&mutex);</CODE></p>
<p class=book><CODE>80 if (status != 0)</CODE></p>
<p class=book><CODE>81 	err_abort (status, "Lock mutex");</CODE></p>
<p class=book><CODE>82 while (!interrupted) {</CODE></p>
<p class=book><CODE>83 	status = pthread_cond_wait (&cond,&mutex);</CODE></p>
<p class=book><CODE>84 	if (status != 0)</CODE></p>
<p class=book><CODE>85 		err_abort (status, "Wait for interrupt");</CODE></p>
<p class=book><CODE>86 }</CODE></p>
<p class=book><CODE>87 status = pthread_mutex_unlock (&mutex);</CODE></p>
<p class=book><CODE>88 if (status != 0)</CODE></p>
<p class=book><CODE>89 	err_abort (status, "Unlock mutex");</CODE></p>
<p class=book><CODE>90 printf ("Main terminating with SIGINT\n");</CODE></p>
<p class=book><CODE>91 return 0;</CODE></p>
<p class=book><CODE>92 }</CODE></p>


<a name=t112></a><h3 class=book>
6.6.5 SIGEV_THREAD
</h3>
<p class=book>Some of the functions in the POSLX.1b realtime standard, which provide for asynchronous notification, allow the programmer to give specific instructions about how that notification is to be accomplished. For example, when initiating an asynchronous device read or write using <CODE>aio_read</CODE> or <CODE>aio_write</CODE>, the programmer specifies a <CODE>struct aiocb</CODE>, which contains, among other members, a struct <CODE>sigevent</CODE>. Other functions that accept a struct <CODE>sigevent</CODE> include <CODE>timer_create</CODE> (which creates a per-process timer) and <CODE>sigqueue</CODE> (which queues a signal to a process).</p>
<p class=book>The <CODE>struct sigevent</CODE> structure in POSIX.1b provides a "notification mechanism" that allows the programmer to specify whether a signal is to be generated, and, if so, what signal number should be used. Pthreads adds a new notification mechanism called SIGEV_THREAD. This new notification mechanism causes the signal notification function to be run as if it were the start routine of a thread.</p>
<p class=book>Pthreads adds several members to the POSIX.1b <CODE>struct sigevent</CODE> structure. The new members are <CODE>sigev_notify_function</CODE>, a pointer to a thread start function; and <CODE>sigev_notify_attributes</CODE>, a pointer to a thread attributes object (<CODE>pthread_attr_t</CODE>) containing the desired thread creation attributes. If <CODE>sigev_notify_attributes</CODE> is NULL, the notify thread is created as if the <i>detachstate</i> attribute was set to PTHREAD_CREATE_DETACHED. This avoids a memory leak — in general, the notify thread's identifier won't be available to any other thread. Furthermore, Pthreads says that the result of specifying an attributes object that has the <i>detachstate</i> attribute set to PTHREAD_CREATE_JOINABLE is "undefined." (Most likely, the result will be a memory leak because the thread cannot be joined — if you are lucky, the system may override your choice and create it detached anyway.)</p>
<p class=book>The SIGEV_THREAD notification function may not actually be run in a new thread — Pthreads carefully specifies that it behaves as if it were run in a new thread, just as I did a few paragraphs ago. The system may, for example, queue SIGEV_THREAD events and call the start routines, serially, in some internal "server thread." The difference is effectively indistinguishable to the application. A system that uses a server thread must be very careful about the attributes specified for the notification thread—for example, scheduling policy and priority, contention scope, and minimum stack size must all be taken into consideration.</p>
<p class=book>The SIGEV_THREAD feature is not available to any of the "traditional" signal generation mechanisms, such as <CODE>setitimer</CODE>, or for SIGCHLD, SIGINT, and so forth. Those who are programming using the POSIX.1b "realtime signal" interfaces, including timers and asynchronous I/O, may find this new capability useful.</p>
<p class=book>The following program, sigev_thread.c, shows how to use the SIGEV_THREAD notification mechanism for a POSIX.1b timer. </p>
<p class=book><b>20-37</b> The function timer_thread is specified as the "notification function" (thread start routine) for the SIGEV_THREAD timer. The function will be called each time the timer expires. It counts expirations, and wakes the main thread after five. Notice that, unlike a signal-catching function, the SIGEV_THREAD notification function can make full use of Pthreads synchronization operations. This can be a substantial advantage in many situations. </p>
<p class=book><b>45-51</b> Unfortunately, neither Solaris 2.5 nor Digital UNIX 4.0 correctly implemented SIGEV_THREAD. Thus, unlike all other examples in this book, this code will not compile on Solaris 2.5. This #ifdef block allows the code to compile, and to fail gracefully if the resulting program is run, with an error message. Although the program will compile on Digital UNIX 4.0, it will not run. The implementation of SIGEV_THREAD has been fixed in Digital UNIX 4.0D, which should be available by the time you read this, and it should also be fixed in Solaris 2.6.</p>
<p class=book><b>56-59</b> These statements initialize the sigevent structure, which describes how the system should notify the application when an event occurs. In this case, we are telling it to call timer_thread when the timer expires, and to use default attributes.</p>
<p class=book>■ <b>sigev_thread.c</b></p>
<p class=book><CODE>1 #include &lt;pthread.h&gt;</CODE></p>
<p class=book><CODE>2 #include &lt;sys/signal.h&gt;</CODE></p>
<p class=book><CODE>3 #include &lt;sys/time.h&gt;</CODE></p>
<p class=book><CODE>4 #include "errors.h"</CODE> </p>
<p class=book><CODE>5</CODE></p>
<p class=book><CODE>6 timer_t timer_id;</CODE></p>
<p class=book><CODE>7 pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;</CODE></p>
<p class=book><CODE>8 pthread_cond_t cond = PTHREAD_COND_INITIALIZER;</CODE></p>
<p class=book><CODE>9 int counter = 0;</CODE> </p>
<p class=book><CODE>10</CODE></p>
<p class=book><CODE>11 /*</CODE></p>
<p class=book><CODE>12 * Thread start routine to notify the application when the</CODE></p>
<p class=book><CODE>13 * timer expires. This routine is run "as if" it were a new</CODE></p>
<p class=book><CODE>14 * thread, each time the timer expires.</CODE></p>
<p class=book><CODE>15 *</CODE></p>
<p class=book><CODE>16 * When the timer has expired 5 times, the main thread will</CODE></p>
<p class=book><CODE>17 * be awakened, and will terminate the program.</CODE></p>
<p class=book><CODE>18 */</CODE></p>
<p class=book><CODE>19 void</CODE></p>
<p class=book><CODE>20 timer_thread (void *arg)</CODE></p>
<p class=book><CODE>21 {</CODE></p>
<p class=book><CODE>22 int status;</CODE> </p>
<p class=book><CODE>23</CODE></p>
<p class=book><CODE>24 status = pthread_mutex_lock (&mutex);</CODE></p>
<p class=book><CODE>25 if (status != 0)</CODE></p>
<p class=book><CODE>26 	err_abort (status, "Lock mutex");</CODE></p>
<p class=book><CODE>27 if (++counter &gt;= 5) {</CODE></p>
<p class=book><CODE>28 	status = pthread_cond_signal (&cond);</CODE></p>
<p class=book><CODE>29 	if (status != 0)</CODE></p>
<p class=book><CODE>30 		err_abort (status, "Signal condition");</CODE></p>
<p class=book><CODE>31 }</CODE></p>
<p class=book><CODE>32 status = pthread_mutex_unlock (&mutex);</CODE></p>
<p class=book><CODE>33 if (status != 0)</CODE></p>
<p class=book><CODE>34 	err_abort (status, "Unlock mutex");</CODE> </p>
<p class=book><CODE>35</CODE></p>
<p class=book><CODE>36 printf ("Timer %d\n", counter);</CODE></p>
<p class=book><CODE>37 }</CODE> </p>
<p class=book><CODE>38</CODE></p>
<p class=book><CODE>39 main( )</CODE></p>
<p class=book><CODE>40 {</CODE></p>
<p class=book><CODE>41 int status;</CODE></p>
<p class=book><CODE>42 struct itimerspec ts;</CODE></p>
<p class=book><CODE>43 struct sigevent se;</CODE> </p>
<p class=book><CODE>44</CODE></p>
<p class=book><CODE>45 #ifdef sun</CODE></p>
<p class=book><CODE>46 fprintf (</CODE></p>
<p class=book><CODE>47 stderr,</CODE></p>
<p class=book><CODE>48 "This program cannot compile on Solaris 2.5.\n"</CODE></p>
<p class=book><CODE>49 "To build and run on Solaris 2.6, remove the\n"</CODE></p>
<p class=book><CODE>50 "\"#ifdef sun\" block in main().\n");</CODE></p>
<p class=book><CODE>51 #else</CODE></p>
<p class=book><CODE>52 /*</CODE></p>
<p class=book><CODE>53 * Set the sigevent structure to cause the signal to be</CODE></p>
<p class=book><CODE>54 * delivered by creating a new thread.</CODE></p>
<p class=book><CODE>55 */</CODE></p>
<p class=book><CODE>56 se.sigev_notify = SIGEV_THREAD;</CODE></p>
<p class=book><CODE>57 se.sigev_value.sival_ptr = &timer_id;</CODE></p>
<p class=book><CODE>58 se.sigev_notify_function = timer_thread;</CODE></p>
<p class=book><CODE>59 se.sigev_notify_attributes = NULL;</CODE></p>
<p class=book><CODE>60</CODE></p>
<p class=book><CODE>61 /*</CODE></p>
<p class=book><CODE>62 * Specify a repeating timer that fires every 5 seconds.</CODE></p>
<p class=book><CODE>63 */</CODE></p>
<p class=book><CODE>64 ts.it_value.tv_sec = 5;</CODE></p>
<p class=book><CODE>65 ts.it_value.tv_nsec = 0;</CODE></p>
<p class=book><CODE>66 ts.it_interval.tv_sec = 5;</CODE></p>
<p class=book><CODE>67 ts.it_interval.tv_nsec = 0;</CODE> </p>
<p class=book><CODE>68</CODE></p>
<p class=book><CODE>69 DPRINTF (("Creating timer\n"));</CODE></p>
<p class=book><CODE>70 status = timer_create(CLOCK_REALTIME, &se, &timer_id);</CODE></p>
<p class=book><CODE>71 if (status == -1)</CODE></p>
<p class=book><CODE>72 	errno_abort ("Create timer");</CODE> </p>
<p class=book><CODE>73</CODE></p>
<p class=book><CODE>74 DPRINTF ((</CODE></p>
<p class=book><CODE>75 	"Setting timer %d for 5-second expiration...\n", timer_id));</CODE></p>
<p class=book><CODE>76 status = timer_settime(timer_id, 0, &ts, 0);</CODE></p>
<p class=book><CODE>77 if (status == -1)</CODE></p>
<p class=book><CODE>78 	errno_abort ("Set timer");</CODE> </p>
<p class=book><CODE>79</CODE></p>
<p class=book><CODE>80 status = pthread_mutex_lock (&mutex);</CODE></p>
<p class=book><CODE>81 if (status != 0)</CODE></p>
<p class=book><CODE>82 	err_abort (status, "Lock mutex");</CODE></p>
<p class=book><CODE>83 while (counter &lt; 5) {</CODE></p>
<p class=book><CODE>84 	status = pthread_cond_wait (&cond, &mutex);</CODE></p>
<p class=book><CODE>85 	if (status != 0)</CODE></p>
<p class=book><CODE>86 		err_abort (status, "Wait on condition");</CODE></p>
<p class=book><CODE>87 }</CODE></p>
<p class=book><CODE>88 status = pthread_mutex_unlock (&mutex);</CODE> </p>
<p class=book><CODE>89 if (status != 0)</CODE></p>
<p class=book><CODE>90	err_abort (status, "Unlock mutex");</CODE></p>
<p class=book><CODE>91</CODE></p>
<p class=book><CODE>92 #endif /* Sun */</CODE></p>
<p class=book><CODE>93 return 0;</CODE></p>
<p class=book><CODE>94 }</CODE></p>


<a name=t113></a><h3 class=book>
<b>6.6.6 Semaphores: synchronizing with a signal-catching function</b>
</h3>
<p class=book><b>#ifdef _POSIX_SEMAPHORES</b> </p>
<p class=book><b>int sem_init (sem_t *sem, int pshared, unsigned int value);</b></p>
<p class=book><b>int sem_destroy (sem_t *sem);</b> </p>
<p class=book><b>int sem_wait (sem_t*sem);</b> </p>
<p class=book><b>int sem_trywake (sem_t *sem);</b> </p>
<p class=book><b>int sem_post (sem_t *sem);</b> </p>
<p class=book><b>int sem_getvalue (sem_t *sem, int *sval);</b> </p>
<p class=book><b>#endif</b></p>
<p class=book>Although mutexes and condition variables provide an ideal solution to most synchronization needs, they cannot meet all needs. One example of this is a need to communicate between a POSIX signal-catching function and a thread waiting for some asynchronous event. In new code, it is best to use sigwait or sigwaitinfo rather than relying on a signal-catching function, and this neatly avoids this problem. However, the use of asynchronous POSIX signal-catching functions is well established and widespread, and most programmers working with threads and existing code will probably encounter this situation.</p>
<p class=book>To awaken a thread from a POSIX signal-catching function, you need a mechanism that's reentrant with respect to POSIX signals (async-signal safe). POSIX provides relatively few of these functions, and none of the Pthreads functions is included. That's primarily because an async-signal safe mutex lock operation would be many times slower than one that isn't async-signal safe. Outside of the kernel, making a function async-signal safe usually requires that the function mask (block) signals while it runs — and that is expensive.</p>
<p class=book>In case you're curious, here is the full list of POSIX 1003.1-1996 functions that are async-signal safe (some of these functions exist only when certain POSIX options are defined, such as _POSIX_ASYNCHRONOUS_IO or _POSIX_TIMERS):</p>
<TABLE>
<TR>
<TD align = "left" >access</TD>
<TD align = "left" >getoverrun</TD>
<TD align = "left" >sigismember</TD>
</TR>
<TR>
<TD align = "left" >aio_error</TD>
<TD align = "left" >getgroups</TD>
<TD align = "left" >sigpending</TD>
</TR>
<TR>
<TD align = "left" >aio_return</TD>
<TD align = "left" >getpgrp</TD>
<TD align = "left" >sigprocmask</TD>
</TR>
<TR>
<TD align = "left" >aio_suspend</TD>
<TD align = "left" >getpid</TD>
<TD align = "left" >sigqueue</TD>
</TR>
<TR>
<TD align = "left" >alarm</TD>
<TD align = "left" >getppid</TD>
<TD align = "left" >sigsuspend</TD>
</TR>
<TR>
<TD align = "left" >cfgetispeed</TD>
<TD align = "left" >getuid</TD>
<TD align = "left" >sleep</TD>
</TR>
<TR>
<TD align = "left" >cfgetospeed</TD>
<TD align = "left" >kill</TD>
<TD align = "left" >stat</TD>
</TR>
<TR>
<TD align = "left" >cfsetispeed</TD>
<TD align = "left" >link</TD>
<TD align = "left" >sysconf</TD>
</TR>
<TR>
<TD align = "left" >cfsetospeed</TD>
<TD align = "left" >lseek</TD>
<TD align = "left" >tcdrain</TD>
</TR>
<TR>
<TD align = "left" >chdir</TD>
<TD align = "left" >mkdir</TD>
<TD align = "left" >tcflow</TD>
</TR>
<TR>
<TD align = "left" >chmod</TD>
<TD align = "left" >mkfifo</TD>
<TD align = "left" >tcflush</TD>
</TR>
<TR>
<TD align = "left" >chown</TD>
<TD align = "left" >open</TD>
<TD align = "left" >tcgetattr</TD>
</TR>
<TR>
<TD align = "left" >clock_gettime</TD>
<TD align = "left" >pathconf</TD>
<TD align = "left" >tcgetpgrp</TD>
</TR>
<TR>
<TD align = "left" >close</TD>
<TD align = "left" >pause</TD>
<TD align = "left" >tcsendbreak</TD>
</TR>
<TR>
<TD align = "left" >creat</TD>
<TD align = "left" >pipe</TD>
<TD align = "left" >tcsetattr</TD>
</TR>
<TR>
<TD align = "left" >dup2</TD>
<TD align = "left" >read</TD>
<TD align = "left" >tcsetpgrp</TD>
</TR>
<TR>
<TD align = "left" >dup</TD>
<TD align = "left" >rename</TD>
<TD align = "left" >time</TD>
</TR>
<TR>
<TD align = "left" >execle</TD>
<TD align = "left" >rmdir</TD>
<TD align = "left" >timer_getoverrun</TD>
</TR>
<TR>
<TD align = "left" >execve</TD>
<TD align = "left" >sem_post</TD>
<TD align = "left" >timer_gettime</TD>
</TR>
<TR>
<TD align = "left" >_exit</TD>
<TD align = "left" >setgid</TD>
<TD align = "left" >timer_settime</TD>
</TR>
<TR>
<TD align = "left" >fcntl</TD>
<TD align = "left" >setpgid</TD>
<TD align = "left" >times</TD>
</TR>
<TR>
<TD align = "left" >fdatasync</TD>
<TD align = "left" >setsid</TD>
<TD align = "left" >umask</TD>
</TR>
<TR>
<TD align = "left" >fork</TD>
<TD align = "left" >setuid</TD>
<TD align = "left" >uname</TD>
</TR>
<TR>
<TD align = "left" >fstat</TD>
<TD align = "left" >sigaction</TD>
<TD align = "left" >unlink</TD>
</TR>
<TR>
<TD align = "left" >fsync</TD>
<TD align = "left" >sigaddset</TD>
<TD align = "left" >utime</TD>
</TR>
<TR>
<TD align = "left" >getegid</TD>
<TD align = "left" >sigdelset</TD>
<TD align = "left" >wait</TD>
</TR>
<TR>
<TD align = "left" >geteuid</TD>
<TD align = "left" >sigemptyset</TD>
<TD align = "left" >waitpid</TD>
</TR>
<TR>
<TD align = "left" >getgid</TD>
<TD align = "left" >sigfillset</TD>
<TD align = "left" >write</TD>
</TR>
</TABLE>
<p class=book>POSIX.1b provides counting semaphores, and most systems that support Pthreads also support POSIX.1b semaphores. You may notice that the sem_post function, which wakes threads waiting on a semaphore, appears in the list of async-signal safe functions. If your system supports POSIX semaphores (&lt;unistd.h&gt; defines the _POSIX_SEMAPHORES option), then Pthreads adds the ability to use semaphores between threads within a process. That means you can <i>post</i> a semaphore, from within a POSIX signal-catching function, to wake a thread in the same process or in another process.</p>
<p class=book>A semaphore is a different kind of synchronization object — it is a little like a mutex, a little like a condition variable. The differences can make semaphores a little harder to use for many common tasks, but they make semaphores substantially easier to use for certain specialized purposes. In particular, semaphores can be <i>posted</i> (unlocked or signaled) from a POSIX signal-catching function.</p>
<p class=book>Semaphores are a general synchronization mechanism. We just have no reason to use them that way.</p>
<p class=book>I am emphasizing the use of semaphores to pass information from a signal-catching function, rather than for general use, for a couple of reasons. One reason is that semaphores are part of a different standard. As I said, most systems that support Pthreads will also support POSIX. lb, but there is no such requirement anywhere in the standard. So you may well find yourself without access to semaphores, and you shouldn't feel dependent on them. {Of course, you may also find yourself <i>with</i> semaphores and <i>without</i> threads — but in that case, you should be reading a different book.)</p>
<p class=book>Another reason for keeping semaphores here with signals is that, although semaphores are a completely general synchronization mechanism, it can be more difficult to solve many problems using semaphores—mutexes and condition variables are simpler. If you've got Pthreads, you only <i>need</i> semaphores to handle this one specialized function — waking a waiting thread from a signal-catching function. Just remember that you <i>can</i> use them for other things when they're convenient and available.</p>
<p class=book>POSIX semaphores contain a count, but no "owner," so although they can be used essentially as a lock, they can also be used to wait for events. The terminology used in the POSIX semaphore operations stresses the "wait" behavior rather than the "lock" behavior. Don't be confused by the names, though; there's no difference between "waiting" on a semaphore and "locking" the semaphore.</p>
<p class=book>A thread waits on a semaphore (to lock a resource, or wait for an event) by calling sem_wait. If the semaphore counter is greater than zero, sem_wait decrements the counter and returns immediately. Otherwise, the thread blocks. A thread can post a semaphore (to unlock a resource, or awaken a waiter) by calling sem_post. If one or more threads are waiting on the semaphore, sem_post will wake one waiter (the highest priority, or earliest, waiter). If no threads are waiting, the semaphore counter is incremented.</p>
<p class=book>The initial value of the semaphore counter is the distinction between a "lock" semaphore and a "wait" semaphore. By creating a semaphore with an initial count of 1, you allow one thread to complete a sem_wait operation without blocking— this "locks" the semaphore. By creating a semaphore with an initial count of 0, you force all threads that call sem_wait to block until some thread calls sem_post.</p>
<p class=book>The differences in how semaphores work give the semaphore two important advantages over mutexes and condition variables that may be of use in threaded programs:</p>
<p class=book>1. Unlike mutexes, semaphores have no concept of an "owner." This means that any thread may release threads blocked on a semaphore, much as if any thread could unlock a mutex that some thread had locked. (Although this is usually not a good programming model, there are times when it is handy.)</p>
<p class=book>2. Unlike condition variables, semaphores can be independent of any external state. Condition variables depend on a shared predicate and a mutex for waiting—semaphores do not.</p>
<p class=book>A semaphore is represented in your program by a variable of type sem_t. You should never make a copy of a sem_t variable — the result of using a copy of a sem_t variable in the sem_wait, sem_trywait, sem_post, and sem_destroy functions is undefined. For our purposes, a sem_t variable is initialized by calling the sem_init function. POSIX. lb provides other ways to create a "named" semaphore that can be shared between processes without sharing memory, but there is no need for this capability when using a semaphore within a single process.</p>
<p class=book>Unlike Pthreads functions, the POSIX semaphore functions use errno to report errors. That is, success is designated by returning the value 0, and errors are designated by returning the value -1 and setting the variable errno to an error code.</p>
<p class=book>If you have a section of code in which you want up to two threads to execute simultaneously while others wait, you can use a semaphore without any additional state. Initialize the semaphore to the value 2; then put a sem_wait at the beginning of the code and a sem_post at the end. Two threads can then <i>wait</i> on the semaphore without blocking, but a third thread will find the semaphore's counter at 0, and block. As each thread exits the region of code it <i>posts</i> the semaphore, releasing one waiter (if any) or restoring the counter.</p>
<p class=book>The sem_getvalue function returns the current value of the semaphore counter if there are no threads waiting. If threads are waiting, sem_getvalue returns a negative number. The absolute value of that number tells how many threads are waiting on the semaphore. Keep in mind that the value it returns may already be incorrect — it can change at any time due to the action of some other thread.</p>
<p class=book>The best use for sem_getvalue is as a way to wake multiple waiters, somewhat like a condition variable broadcast. Without sem_getvalue, you have no way of knowing how many threads might be blocked on a semaphore. To "broadcast" a semaphore, you could call sem_getvalue and sem_post in a loop until sem_getvalue reports that there are no more waiters.</p>
<p class=book>But remember that other threads can call sem_post during this loop, and there is no synchronization between the various concurrent calls to sem_post and sem_getvalue. You can easily end up issuing one or more extra calls to sem_post, which will cause the next thread that calls sem_wait to find a value greater than 0, and return immediately without blocking.</p>
<p class=book>The program below, semaphore_signal.c, uses a semaphore to awaken threads from within a POSIX signal-catching function. Notice that the sem_init call sets the initial value to 0 so that each thread calling sem_wait will block. The main program then requests an interval timer, with a POSIX signal-catching function that will wake one waiting thread by calling sem_post. Each occurrence of the POSIX timer signal will awaken one waiting thread. The program will exit when each thread has been awakened five times.</p>
<p class=book><b>32-35</b> Notice the code to check for EINTR return status from the sem_wait call. The POSIX timer signal in this program will always occur while one or more threads are blocked in sem_wait. When a signal occurs for a process (such as a timer signal), the system may deliver that signal within the context of any thread within the process. Likely "victims" include threads that the kernel knows to be waiting, for example, on a semaphore. So there is a fairly good chance that the sem_wait thread will be chosen, at least sometimes. If that occurs, the call to sem_wait will return with EINTR. The thread must then retry the call. Treating an EINTR return as "success" would make it appear that two threads had been awakened by each call to sem_post: the thread that was interrupted, and the thread that was awakened by the sem_post call.</p>
<p class=book>■ semaphore_signal.c</p>
<p class=book><CODE>1 #include &lt;sys/types.h&gt;</CODE></p>
<p class=book><CODE>2 #include &lt;unistd.h&gt;</CODE></p>
<p class=book><CODE>3 #include &lt;pthread.h&gt;</CODE></p>
<p class=book><CODE>4 #include &lt;semaphore.h&gt;</CODE></p>
<p class=book><CODE>5 #include &lt;signal.h&gt;</CODE></p>
<p class=book><CODE>6 #include &lt;time.h&gt;</CODE></p>
<p class=book><CODE>7 #include "errors.h"</CODE> </p>
<p class=book><CODE>8</CODE></p>
<p class=book><CODE>9 sem_t semaphore;</CODE> </p>
<p class=book><CODE>10</CODE></p>
<p class=book><CODE>11 /*</CODE></p>
<p class=book><CODE>12 * Signal-catching function.</CODE></p>
<p class=book><CODE>13 */</CODE></p>
<p class=book><CODE>14 void signal_catcher (int sig)</CODE></p>
<p class=book><CODE>15 {</CODE></p>
<p class=book><CODE>16 	if (sem_post (&semaphore) == -1)</CODE></p>
<p class=book><CODE>17 		errno_abort ("Post semaphore");</CODE></p>
<p class=book><CODE>18 }</CODE> </p>
<p class=book><CODE>19</CODE></p>
<p class=book><CODE>20 /*</CODE></p>
<p class=book><CODE>21 * Thread start routine which waits on the semaphore.</CODE></p>
<p class=book><CODE>22 */</CODE></p>
<p class=book><CODE>23 void *sem_waiter (void *arg)</CODE></p>
<p class=book><CODE>24 {</CODE></p>
<p class=book><CODE>25 int number = (int)arg;</CODE></p>
<p class=book><CODE>26 int counter;</CODE> </p>
<p class=book><CODE>27</CODE></p>
<p class=book><CODE>28 /*</CODE></p>
<p class=book><CODE>29 * Each thread waits 5 times.</CODE></p>
<p class=book><CODE>30 */</CODE></p>
<p class=book><CODE>31 for (counter = 1; counter &lt;= 5; counter++) {</CODE></p>
<p class=book><CODE>32 while (sem_wait (&semaphore) == -1) {</CODE></p>
<p class=book><CODE>33 	if (errno != EINTR)</CODE></p>
<p class=book><CODE>34 		errno_abort ("Wait on semaphore");</CODE></p>
<p class=book><CODE>35 }</CODE></p>
<p class=book><CODE>36 printf ("%d waking (%d)...\n", number, counter);</CODE></p>
<p class=book><CODE>37 }</CODE></p>
<p class=book><CODE>38 return NULL;</CODE></p>
<p class=book><CODE>39 }</CODE> </p>
<p class=book><CODE>40</CODE></p>
<p class=book><CODE>41 int main (int argc, char *argv[])</CODE></p>
<p class=book><CODE>42 {</CODE></p>
<p class=book><CODE>43 int thread_count, status;</CODE></p>
<p class=book><CODE>44 struct sigevent sig_event;</CODE></p>
<p class=book><CODE>45 struct sigaction sig_action;</CODE></p>
<p class=book><CODE>46 sigset_t sig_mask;</CODE></p>
<p class=book><CODE>47 timer_t timer_id;</CODE></p>
<p class=book><CODE>48 struct itimerspec timer_val;</CODE></p>
<p class=book><CODE>49 pthread_t sem_waiters[5];</CODE></p>
<p class=book><CODE>50</CODE></p>
<p class=book><CODE>51 #if !defined(_POSIX_SEMAPHORES) || !defined(_POSIX_TIMERS)</CODE></p>
<p class=book><CODE>52 #if !defined(_POSIX_SEMAPHORES)</CODE></p>
<p class=book><CODE>53 printf ("This system does not support POSIX semaphores\n");</CODE></p>
<p class=book><CODE>54 # endif</CODE></p>
<p class=book><CODE>55 #if !defined(_POSIX_TIMERS)</CODE></p>
<p class=book><CODE>56 printf ("This system does not support POSIX timers\n");</CODE></p>
<p class=book><CODE>57 #endif</CODE></p>
<p class=book><CODE>58 return -1;</CODE></p>
<p class=book><CODE>59 #else</CODE></p>
<p class=book><CODE>60 sem_init (&semaphore, 0, 0);</CODE> </p>
<p class=book><CODE>61</CODE></p>
<p class=book><CODE>62 /*</CODE></p>
<p class=book><CODE>63 * Create 5 threads to wait on a semaphore.</CODE></p>
<p class=book><CODE>64 */</CODE></p>
<p class=book><CODE>65 for (thread_count = 0; thread_count &lt; 5; thread_count++) {</CODE></p>
<p class=book><CODE>66 	status = pthread_create (</CODE></p>
<p class=book><CODE>67 		&sem_waiters[thread_count], NULL,</CODE></p>
<p class=book><CODE>68 		sem_waiter, (void*)thread_count);</CODE></p>
<p class=book><CODE>69 if (status != 0)</CODE></p>
<p class=book><CODE>70 	err_abort (status, "Create thread");</CODE></p>
<p class=book><CODE>71 }</CODE> </p>
<p class=book><CODE>72</CODE></p>
<p class=book><CODE>73 /*</CODE></p>
<p class=book><CODE>74 * Set up a repeating timer using signal number SIGRTMIN,</CODE></p>
<p class=book><CODE>75 * set to occur every 2 seconds.</CODE></p>
<p class=book><CODE>76 */</CODE></p>
<p class=book><CODE>77 sig_event.sigev_value.sival_int = 0;</CODE></p>
<p class=book><CODE>78 sig_event.sigev_signo = SIGRTMIN;</CODE></p>
<p class=book><CODE>79 sig_event.sigev_notify = SIGEV_SIGNAL;</CODE></p>
<p class=book><CODE>80 if (timer_create (CLOCK_REALTIME, &sig_event, &timer_id) == -1)</CODE></p>
<p class=book><CODE>81 	errno_abort ("Create timer");</CODE></p>
<p class=book><CODE>82 sigemptyset (&sig_mask);</CODE></p>
<p class=book><CODE>83 sigaddset (&sig_mask, SIGRTMIN);</CODE></p>
<p class=book><CODE>84 sig_action.sa_handler = signal_catcher;</CODE></p>
<p class=book><CODE>85 sig_action.sa_mask = sig mask;</CODE></p>
<p class=book><CODE>86 sig_action.sa_flags = 0;</CODE></p>
<p class=book><CODE>87 if (sigaction (SIGRTMIN, &sig_action, NULL) == -1)</CODE></p>
<p class=book><CODE>88 errno_abort ("Set signal action");</CODE></p>
<p class=book><CODE>89 timer_val.it_interval.tv_sec = 2;</CODE></p>
<p class=book><CODE>90 timer_val.it_interval.tv_nsec = 0;</CODE></p>
<p class=book><CODE>91 timer_val.it_value.tv_sec = 2;</CODE></p>
<p class=book><CODE>92 timer_val.it_value.tv_nsec = 0;</CODE></p>
<p class=book><CODE>93 if (timer_settime (timer_id, 0, &timer_val, NULL) == -1)</CODE></p>
<p class=book><CODE>94 errno_abort ("Set timer");</CODE> </p>
<p class=book><CODE>95</CODE></p>
<p class=book><CODE>96 /*</CODE></p>
<p class=book><CODE>97 * Wait for all threads to complete.</CODE></p>
<p class=book><CODE>98 */</CODE></p>
<p class=book><CODE>99 for (thread_count = 0; thread_count &lt; 5; thread_count++) {</CODE></p>
<p class=book><CODE>100 	status = pthread_join (sem_waiters[thread_count], NULL);</CODE></p>
<p class=book><CODE>101 	if (status != 0)</CODE></p>
<p class=book><CODE>102 		err_abort (status, "Join thread");</CODE></p>
<p class=book><CODE>103 }</CODE></p>
<p class=book><CODE>104 return 0;</CODE></p>
<p class=book><CODE>105 #endif</CODE></p>
<p class=book><CODE>106 }</CODE></p>




<a name=t114></a><h3 class=book>
<b>7 "Real code"</b>
</h3>
<blockquote class="epigraph">
<p class=book>"When we were still little," the Mock Turtle went on at last, more calmly, though still sobbing a little now and then, "we went to school in the sea. The master was an old Turtle — we used to call him Tortoise—"</p>
<p class=book>"Why did you call him Tortoise, if he wasn't one?" Alice asked.</p>
<p class=book>"We called him Tortoise because he taught us," said the Mock Turtle angrily.</p>
<blockquote class=book><i>— <i>Lewis Carroll, Through the Looking-Glass</i></i></blockquote>
</blockquote>

<p class=book>This section builds on most of the earlier sections of the book, but principally on the mutex and condition variable sections. You should already understand how to create both types of synchronization objects and how they work. I will demonstrate the design and construction of <i>barrier</i> and <i>read/write lock</i> synchronization mechanisms that are built from mutexes, condition variables, and a dash of data. Both barriers and read/write locks are in common use. and have been proposed for standardization in the near future. I will follow up with a <i>queue</i> server that lets you parcel out tasks to a pool of threads.</p>
<p class=book>The purpose of all this is to teach you more about the subtleties of using of these new threaded programming tools (that is, mutexes, condition variables and threads). The library packages may be useful to you as is or as templates. Primar-ily, though, they are here to give me something to talk about in this section and I have omitted some complication that may be valuable in real code. The error detection and recovery code, for example, is fairly primitive.</p>


<a name=t115></a><h3 class=book>
7.1 Extended synchronization
</h3>

<p class=book>Mutexes and condition variables are flexible and efficient synchronization. tools. You can build just about any form of synchronization you need using those two things. But you shouldn't build them from scratch every time you need them. It is nice to start with a general, modular implementation that doesn't need to be debugged every time. This section shows some common and useful tools that you won't have to redesign every time you write an application that needs them.</p>
<p class=book>First we'll build a <i>barrier.</i> The function of a barrier is about what you might guess — it stops threads. A barrier is initialized to stop a certain number of threads — when the required number of threads have reached the barrier, all are allowed to continue.</p>
<p class=book>Then we'll build something called a <i>read/write lock.</i> A read/write lock allows multiple threads to read data simultaneously, but prevents any thread from modifying data that is being read or modified by another thread.</p>


<a name=t116></a><h3 class=book>
7.1.1 Barriers
</h3>
<p class=book>A barrier is a way to keep the members of a group together. If our intrepid "bailing programmers" washed up on a deserted island, for example, and they ventured into the jungle to explore, they would want to remain together, for the illusion of safety in numbers, if for no other reason (Figure 7.1). Any exploring programmer finding himself very far in front of the others would therefore wait for them before continuing.</p>
<p class=book>A barrier is usually employed to ensure that all threads cooperating in some parallel algorithm reach a specific point in that algorithm before any can pass. This is especially common in code that has been <i>decomposed</i> automatically by creating fine-grained parallelism within compiled source code. All threads may execute the same code, with threads processing separate portions of a shared data set (such as an array) in some areas and processing private data in parallel</p>
<img border=0 style='spacing 9px;' src="img_21.png">
<br>
<p class=book><b>FIGURE 7.1</b> <i>Barrier analogy</i></p>
<p class=book>in other areas. Still other areas must be executed by only one thread, such as setup or cleanup for the parallel regions. The boundaries between these areas are often implemented using barriers. Thus, threads completing a matrix computation may wait at a barrier until all have finished. One may then perform setup for the next parallel segment while the others skip ahead to another barrier. When the setup thread reaches that barrier, all threads begin the next parallel region.</p>
<p class=book>Figure 7.2 shows the operation of a barrier being used to synchronize three threads, called thread 1, thread 2, and thread 3. The figure is a sort of timing diagram, with time increasing from left to right. Each of the lines beginning at the labels in the upper left designates the behavior of a specific thread — solid for thread 1, dotted for thread 2, and dashed for thread 3. When the lines drop within the rounded rectangle, they are interacting with the barrier. If the line drops below the center line, it shows that the thread is blocked waiting for other threads to reach the barrier. The line that stops above the center line represents the final thread to reach the barrier, awakening all waiters.</p>
<p class=book>In this example, thread 1 and then thread 2 wait on the barrier. At a later time, thread 3 waits on the barrier, finds that the barrier is now full, and awakens all the waiters. All three threads then return from the barrier wait.</p>
<p class=book>The core of a barrier is a <i>counter.</i> The counter is initialized to the number of threads in the "tour group," the number of threads that must wait on a barrier before all the waiters return. I'll call that the "threshold," to give it a simple one-word name. When each thread reaches the barrier, it decreases the counter. If the value hasn't reached 0, it waits. If the value has reached 0, it wakes up the waiting threads.</p>
<img border=0 style='spacing 9px;' src="img_22.png">
<br>
<p class=book><b>FIGURE 7.2</b> <i>Barrier operation</i></p>
<br>
<p class=book>Because the counter will be modified by multiple threads, it has to be protected by a mutex. Because threads will be waiting for some event (a counter value of 0), the barrier needs to have a condition variable and a predicate expression. When the counter reaches 0 and the barrier drops open, we need to reset the counter, which means the barrier must store the original threshold.</p>
<p class=book>The obvious predicate is to simply wait for the counter to reach 0, but that complicates the process of resetting the barrier. When can we reset the count to the original value? We can't reset it when the counter reaches 0, because at that point most of the threads are waiting on the condition variable. The counter must be 0 when they wake up, or they'll continue waiting. Remember that condition variable waits occur in loops that retest the predicate.</p>
<p class=book>The best solution is to add a separate variable for the predicate. We will use a "cycle" variable that is logically inverted each time some thread determines that one cycle of the barrier is complete. That is, whenever the counter value is reset, before broadcasting the condition variable, the thread inverts the cycle flag. Threads wait in a loop as long as the cycle flag remains the same as the value seen on entry, which means that each thread must save the initial value.</p>
<p class=book>The header file barrier.h and the C source file barrier.c demonstrate an implementation of barriers using standard Pthreads mutexes and condition variables. This is a portable implementation that is relatively easy to understand. One could, of course, create a much more efficient implementation for any specific system based on knowledge of nonportable hardware and operating system characteristics.</p>
<p class=book><b>6-13</b> Part 1 shows the structure of a barrier, represented by the type barrier_t. You can see the mutex (mutex) and the condition variable (cv). The threshhold member is the number of threads in the group, whereas counter is the number of threads that have yet to join the group at the barrier. And cycle is the flag discussed in the previous paragraph. It is used to ensure that a thread awakened from a barrier wait will immediately return to the caller, but will block in the barrier if it calls the wait operation again before all threads have resumed execution. </p>
<p class=book><b>15</b> The <b>BARRIER_VALID</b> macro defines a "magic number," which we store into the valid member and then check to determine whether an address passed to other barrier interfaces is "reasonably likely to be" a barrier. This is an easy, quick check that will catch the most common errors.<sup><a name=r7><a href="#n7" title="
I always like to define magic numbers using hexadecimal constants that can be pronounced as English words. For barriers, I invented my own restaurant called the &quot;DB cafe,&quot; or, in C syntax, Oxdbcafe. Many interesting (or at least mildly amusing) English words can be spelled using only the letters a through f. There are even more possibilities if you allow the digit 1 to stand in for the letter 1. and the digit 0 to stand in for the letter o. (Whether you like the results will depend a lot on the typeface in which you commonly read your code.)
">[7]</sup></A></p>
<p class=book>■ barrier.h  part 1 barrier_t</p>
<p class=book><CODE>1 #include &lt;pthread.h&gt;</CODE> </p>
<p class=book><CODE>2</CODE></p>
<p class=book><CODE>3 /*</CODE></p>
<p class=book><CODE>4 * Structure describing a barrier.</CODE></p>
<p class=book><CODE>5 */</CODE></p>
<p class=book><CODE>6 typedef struct barrier_tag {</CODE></p>
<p class=book><CODE>7	pthread_mutex_t	mutex;	/*	Control access to	barrier *	/</CODE></p>
<p class=book><CODE>8	pthread_cond_t	cv;	/*	wait for barrier	*/	</CODE></p>
<p class=book><CODE>9	int	valid;	/*	set when valid */		</CODE></p>
<p class=book><CODE>10	int	threshold;	/*	number of threads	required	*/</CODE></p>
<p class=book><CODE>11	int	counter;	/*	current number of	threads *	/</CODE></p>
<p class=book><CODE>12	int	cycle;	/*	alternate cycles	(0 or 1) *	/</CODE></p>
<p class=book><CODE>13 } barrier_t;</CODE> </p>
<p class=book><CODE>14</CODE></p>
<p class=book><CODE>15 #define BARRIER_VALID 0xdbcafe</CODE></p>
<p class=book>Part 2 shows definitions and prototypes that allow you to do something with the barrier_t structure. First, you will want to initialize a new barrier. 4-6 You can initialize a static barrier at compile time by using the macro BARRIER_ INITIALIZER. You can instead dynamically initialize a barrier by calling the function barrier_init.</p>
<p class=book><b>11-13</b> Once you have initialized a barrier, you will want to be able to use it. and the main thing to be done with a barrier is to wait on it. When we're done with a barrier, it would be nice to be able to destroy the barrier and reclaim the resources it used. We'll call these operations <CODE>barrier_init</CODE>, <CODE>barrier_wait</CODE>, and barrier_ destroy. All the operations need to specify upon which barrier they will operate. Because barriers are synchronization objects, and contain both a mutex and a condition variable (neither of which can be copied), we always pass a pointer to a barrier. Only the initialization operation requires a second parameter, the number of waiters required before the barrier opens.</p>
<p class=book>To be consistent with Pthreads conventions, the functions all return an integer value, representing an error number defined in &lt;errno.h&gt;. The value 0 represents success.</p>
<p class=book>■ barrier.h part 2 interfaces</p>
<p class=book><CODE>1 /*</CODE></p>
<p class=book><CODE>2 * Support static initialization of barriers.</CODE></p>
<p class=book><CODE>3 */</CODE></p>
<p class=book><CODE>4 #define BARRIER_INITIALIZER(cnt) \</CODE></p>
<p class=book><CODE>5 {PTHREAD_MUTEX_INITIALIZER, PTHREAD_COND_INITIALIZER, \</CODE></p>
<p class=book><CODE>6 BARRIER_VALID, cnt, cnt, 0}</CODE> </p>
<p class=book><CODE>7</CODE></p>
<p class=book><CODE>8 /*</CODE></p>
<p class=book><CODE>9 * Define barrier functions</CODE></p>
<p class=book><CODE>10 */</CODE></p>
<p class=book><CODE>11 extern int barrier_init (barrier_t *barrier, int count);</CODE></p>
<p class=book><CODE>12 extern int barrier_destroy (barrier_t *barrier);</CODE></p>
<p class=book><CODE>13 extern int barrier_wait (barrier_t *barrier);</CODE></p>
<p class=book>Now that you know the interface definition, you could write a program using barriers. But then, the point of this section is not to tell you how to use barriers, but to help improve your understanding of threaded programming by showing how to build a barrier. The following examples show the functions provided by barrier .c, to implement the interfaces we've just seen in barrier.h.</p>
<p class=book>Part 1 shows <CODE>barrier_init</CODE>, which you would call to dynamically initialize a barrier, for example, if you allocate a barrier with <CODE>malloc</CODE>. </p>
<p class=book><b>12</b> Both the counter and threshold are set to the same value. The counter is the "working counter" and will be reset to threshold for each barrier cycle. </p>
<p class=book><b>14-16</b> If mutex initialization fails, <CODE>barrier_init</CODE> returns the failing status to the caller.</p>
<p class=book><b>17-21</b> If condition variable (<CODE>cv</CODE>) initialization fails, <CODE>barrier_init</CODE> destroys the mutex it had already created and returns the failure status — the status of <CODE>pthread_mutex_destroy</CODE> is ignored because the failure to create the condition variable is more important than the failure to destroy the mutex. </p>
<p class=book><b>22</b> The barrier is marked valid only after all initialization is complete. This does not completely guarantee that another thread erroneously trying to wait on that barrier will detect the invalid barrier rather than failing in some less easily diag-nosable manner, but at least it is a token attempt.</p>
<p class=book>■ barrier.c part 1 barrier_init</p>
<p class=book><CODE>1 #include &lt;pthread.h&gt;</CODE></p>
<p class=book><CODE>2 #include "errors.h"</CODE></p>
<p class=book><CODE>3 #include "barrier.h"</CODE></p>
<p class=book><CODE>4</CODE></p>
<p class=book><CODE>5 /*</CODE></p>
<p class=book><CODE>6 * Initialize a barrier for use.</CODE></p>
<p class=book><CODE>7 */</CODE></p>
<p class=book><CODE>8 int barrier_init (barrier_t *barrier, int count)</CODE></p>
<p class=book><CODE>9 {</CODE></p>
<p class=book><CODE>10 int status; 11</CODE></p>
<p class=book><CODE>12 barrier-&gt;threshold = barrier-&gt;counter = count;</CODE></p>
<p class=book><CODE>13 barrier-&gt;cycle = 0;</CODE></p>
<p class=book><CODE>14 status = pthread_mutex_init (&barrier-&gt;mutex, NULL);</CODE></p>
<p class=book><CODE>15 if (status != 0)</CODE></p>
<p class=book><CODE>16 	return status;</CODE></p>
<p class=book><CODE>17 status = pthread_cond_init (&barrier-&gt;cv, NULL);</CODE></p>
<p class=book><CODE>18 if (status != 0) {</CODE></p>
<p class=book><CODE>19 	pthread_mutex_destroy (&barrier-&gt;mutex);</CODE></p>
<p class=book><CODE>20 	return status;</CODE></p>
<p class=book><CODE>21 }</CODE></p>
<p class=book><CODE>22 barrier-&gt;valid = BARRIER_VALID;</CODE></p>
<p class=book><CODE>23 return 0;</CODE></p>
<p class=book><CODE>24 }</CODE></p>
<p class=book>Part 2 shows the barrier_destroy function, which destroys the mutex and condition variable (cv) in the barrier_t structure. If we had allocated any additional resources for the barrier, we would need to release those resources also. 8-9 First check that the barrier appears to be valid, and initialized, by looking at the valid member. We don't lock the mutex first, because that will fail, possibly with something nasty like a segmentation fault, if the mutex has been destroyed or hasn't been initialized. Because we do not lock the mutex first, the validation check is not entirely reliable, but it is better than nothing, and will only fail to detect some race conditions where one thread attempts to destroy a barrier while another is initializing it, or where two threads attempt to destroy a barrier at nearly the same time.</p>
<p class=book><b>19-22</b> If any thread is currently waiting on the barrier, return EBUSY.</p>
<p class=book><b>24-27</b> At this point, the barrier is "destroyed"—all that's left is cleanup. To minimize the chances of confusing errors should another thread try to wait on the barrier before we're done, mark the barrier "not valid" by clearing valid, before changing any other state. Then, unlock the mutex, since we cannot destroy it while it is locked.</p>
<p class=book><b>33-35</b> Destroy the mutex and condition variable. If the mutex destruction fails return the status; otherwise, return the status of the condition variable destruc-tion. Or, to put it another way, return an error status if either destruction failed otherwise, return success.</p>
<p class=book>■ <b>barrier.c part 2 barrier_destroy</b></p>
<p class=book><CODE>1 /*</CODE></p>
<p class=book><CODE>2 * Destroy a barrier when done using it.</CODE></p>
<p class=book><CODE>3 */</CODE></p>
<p class=book><CODE>4 int barrier_destroy (barrier_t *barrier)</CODE></p>
<p class=book><CODE>5 {</CODE></p>
<p class=book><CODE>6 int status, status2;</CODE> </p>
<p class=book><CODE>7</CODE></p>
<p class=book><CODE>8 if (barrier-&gt;valid != BARRIER_VALID)</CODE></p>
<p class=book><CODE>9 	return EINVAL;</CODE> </p>
<p class=book><CODE>10</CODE></p>
<p class=book><CODE>11 status = pthread_mutex_lock (&barrier-&gt;mutex);</CODE></p>
<p class=book><CODE>12 if (status != 0)</CODE></p>
<p class=book><CODE>13 	return status;</CODE> </p>
<p class=book><CODE>14</CODE></p>
<p class=book><CODE>15 /*</CODE></p>
<p class=book><CODE>16 * Check whether any threads are known to be waiting; report</CODE></p>
<p class=book><CODE>17 * "BUSY" if so.</CODE></p>
<p class=book><CODE>18 */</CODE></p>
<p class=book><CODE>19 if (barrier-&gt;counter != barrier-&gt;threshold) {</CODE></p>
<p class=book><CODE>20 	pthread_mutex_unlock (&barrier-&gt;mutex);</CODE></p>
<p class=book><CODE>21 	return EBUSY;</CODE></p>
<p class=book><CODE>22 }</CODE> </p>
<p class=book><CODE>23</CODE></p>
<p class=book><CODE>24 barrier-&gt;valid = 0;</CODE></p>
<p class=book><CODE>25 status = pthread_mutex_unlock (&barrier-&gt;mutex);</CODE></p>
<p class=book><CODE>26 if (status != 0)</CODE></p>
<p class=book><CODE>27 return status;</CODE> </p>
<p class=book><CODE>28</CODE></p>
<p class=book><CODE>29 /*</CODE></p>
<p class=book><CODE>30 * If unable to destroy either 1003.1c synchronization</CODE></p>
<p class=book><CODE>31 * object, return the error status.</CODE></p>
<p class=book><CODE>32 */</CODE></p>
<p class=book><CODE>33 status = pthread_mutex_destroy (&barrier-&gt;mutex);</CODE></p>
<p class=book><CODE>34 status2 = pthread_cond_destroy (&barrier-&gt;cv);</CODE></p>
<p class=book><CODE>35 return (status == 0 ? status : status2);</CODE></p>
<p class=book><CODE>36 }</CODE></p>
<p class=book>Finally, part 3 shows the implementation ofbarrier_wait.</p>
<p class=book><b>10-11</b> First we verify that the argument barrier appears to be a valid barrier_t. We</p>
<p class=book>perform this check before locking the mutex, so that barrier_destroy can safely destroy the mutex once it has cleared the valid member. This is a simple attempt to minimize the damage if one thread attempts to wait on a barrier while another thread is simultaneously either initializing or destroying that barrier.</p>
<p class=book>We cannot entirely avoid problems, since without the mutex, barrier_wait has no guarantee that it will see the correct (up-to-date) value of valid. The valid check may succeed when the barrier is being made invalid, or fail when the barrier is being made valid. Locking the mutex first would do no good, because the mutex may not exist if the barrier is not fully initialized, or if it is being destroyed. This isn't a problem as long as you use the barrier correctly — that is, you initialize the barrier before any thread can possibly try to use it, and do not destroy the barrier until you are sure no thread will try to use it again. </p>
<p class=book><b>17</b> Copy the current value of the barrier's cycle into a local variable. The comparison of our local cycle against the barrier_t structure's cycle member becomes our condition wait predicate. The predicate ensures that all currently waiting threads will return from barrier_wait when the last waiter broadcasts the condition variable, but that any thread that calls barrier_wait again will wait for the next broadcast. (This is the "tricky part" of correctly implementing a barrier.)</p>
<p class=book><b>19-22</b> Now we decrease counter, which is the number of threads that are required but haven't yet waited on the barrier. When counter reaches 0, no more threads are needed — they're all here and waiting anxiously to continue to the next attraction. Now all we need to do is tell them to wake up. We advance to the next cycle, reset the counter, and broadcast the barrier's condition variable. </p>
<p class=book><b>28-29</b> Earlier, I mentioned that a program often needs one thread to perform some cleanup or setup between parallel regions. Each thread could lock a mutex and check a flag so that only one thread would perform the setup. However, the setup may not need additional synchronization, for example, because the other threads will wait at a barrier for the next parallel region, and, in that case, it would be nice to avoid locking an extra mutex.</p>
<p class=book>The barrier_wait function has this capability built into it. One and only one thread will return with the special value of -1 while the others return 0. In this particular implementation, the one that waits last and wakes the others will take the honor, but in principle it is "unspecified" which thread returns -1. The thread that receives -1 can perform the setup, while others race ahead. If you do not need the special return status, treat -1 as another form of success. The proposed POSIX.1j standard has a similar capability — one (unspecified) thread completing a barrier will return the status BARRIER_SERIAL_THREAD. </p>
<p class=book><b>35</b> Any threaded code that uses condition variables should always either support deferred cancellation or disable cancellation. Remember that there are two distinct <i>types</i> of cancellation: <i>deferred</i> and <i>asynchronous.</i> Code that deals with asynchronous cancellation is rare. In general it is difficult or impossible to support asynchronous cancellation in any code that acquires resources (including locking a mutex). Programmers can't assume any function supports asynchronous cancellation unless its documentation specifically says so. Therefore we do not need to worry about asynchronous cancellation.</p>
<p class=book>We could code barrier_wait to deal with deferred cancellation, but that raises difficult questions. How, for example, will the barrier wait ever be satisfied if one of the threads has been canceled? And if it won't be satisfied, what happens to all the other threads that have already waited (or are about to wait) on that barrier? There are various ways to answer these questions. One would be for barrier_wait to record the thread identifiers of all threads waiting on the barrier, and for any thread that's canceled within the wait to cancel all other waiters.</p>
<p class=book>Or we might handle cancellation by setting some special error flag and broadcasting the condition variable, and modifying barrier_wait to return a special error when awakened in that way. However, it makes little sense to cancel one thread that's using a barrier. We're going to disallow it, by disabling cancellation prior to the wait, and restoring the previous state of cancellation afterward. This is the same approach taken by the proposed POSIX.1j standard, by the way—barrier waits are not cancellation points. 42-46 If there are more threads that haven't reached the barrier, we need to wait for them. We do that by waiting on the condition variable until the barrier has advanced to the next cycle — that is, the barrier's cycle no longer matches the local copy.</p>
<p class=book>■ barrier.c part 3 barrier_wait</p>
<p class=book><CODE>1 /*</CODE></p>
<p class=book><CODE>2 * Wait for all members of a barrier to reach the barrier. When</CODE></p>
<p class=book><CODE>3 * the count (of remaining members) reaches 0, broadcast to wake</CODE></p>
<p class=book><CODE>4 * all threads waiting.</CODE></p>
<p class=book><CODE>5 */</CODE></p>
<p class=book><CODE>6 int barrier_wait (barrier_t *barrier)</CODE></p>
<p class=book><CODE>7 {</CODE></p>
<p class=book><CODE>8 int status, cancel, tmp, cycle;</CODE> </p>
<p class=book><CODE>9</CODE></p>
<p class=book><CODE>10 if (barrier-&gt;valid != BARRIER_VALID)</CODE></p>
<p class=book><CODE>11 return EINVAL;</CODE> </p>
<p class=book><CODE>12</CODE></p>
<p class=book><CODE>13 status = pthread_mutex_lock (&barrier-&gt;mutex);</CODE></p>
<p class=book><CODE>14 if (status != 0)</CODE></p>
<p class=book><CODE>15 return status;</CODE> </p>
<p class=book><CODE>16</CODE></p>
<p class=book><CODE>17 cycle = barrier-&gt;cycle; /* Remember which cycle we're on */</CODE></p>
<p class=book><CODE>18</CODE></p>
<p class=book><CODE>19 if (--barrier-&gt;counter == 0) {</CODE></p>
<p class=book><CODE>20 	barrier-&gt;cycle = !barrier-&gt;cycle;</CODE></p>
<p class=book><CODE>21 	barrier-&gt;counter = barrier-&gt;threshold;</CODE></p>
<p class=book><CODE>22 	status = pthread_cond_broadcast (&barrier-&gt;cv);</CODE></p>
<p class=book><CODE>23 /*</CODE></p>
<p class=book><CODE>24 * The last thread into the barrier will return status</CODE></p>
<p class=book><CODE>25 * -1 rather than 0, so that it can be used to perform</CODE></p>
<p class=book><CODE>26 * some special serial code following the barrier.</CODE></p>
<p class=book><CODE>27 */</CODE></p>
<p class=book><CODE>28 	if (status == 0)</CODE></p>
<p class=book><CODE>29 		status = -1;</CODE></p>
<p class=book><CODE>30 } else {</CODE></p>
<p class=book><CODE>31 /*</CODE></p>
<p class=book><CODE>32 * Wait with cancellation disabled, because barrier_wait</CODE></p>
<p class=book><CODE>33 * should not be a cancellation point.</CODE></p>
<p class=book><CODE>34 */</CODE></p>
<p class=book><CODE>35 pthread_setcancelstate (PTHREAD_CANCEL_DISABLE, &cancel); 36</CODE></p>
<p class=book><CODE>37 /*</CODE></p>
<p class=book><CODE>38 * Wait until the barrier's cycle changes, which means</CODE></p>
<p class=book><CODE>39 * that it has been broadcast, and we don't want to wait</CODE></p>
<p class=book><CODE>40 * anymore.</CODE></p>
<p class=book><CODE>41 */</CODE></p>
<p class=book><CODE>42 while (cycle == barrier-&gt;cycle) {</CODE></p>
<p class=book><CODE>43 	status = pthread_cond_wait (</CODE></p>
<p class=book><CODE>44 		&barrier-&gt;cv, &barrier-&gt;mutex);</CODE></p>
<p class=book><CODE>45 	if (status != 0) break;</CODE></p>
<p class=book><CODE>46 }</CODE></p>
<p class=book><CODE>47</CODE></p>
<p class=book><CODE>48 pthread_setcancelstate (cancel, &tmp);</CODE></p>
<p class=book><CODE>49 }</CODE></p>
<p class=book><CODE>50 /*</CODE></p>
<p class=book><CODE>51 * Ignore an error in unlocking. It shouldn't happen, and</CODE></p>
<p class=book><CODE>52 * reporting it here would be misleading — the barrier wait</CODE></p>
<p class=book><CODE>53 * completed, after all, whereas returning, for example,</CODE></p>
<p class=book><CODE>54 * EINVAL would imply the wait had failed. The next attempt</CODE></p>
<p class=book><CODE>55 * to use the barrier *will* return an error, or hang, due</CODE></p>
<p class=book><CODE>56 * to whatever happened to the mutex.</CODE></p>
<p class=book><CODE>57 */</CODE></p>
<p class=book><CODE>58 pthread_mutex_unlock (&barrier-&gt;mutex);</CODE></p>
<p class=book><CODE>59 return status; /* error, -1 for waker, or 0 */</CODE></p>
<p class=book><CODE>60 }</CODE></p>
<p class=book>Finally, barrier_main.c is a simple program that uses barriers. Each thread</p>
<p class=book>loops on calculations within a private array. 35,47 At the beginning and end of each iteration, the threads, running function</p>
<p class=book>thread_routine, all wait on a barrier to synchronize the operation. 56-61 At the end of each iteration, the "lead thread" (the one receiving a -1 result</p>
<p class=book>from barrier_wait) will modify the data of all threads, preparing them for the next iteration. The others go directly to the top of the loop and wait on the barrier at line 35.</p>
<p class=book>■ barrier_main.c</p>
<p class=book><CODE>1 #include &lt;pthread.h&gt;</CODE></p>
<p class=book><CODE>2 #include "barrier.h"</CODE></p>
<p class=book><CODE>3 #include "errors.h"</CODE></p>
<p class=book><CODE>4</CODE></p>
<p class=book><CODE>5 #define THREADS 5</CODE></p>
<p class=book><CODE>6 #define ARRAY 6</CODE></p>
<p class=book><CODE>7 #define INLOOPS 1000</CODE></p>
<p class=book><CODE>8 #define OUTLOOPS 10</CODE> </p>
<p class=book><CODE>9</CODE></p>
<p class=book><CODE>10 /*</CODE></p>
<p class=book><CODE>11 * Keep track of each thread.</CODE></p>
<p class=book><CODE>12 */</CODE></p>
<p class=book><CODE>13 typedef struct thread_tag {</CODE></p>
<p class=book><CODE>14 	pthread_t thread_id;</CODE></p>
<p class=book><CODE>15 	int number;</CODE></p>
<p class=book><CODE>16 	int increment;</CODE></p>
<p class=book><CODE>17 	int array[ARRAY];</CODE></p>
<p class=book><CODE>18 } thread_t;</CODE> </p>
<p class=book><CODE>19</CODE></p>
<p class=book><CODE>20 barrier_t barrier;</CODE></p>
<p class=book><CODE>21 thread_t thread[THREADS];</CODE> </p>
<p class=book><CODE>22</CODE></p>
<p class=book><CODE>23 /*</CODE></p>
<p class=book><CODE>24 * Start routine for threads.</CODE></p>
<p class=book><CODE>25 */</CODE></p>
<p class=book><CODE>26 void *thread_routine (void *arg)</CODE></p>
<p class=book><CODE>27 {</CODE></p>
<p class=book><CODE>28 thread_t *self = (thread_t*)arg; /* Thread's thread_t */</CODE></p>
<p class=book><CODE>29 int in_loop, out_loop, count, status;</CODE></p>
<p class=book><CODE>30</CODE></p>
<p class=book><CODE>31 /*</CODE></p>
<p class=book><CODE>32 * Loop through OUTLOOPS barrier cycles.</CODE></p>
<p class=book><CODE>33 */</CODE></p>
<p class=book><CODE>34 for (out_loop = 0; out_loop &lt; OUTLOOPS; out_loop++) {</CODE></p>
<p class=book><CODE>35 status = barrier_wait (&barrier);</CODE></p>
<p class=book><CODE>36 if (status &gt; 0)</CODE></p>
<p class=book><CODE>37 err_abort (status, "Wait on barrier");</CODE></p>
<p class=book><CODE>38</CODE></p>
<p class=book><CODE>39 /*</CODE></p>
<p class=book><CODE>40 * This inner loop just adds a value to each element in</CODE></p>
<p class=book><CODE>41 * the working array.</CODE></p>
<p class=book><CODE>42 */</CODE></p>
<p class=book><CODE>43 for (in_loop = 0; in_loop &lt; INLOOPS; in_loop++)</CODE></p>
<p class=book><CODE>44 	for (count = 0; count &lt; ARRAY; count++)</CODE></p>
<p class=book><CODE>45 		self-&gt;array[count] += self-&gt;increment; 46</CODE></p>
<p class=book><CODE>47 status = barrier_wait (&barrier);</CODE></p>
<p class=book><CODE>48 if (status &gt; 0)</CODE></p>
<p class=book><CODE>49 	err_abort (status, "Wait on barrier");</CODE> </p>
<p class=book><CODE>50</CODE></p>
<p class=book><CODE>51 /*</CODE></p>
<p class=book><CODE>52 * The barrier causes one thread to return with the</CODE></p>
<p class=book><CODE>53 * special return status -1. The thread receiving this</CODE></p>
<p class=book><CODE>54 * value increments each element in the shared array.</CODE></p>
<p class=book><CODE>55 */</CODE></p>
<p class=book><CODE>56 if (status == -1) {</CODE></p>
<p class=book><CODE>57 	int thread_num;</CODE></p>
<p class=book><CODE>58</CODE></p>
<p class=book><CODE>59 	for (thread_num = 0; thread_num &lt; THREADS; thread_num++)</CODE></p>
<p class=book><CODE>60 		thread[thread_num].increment += 1;</CODE></p>
<p class=book><CODE>61 }</CODE></p>
<p class=book><CODE>62 }</CODE></p>
<p class=book><CODE>63 return NULL;</CODE></p>
<p class=book><CODE>64 }</CODE> </p>
<p class=book><CODE>65</CODE></p>
<p class=book><CODE>66 int main (int arg, char *argv[])</CODE></p>
<p class=book><CODE>67 {</CODE></p>
<p class=book><CODE>68 int thread_count, array_count;</CODE></p>
<p class=book><CODE>69 int status;</CODE></p>
<p class=book><CODE>70</CODE></p>
<p class=book><CODE>71 barrier_init (&barrier, THREADS);</CODE></p>
<p class=book><CODE>72</CODE></p>
<p class=book><CODE>73 /*</CODE></p>
<p class=book><CODE>74 * Create a set of threads that will use the barrier.</CODE></p>
<p class=book><CODE>75 */</CODE></p>
<p class=book><CODE>76 for (thread_count = 0; thread_count &lt; THREADS; thread_count++) { 7 7 thread[thread_count].increment = thread_count;</CODE></p>
<p class=book><CODE>78 thread[thread_count].number = thread_count;</CODE></p>
<p class=book><CODE>79</CODE></p>
<p class=book><CODE>80 for (array_count = 0; array_count &lt; ARRAY; array_count++)</CODE></p>
<p class=book><CODE>81 	thread[thread_count].array[array_count] = array_count + <b>1;</b></CODE> </p>
<p class=book><CODE>82</CODE></p>
<p class=book><CODE>83 status = pthread_create (&thread[thread_count].thread_id,</CODE></p>
<p class=book><CODE>84 NULL, thread_routine, (void*)&thread[thread_count]);</CODE></p>
<p class=book><CODE>85 if (status != 0)</CODE></p>
<p class=book><CODE>86 	err_abort (status, "Create thread");</CODE></p>
<p class=book><CODE>87 }</CODE> </p>
<p class=book><CODE>88</CODE></p>
<p class=book><CODE>89 /*</CODE></p>
<p class=book><CODE>90 * Now join with each of the threads.</CODE></p>
<p class=book><CODE>91 */</CODE></p>
<p class=book><CODE>92 for (thread_count = 0; thread_count &lt; THREADS; thread_count++) {</CODE></p>
<p class=book><CODE>93 status = pthread_join (thread[thread_count].thread_id, NULL);</CODE></p>
<p class=book><CODE>94 if (status != 0)</CODE></p>
<p class=book><CODE>95 	err_abort (status, "Join thread");</CODE> </p>
<p class=book><CODE>96</CODE></p>
<p class=book><CODE>97 printf ("%02d: (%d) ",</CODE></p>
<p class=book><CODE>98 thread_count, thread[thread_count].increment);</CODE></p>
<p class=book><CODE>99</CODE></p>
<p class=book><CODE>100 for (array_count = 0; array_count &lt; ARRAY; array_count++)</CODE></p>
<p class=book><CODE>101 printf ("%010u ",</CODE></p>
<p class=book><CODE>102 thread[thread_count].array[array_count]);</CODE></p>
<p class=book><CODE>103 printf ("\n");</CODE></p>
<p class=book><CODE>104 }</CODE> </p>
<p class=book><CODE>105</CODE></p>
<p class=book><CODE>106 /*</CODE></p>
<p class=book><CODE>107 * To be thorough, destroy the barrier.</CODE></p>
<p class=book><CODE>108 */</CODE></p>
<p class=book><CODE>109 barrier_destroy (&barrier);</CODE></p>
<p class=book><CODE>110 return 0;</CODE></p>
<p class=book><CODE>111 }</CODE></p>


<a name=t117></a><h3 class=book>
<b>7.1.2 Read/write locks</b>
</h3>
<p class=book>A read/write lock is a lot like a mutex. It is another way to prevent more than one thread from modifying shared data at the same time. But unlike a mutex it distinguishes between <i>reading</i> data and <i>writing</i> data. A mutex excludes all other threads, while a read/write lock allows more than one thread to <i>read</i> the data, as long as none of them needs to change it.</p>
<p class=book>Read/write locks are used to protect information that you need to read frequently but usually don't need to modify. For example, when you build a cache of recently accessed information, many threads may simultaneously examine the cache without conflict. When a thread needs to update the cache, it must have exclusive access.</p>
<p class=book>When a thread locks a read/write lock, it chooses <i>shared read access</i> or <i>exclusive write access. A</i> thread that wants read access can't continue while any thread currently has write access. A thread trying to gain write access can't continue when another thread currently has either write access or read access.</p>
<p class=book>When both readers and writers are waiting for access at the same time, the readers are given precedence when the write lock is released. <i>Read</i> precedence favors concurrency because it potentially allows many threads to accomplish work simultaneously. <i>Write</i> precedence on the other hand would ensure that pending modifications to the shared data are completed before the data is used. There's no absolute right or wrong policy, and if you don't find the implementation here appropriate for you, it is easy to change.</p>
<p class=book>Figure 7.3 shows the operation of a read/write lock being used to synchronize three threads, called thread 1. thread 2, and thread 3. The figure is a sort of timing diagram, with time increasing from left to right. Each of the lines beginning at the labels in the upper left designates the behavior of a specific thread — solid for thread 1, dotted for thread 2, and dashed for thread 3. When the lines drop within the rounded rectangle, they are interacting with the read/write lock. If the</p>
<img border=0 style='spacing 9px;' src="img_23.png">
<br>
<p class=book><b>FIGURE 7.3</b> <i>Read/write lock operation</i></p>
<br>
<p class=book>line drops below the center Line, it shows that the thread has the read/write lock locked, either for exclusive write or for shared read. Lines that hover above the center line represent threads waiting for the lock.</p>
<p class=book>In this example, thread 1 locks the read/write lock for exclusive write. Thread 2 tries to lock the read/write lock for shared read and, finding it already locked for exclusive write, blocks. When thread 1 releases the lock, it awakens thread 2, which then succeeds in locking the read/write lock for shared read. Thread 3 then tries to lock the read/write lock for shared read and, because the read/write lock is already locked for shared read, it succeeds immediately. Thread 1 then tries to lock the read/write lock again for exclusive write access, and blocks because the read/write lock is already locked for read access. When thread 3 unlocks the read/write lock, it cannot awaken thread 1, because there is another reader. Only when thread 2 also unlocks the read/write lock, and the lock becomes unlocked, can thread 1 be awakened to lock the read/write lock for exclusive write access.</p>
<p class=book>The header file rwlock.h and the C source file rwlock.c demonstrate an implementation of read/write locks using standard Pthreads mutexes and condition variables. This is a portable implementation that is relatively easy to understand. One could, of course, create a much more efficient implementation for any specific system based on knowledge of nonportable hardware and operating system characteristics.</p>
<p class=book>The rest of this section shows the details of a read/write lock package. First, rwlock.h describes the interfaces, and then rwlock.c provides the implementation. Part 1 shows the structure of a read/write lock, represented by the type <CODE>rwlock_t</CODE>.</p>
<p class=book><b>7-9</b> Of course, there's a mutex to serialize access to the structure. We'll use two separate condition variables, one to wait for read access (called read) and one to wait for write access (called, surprisingly, write), 10 The <CODE>rwlock_t</CODE> structure has a valid member to easily detect common usage errors, such as trying to lock a read/write lock that hasn't been initialized. The member is set to a magic number when the read/write lock is initialized, just as in <CODE>barrier_init</CODE>.</p>
<p class=book><b>11-12</b> To enable us to determine whether either condition variable has waiters, we'll keep a count of active readers (r_active) and a flag to indicate an active writer (w_active).</p>
<p class=book><b>13-14</b> We also keep a count of the number of threads waiting for read access (r_wait) and for write access (w_wait). </p>
<p class=book><b>17</b> Finally, we need a "magic number" for our valid member. (See the footnote in Section 7.1.1 if you missed this part of the barrier example.)</p>
<p class=book>■ rwlock.h part 1 rwlock_t</p>
<p class=book><CODE>1 #include &lt;pthread.h&gt;</CODE> </p>
<p class=book><CODE>2</CODE></p>
<p class=book><CODE>3 /*</CODE></p>
<p class=book><CODE>4 * Structure describing a read/write lock.</CODE></p>
<p class=book><CODE>5 */</CODE></p>
<p class=book><CODE>6 typedef struct rwlock_tag {</CODE></p>
<p class=book><CODE>7 	pthread_mutex_t mutex;</CODE></p>
<p class=book><CODE>8 	pthread_cond_t read;</CODE></p>
<p class=book><CODE>9 	pthread_cond_t write;</CODE></p>
<p class=book><CODE>10 	int valid;</CODE></p>
<p class=book><CODE>11 	int r_active;</CODE></p>
<p class=book><CODE>12 	int w_active;</CODE></p>
<p class=book><CODE>13 	int r_wait;</CODE></p>
<p class=book><CODE>14 	int w_wait;</CODE></p>
<p class=book><CODE>15 } rwlock_t;</CODE> </p>
<p class=book><CODE>16</CODE></p>
<p class=book><CODE>17 #define RWLOCK VALID 0xfacade</CODE></p>
<p class=book><CODE>/* wait for read */</CODE></p>
<p class=book><CODE>/* wait for write */</CODE></p>
<p class=book><CODE>/* set when valid */</CODE></p>
<p class=book><CODE>/* readers active */</CODE></p>
<p class=book><CODE>/* writer active */</CODE></p>
<p class=book><CODE>/* readers waiting */</CODE></p>
<p class=book><CODE>/* writers waiting */</CODE></p>
<p class=book>We could have saved some space and simplified the code by using a single condition variable, with readers and writers waiting using separate predicate expressions. We will use one condition variable for each predicate, because it is more efficient. This is a common trade-off. The main consideration is that when two predicates share a condition variable, you must always wake them using <CODE>pthread_cond_broadcast</CODE>, which would mean waking all waiters each time the read/write lock is unlocked.</p>
<p class=book>We keep track of a boolean variable for "writer active," since there can only be one. There are also counters for "readers active," "readers waiting," and "writers waiting." We could get by without counters for readers and writers waiting. All readers are awakened simultaneously using a broadcast, so it doesn't matter how many there are. Writers are awakened only if there are no readers, so we could dispense with keeping track of whether there are any threads waiting to write (at the cost of an occasional wasted condition variable signal when there are no waiters).</p>
<p class=book>We count the number of threads waiting for read access because the condition variable waits might be canceled. Without cancellation, we could use a simple flag — "threads are waiting for read" or "no threads are waiting for read." Each thread could set it before waiting, and we could clear it before broadcasting to wake all waiting readers. However, because we can't count the threads waiting on a condition variable, we wouldn't know whether to clear that flag when a waiting reader was canceled. This information is critical, because if there are no readers waiting when the read/write lock is unlocked, we must wake a writer — but we cannot wake a writer if there are waiting readers. A count of waiting readers, which we can decrease when a waiter is canceled, solves the problem.</p>
<p class=book>The consequences of "getting it wrong" are less important for writers than for readers. Because we check for readers first, we don't really need to know whether there are writers. We could signal a "potential writer" anytime the read/write lock was released with no waiting readers. But counting waiting writers allows us to avoid a condition variable signal when no threads are waiting.</p>
<p class=book>Part 2 shows the rest of the definitions and the function prototypes.</p>
<p class=book><b>4-6</b> The RWLOCK_INITIALlZER macro allows you to statically initialize a read/write lock.</p>
<p class=book><b>11</b>-<b>18</b> Of course, you must also be able to initialize a read/write lock that you cannot allocate statically, so we provide <CODE>rwl_init</CODE> to initialize dynamically, and rwl_ destroy to destroy a read/write lock once you're done with it. In addition, there are functions to lock and unlock the read/write lock for either read or write access. You can "try to lock" a read/write lock, either for read or write access, by calling <CODE>rwl_readtrylock</CODE> or rwl_writetrylock., just as you can try to lock a mutex by calling <CODE>pthread_mutex_trylock</CODE>.</p>
<p class=book>■ rwlock.h part 2 interfaces</p>
<p class=book><CODE>1 /*</CODE></p>
<p class=book><CODE>2 * Support static initialization of barriers.</CODE></p>
<p class=book><CODE>3 */</CODE></p>
<p class=book><CODE>4 #define RWL_INITIALIZER \</CODE></p>
<p class=book><CODE>5 {PTHREAD_MUTEX_INITIALIZER, PTHREAD_COND_INITIALIZER, \</CODE></p>
<p class=book><CODE>6 PTHREAD_COND_INITIALIZER, RWLOCK_VALID, 0, 0, 0, 0}</CODE></p>
<p class=book><CODE>7</CODE></p>
<p class=book><CODE>8 /*</CODE></p>
<p class=book><CODE>9 * Define read/write lock functions.</CODE></p>
<p class=book><CODE>10 */</CODE></p>
<p class=book><CODE>11 extern int rwl_init (rwlock_t *rwlock);</CODE></p>
<p class=book><CODE>12 extern int rwl_destroy (rwlock_t *rwlock);</CODE></p>
<p class=book><CODE>13 extern int rwl_readlock (rwlock_t *rwlock);</CODE></p>
<p class=book><CODE>14 extern int rwl_readtrylock (rwlock_t *rwlock);</CODE></p>
<p class=book><CODE>15 extern int rwl_readunlock (rwlock_t *rwlock);</CODE></p>
<p class=book><CODE>16 extern int rwl_writelock (rwlock_t *rwlock);</CODE></p>
<p class=book><CODE>17 extern int rwl_writetrylock (rwlock_t *rwlock);</CODE></p>
<p class=book><CODE>18 extern int rwl_writeunlock (rwlock_t *rwlock);</CODE></p>
<p class=book>The file rwlock.c contains the implementation of read/write locks. The following examples break down each of the functions used to implement the rwlock.h interfaces.</p>
<p class=book>Part 1 shows <CODE>rwl_init</CODE>, which initializes a read/write lock. It initializes the Pthreads synchronization objects, initializes the counters and flags, and finally sets the valid sentinel to make the read/write lock recognizable to the other interfaces. If we are unable to initialize the read condition variable, we destroy the mutex that we'd already created. Similarly, if we are unable to initialize the write condition variable, we destroy both the mutex and the read condition variable.</p>
<p class=book>■ rwlock.c part 1 rwl_init</p>
<p class=book><CODE>1 #include &lt;pthread.h&gt;</CODE></p>
<p class=book><CODE>2 #include "errors.h"</CODE></p>
<p class=book><CODE>3 #include "rwlock.h"</CODE> </p>
<p class=book><CODE>4</CODE></p>
<p class=book><CODE>5 /*</CODE></p>
<p class=book><CODE>6 * Initialize a read/write lock.</CODE></p>
<p class=book><CODE>7 */</CODE></p>
<p class=book><CODE>8 int rwl_init (rwlock_t *rwl)</CODE></p>
<p class=book><CODE>9 {</CODE></p>
<p class=book><CODE>10 int status;</CODE> </p>
<p class=book><CODE>11</CODE></p>
<p class=book><CODE>12 rwl-&gt;r_active = 0;</CODE></p>
<p class=book><CODE>13 rwl-&gt;r_wait = rwl-&gt;w_wait = 0;</CODE></p>
<p class=book><CODE>14 rwl-&gt;w_active = 0;</CODE></p>
<p class=book><CODE>15 status = pthread_mutex_init (&rwl-&gt;mutex, NULL);</CODE></p>
<p class=book><CODE>16 if (status != 0)</CODE></p>
<p class=book><CODE>17 	return status;</CODE></p>
<p class=book><CODE>18 status = pthread_cond_init (&rwl-&gt;read, NULL);</CODE></p>
<p class=book><CODE>19 if (status != 0) {</CODE></p>
<p class=book><CODE>20 /* if unable to create read CV, destroy mutex */</CODE></p>
<p class=book><CODE>21 	pthread_mutex_destroy (&rwl-&gt;mutex);</CODE></p>
<p class=book><CODE>22 	return status;</CODE></p>
<p class=book><CODE>23 }</CODE></p>
<p class=book><CODE>24 status = pthread_cond_init (&rwl-&gt;write, NULL);</CODE></p>
<p class=book><CODE>25 if (status != 0) {</CODE></p>
<p class=book><CODE>26 /* if unable to create write CV, destroy read CV and mutex */</CODE></p>
<p class=book><CODE>27 	pthread_cond_destroy (&rwl-&gt;read);</CODE></p>
<p class=book><CODE>28 	pthread_mutex_destroy (&rwl-&gt;mutex);</CODE></p>
<p class=book><CODE>29 	return status;</CODE></p>
<p class=book><CODE>30 }</CODE></p>
<p class=book><CODE>31 rwl-&gt;valid = RWLOCK_VALID;</CODE></p>
<p class=book><CODE>32 return 0;</CODE></p>
<p class=book><CODE>33 }</CODE></p>
<p class=book>Part 2 shows the rwl_destroy function, which destroys a read/write lock. </p>
<p class=book><b>8-9</b> We first try to verify that the read/write lock was properly initialized by checking the valid member. This is not a complete protection against incorrect usage, but it is cheap, and it will catch some of the most common errors. See the annotation for barrier.c, part 2, for more about how the valid member is used.</p>
<p class=book><b>10-30</b> Check whether the read/write lock is in use. We look for threads that are using or waiting for either read or write access. Using two separate if statements makes the test slightly more readable, though there's no other benefit.</p>
<p class=book><b>36-39</b> As in barrier_destroy, we destroy all Pthreads synchronization objects, and store each status return. If any of the destruction calls fails, returning a nonzero value, rwl_destroy will return that status, and if they all succeed it will return 0 for success.</p>
<p class=book>■ rwlock.c part 2 rwl_destroy</p>
<p class=book><CODE>1 /*</CODE></p>
<p class=book><CODE>2 * Destroy a read/write lock.</CODE></p>
<p class=book><CODE>3 */</CODE></p>
<p class=book><CODE>4 int rwl_destroy (rwlock_t *rwl)</CODE></p>
<p class=book><CODE>5 {</CODE></p>
<p class=book><CODE>6 int status, status1, status2;</CODE></p>
<p class=book><CODE>7</CODE></p>
<p class=book><CODE>8 if (rwl-&gt;valid != RWLOCK_VALID)</CODE></p>
<p class=book><CODE>9 return EINVAL;</CODE></p>
<p class=book><CODE>10 status = pthread_mutex_lock (&rwl-&gt;mutex);</CODE></p>
<p class=book><CODE>11 if (status != 0)</CODE></p>
<p class=book><CODE>12 return status; 13</CODE></p>
<p class=book><CODE>14 /*</CODE></p>
<p class=book><CODE>15 * Check whether any threads own the lock; report "BUSY" if</CODE></p>
<p class=book><CODE>16 * so.</CODE></p>
<p class=book><CODE>17 */</CODE></p>
<p class=book><CODE>18 if (rwl-&gt;r_active &gt; 0 || rwl-&gt;w_active) {</CODE></p>
<p class=book><CODE>19 pthread_mutex_unlock (&rwl-&gt;mutex);</CODE></p>
<p class=book><CODE>20 return EBUSY;</CODE></p>
<p class=book><CODE>21 } 22</CODE></p>
<p class=book><CODE>23 /*</CODE></p>
<p class=book><CODE>24 * Check whether any threads are known to be waiting; report</CODE></p>
<p class=book><CODE>25 * EBUSY if so.</CODE></p>
<p class=book><CODE>26 */</CODE></p>
<p class=book><CODE>27 if (rwl-&gt;r_wait != 0 || rwl-&gt;w_wait != 0) {</CODE></p>
<p class=book><CODE>28 pthread_mutex_unlock (&rwl-&gt;mutex);</CODE></p>
<p class=book><CODE>29 return EBUSY;</CODE></p>
<p class=book><CODE>30 } 31</CODE></p>
<p class=book><CODE>32 rwl-&gt;valid = 0;</CODE></p>
<p class=book><CODE>33 status = pthread_mutex_unlock (&rwl-&gt;mutex);</CODE></p>
<p class=book><CODE>34 if (status != 0)</CODE></p>
<p class=book><CODE>35 return status;</CODE></p>
<p class=book><CODE>36 status = pthread_mutex_destroy (&rwl-&gt;mutex);</CODE></p>
<p class=book><CODE>37 status1 = pthread_cond_destroy (&rwl-&gt;read);</CODE></p>
<p class=book><CODE>38 status2 = pthread_cond_destroy (&rwl-&gt;write);</CODE></p>
<p class=book><CODE>39 return (status == 0 ? status</CODE></p>
<p class=book><CODE>40 : (status1 == 0 ? status1 : status2));</CODE></p>
<p class=book><CODE>41 }</CODE></p>
<p class=book>Part 3 shows the code for rwl_readcleanup and rwl_writecleanup, two cancellation cleanup handlers used in locking the read/write lock for read and write access, respectively. As you may infer from this, read/write locks, unlike barriers, are cancellation points. When a wait is canceled, the waiter needs to decrease the count of threads waiting for either a read or write lock, as appropriate, and unlock the mutex.</p>
<p class=book>■ rwlock.c part 3 cleanuphandlers</p>
<p class=book><CODE>1 /*</CODE></p>
<p class=book><CODE>2 * Handle cleanup when the read lock condition variable</CODE></p>
<p class=book><CODE>3 * wait is canceled.</CODE></p>
<p class=book><CODE>4 *</CODE></p>
<p class=book><CODE>5 * Simply record that the thread is no longer waiting,</CODE></p>
<p class=book><CODE>6 * and unlock the mutex.</CODE></p>
<p class=book><CODE>7 */</CODE></p>
<p class=book><CODE>8 static void rwl_readcleanup (void *arg)</CODE></p>
<p class=book><CODE>9 {</CODE></p>
<p class=book><CODE>10 rwlock_t *rwl = (rwlock_t *)arg;</CODE></p>
<p class=book><CODE>11</CODE></p>
<p class=book><CODE>12 rwl-&gt;r_wait--;</CODE></p>
<p class=book><CODE>13 pthread_mutex_unlock (&rwl-&gt;mutex);</CODE></p>
<p class=book><CODE>14 }</CODE></p>
<p class=book><CODE>15</CODE></p>
<p class=book><CODE>16 /*</CODE></p>
<p class=book><CODE>17 * Handle cleanup when the write lock condition variable</CODE></p>
<p class=book><CODE>18 * wait is canceled.</CODE></p>
<p class=book><CODE>19 *</CODE></p>
<p class=book><CODE>20 * Simply record that the thread is no longer waiting,</CODE></p>
<p class=book><CODE>21 * and unlock the mutex.</CODE></p>
<p class=book><CODE>22 */</CODE></p>
<p class=book><CODE>23 static void rwl_writecleanup (void *arg)</CODE></p>
<p class=book><CODE>24 {</CODE></p>
<p class=book><CODE>25 rwlock_t *rwl = (rwlock_t *)arg;</CODE> </p>
<p class=book><CODE>26</CODE></p>
<p class=book><CODE>27 rwl-&gt;w_wait--;</CODE></p>
<p class=book><CODE>28 pthread_mutex_unlock (&rwl-&gt;mutex);</CODE></p>
<p class=book><CODE>29 }</CODE></p>
<p class=book><b>10-26</b> Part 4 shows rwl_readlock, which locks a read/write lock for read access. If a writer is currently active (w_active is nonzero), we wait for it to broadcast the read condition variable. The r_wait member counts the number of threads waiting to read. This could be a simple boolean variable, except for one problem— when a waiter is canceled, we need to know whether there are any remaining waiters. Maintaining a count makes this easy, since the cleanup handler only needs to decrease the count.</p>
<p class=book>This is one of the places where the code must be changed to convert our read/ write lock from "reader preference" to "writer preference," should you choose to do that. To implement writer preference, a reader must block while there are waiting writers (w_wait &gt; 0), not merely while there are active writers, as we do here.</p>
<p class=book><b>15-21</b> Notice the use of the cleanup handler around the condition wait. Also, notice that we pass the argument 0 to pthread_cleanup_pop so that the cleanup code is called only if the wait is canceled. We need to perform slightly different actions when the wait is not canceled. If the wait is not canceled, we need to increase the count of active readers before unlocking the mutex.</p>
<p class=book>■ rwlock.c part 4 rwl_readlock</p>
<p class=book><CODE><b>1</b> <b>/*</b></CODE></p>
<p class=book><CODE><b>2</b> * Lock a read/write lock for read access.</CODE></p>
<p class=book><CODE>3 */</CODE></p>
<p class=book><CODE>4 int rwl_readlock (rwlock_t *rwl)</CODE></p>
<p class=book><CODE>5 {</CODE></p>
<p class=book><CODE>6 int status;</CODE> </p>
<p class=book><CODE>7</CODE></p>
<p class=book><CODE>8 if (rwl-&gt;valid != RWLOCK_VALID)</CODE></p>
<p class=book><CODE>9 	return EINVAL;</CODE></p>
<p class=book><CODE>10 status = pthread_mutex_lock (&rwl-&gt;mutex);</CODE></p>
<p class=book><CODE>11 if (status != 0)</CODE></p>
<p class=book><CODE>12 	return status;</CODE></p>
<p class=book><CODE>13 if (rwl-&gt;w_active) {</CODE></p>
<p class=book><CODE>14 	rwl-&gt;r_wait++;</CODE></p>
<p class=book><CODE>15 	pthread_cleanup_push (rwl_readcleanup, (void*)rwl);</CODE></p>
<p class=book><CODE>16 	while (rwl-&gt;w_active) {</CODE></p>
<p class=book><CODE>17 		status = pthread_cond_wait (&rwl-&gt;read, &rwl-&gt;mutex);</CODE></p>
<p class=book><CODE>18 		if (status != 0)</CODE></p>
<p class=book><CODE>19 			break;</CODE></p>
<p class=book><CODE>20 	}</CODE></p>
<p class=book><CODE>21 pthread_cleanup_pop (0);</CODE></p>
<p class=book><CODE>22 rwl-&gt;r_wait--;</CODE></p>
<p class=book><CODE>23 }</CODE></p>
<p class=book><CODE>24 if (status == 0)</CODE></p>
<p class=book><CODE>25 rwl-&gt;r_active++;</CODE></p>
<p class=book><CODE>26 pthread_mutex_unlock (&rwl-&gt;mutex);</CODE></p>
<p class=book><CODE>27 return status;</CODE></p>
<p class=book><CODE>28 }</CODE></p>
<p class=book>Part 5 shows rwl_readtrylock. This function is nearly identical to rwl_readlock, except that, instead of waiting for access if a writer is active, it returns EBUSY. It doesn't need a cleanup handler, and has no need to increase the count of waiting readers.</p>
<p class=book>This function must also be modified to implement "writer preference" read/ write locks, by returning EBUSY when a writer is waiting, not just when a writer is active.</p>
<p class=book>■ <b>rwlock.c</b> <b>part 5 rwl_readtrylock</b></p>
<p class=book><CODE>1 /*</CODE></p>
<p class=book><CODE>2 * Attempt to lock a read/write lock for read access (don't</CODE></p>
<p class=book><CODE>3 * block if unavailable).</CODE></p>
<p class=book><CODE>4 */</CODE></p>
<p class=book><CODE>5 int rwl_readtrylock (rwlock_t *rwl)</CODE></p>
<p class=book><CODE>6 {</CODE></p>
<p class=book><CODE>7 int status, status2;</CODE> </p>
<p class=book><CODE>8</CODE></p>
<p class=book><CODE>9 if (rwl-&gt;valid != RWLOCK_VALID)</CODE></p>
<p class=book><CODE>10 	return EINVAL;</CODE></p>
<p class=book><CODE>11 status = pthread_mutex_lock (&rwl-&gt;mutex);</CODE></p>
<p class=book><CODE>12 if (status != 0)</CODE></p>
<p class=book><CODE>13 	return status;</CODE></p>
<p class=book><CODE>14 if (rwl-&gt;w_active)</CODE></p>
<p class=book><CODE>15 	status = EBUSY;</CODE></p>
<p class=book><CODE>16 else</CODE></p>
<p class=book><CODE>17 	rwl-&gt;r_active++;</CODE></p>
<p class=book><CODE>18 status2 = pthread_mutex_unlock (&rwl-&gt;mutex);</CODE></p>
<p class=book><CODE>19 return (status2 != 0 ? status2 : status);</CODE></p>
<p class=book><CODE>20 }</CODE></p>
<p class=book>13 Part 6 shows <CODE>rwl_readunlock</CODE>. This function essentially reverses the effect of <CODE>rwl_readlock</CODE> or <CODE>rwl_tryreadlock</CODE>, by decreasing the count of active readers (r_active).</p>
<p class=book><b>14-15</b> If there are no more active readers, and at least one thread is waiting for write access, signal the write condition variable to unblock one. Note that there is a race here, and whether you should be concerned about it depends on your notion of what should happen. If another thread that is interested in read access calls <CODE>rwl_readlock</CODE> or <CODE>rwl_tryreadlock</CODE> before the awakened writer can run, the reader may "win," despite the fact that we just selected a writer.</p>
<p class=book>Because our version of read/write locks has "reader preference," this is what we usually want to happen — the writer will determine that it has failed and will resume waiting. (It received a spurious wakeup.) If the implementation changes to prefer writers, the spurious wakeup will not occur, because the potential reader would have to block. The waiter we just unblocked cannot decrease w_wait until it actually claims the lock.</p>
<p class=book>■ rwlock.c part 6 rwl_readunlock</p>
<p class=book><CODE>1 /*</CODE></p>
<p class=book><CODE>2 * Unlock a read/write lock from read access.</CODE></p>
<p class=book><CODE>3 */</CODE></p>
<p class=book><CODE>4 int rwl_readunlock (rwlock_t *rwl)</CODE></p>
<p class=book><CODE>5 {</CODE></p>
<p class=book><CODE>6 int status, status2;</CODE></p>
<p class=book><CODE>7</CODE></p>
<p class=book><CODE>8 if (rwl-&gt;valid != RWLOCK_VALID)</CODE></p>
<p class=book><CODE>9 	return EINVAL;</CODE></p>
<p class=book><CODE>10 status = pthread_mutex_lock (&rwl-&gt;mutex);</CODE></p>
<p class=book><CODE>11 if (status != 0)</CODE></p>
<p class=book><CODE>12 	return status;</CODE></p>
<p class=book><CODE>13 rwl-&gt;r_active--;</CODE></p>
<p class=book><CODE>14 if (rwl-&gt;r_active == 0 && rwl-&gt;w_wait &gt; 0)</CODE></p>
<p class=book><CODE>15 	status = pthread_cond_signal (&rwl-&gt;write);</CODE></p>
<p class=book><CODE>16 status2 = pthread_mutex_unlock (&rwl-&gt;mutex);</CODE></p>
<p class=book><CODE>17 return (status2 == 0 ? status : status2);</CODE></p>
<p class=book><CODE>18 }</CODE></p>
<p class=book><b>13</b> Part 7 shows <CODE>rwl_writelock</CODE>. This function is much like <CODE>rwl_readlock</CODE>, except for the predicate condition on the condition variable wait. In part 1, I explained that, to convert from "preferred read" to "preferred write," a potential reader would have to wait until there were no active or waiting writers, whereas currently it waits only for active writers. The predicate in rwl_writelock is the converse of that condition. Because we support "preferred read," in theory, we must wait here if there are any active or waiting readers. In fact, it is a bit simpler, because if there are any active readers, there cannot be any waiting readers—the whole point of a read/write lock is that multiple threads can have read access at the same time. On the other hand, we do have to wait if there are any active writers, because we allow only one writer at a time.</p>
<p class=book>25 Unlike r_active, which is a counter, w_active is treated as a boolean. Or is it a counter? There's really no semantic difference, since the value of 1 can be considered a boolean TRUE or a count of 1 — there can be only one active writer at any time.</p>
<p class=book>■ rwlock.c_part 7 rwl_writelock</p>
<p class=book><CODE>1 /*</CODE></p>
<p class=book><CODE>2 * Lock a read/write lock for write access.</CODE></p>
<p class=book><CODE>3 */</CODE></p>
<p class=book><CODE>4 int rwl_writelock (rwlock_t *rwl)</CODE></p>
<p class=book><CODE>5 {</CODE></p>
<p class=book><CODE>6 	int status;</CODE> </p>
<p class=book><CODE>7</CODE></p>
<p class=book><CODE>8 	if (rwl-&gt;valid != RWLOCK_VALID)</CODE></p>
<p class=book><CODE>9 		return EINVAL;</CODE></p>
<p class=book><CODE>10 	status = pthread_mutex_lock (&rwl-&gt;mutex);</CODE></p>
<p class=book><CODE>11 	if (status != 0)</CODE></p>
<p class=book><CODE>12 		return status;</CODE></p>
<p class=book><CODE>13 	if (rwl-&gt;w_active || rwl-&gt;r_active &gt; 0) {</CODE></p>
<p class=book><CODE>14 		rwl-&gt;w_wait++;</CODE></p>
<p class=book><CODE>15 		pthread_cleanup_push (rwl_writecleanup, (void*)rwl);</CODE></p>
<p class=book><CODE>16 		while (rwl-&gt;w_active || rwl-&gt;r_active &gt; 0) {</CODE></p>
<p class=book><CODE>17 			status = pthread_cond_wait (&rwl-&gt;write, &rwl-&gt;mutex);</CODE></p>
<p class=book><CODE>18 			if (status != 0)</CODE></p>
<p class=book><CODE>19 				break;</CODE></p>
<p class=book><CODE>20 		}</CODE></p>
<p class=book><CODE>21 		pthread_cleanup_pop (0);</CODE></p>
<p class=book><CODE>22 		rwl-&gt;w_wait--;</CODE></p>
<p class=book><CODE>23 	}</CODE></p>
<p class=book><CODE>24 	if (status == 0)</CODE></p>
<p class=book><CODE>25 		rwl-&gt;w_active = 1;</CODE></p>
<p class=book><CODE>26 	pthread_mutex_unlock (&rwl-&gt;mutex);</CODE></p>
<p class=book><CODE>27 	return status;</CODE></p>
<p class=book><CODE>28 }</CODE></p>
<p class=book>Part 8 shows rwl_writetrylock. This function is much like rwl_writelock, except that it returns EBUSY if the read/write lock is currently in use (either by a reader or by a writer) rather than waiting for it to become free.</p>
<p class=book>■ rwlock.c part 8 rwl_writetrylock</p>
<p class=book>1<CODE> /*</CODE></p>
<p class=book><CODE>2 * Attempt to lock a read/write lock for write access. Don't</CODE></p>
<p class=book><CODE>3 * block if unavailable.</CODE></p>
<p class=book><CODE>4 */</CODE></p>
<p class=book><CODE>5 int rwl_writetrylock (rwlock_t *rwl)</CODE></p>
<p class=book><CODE>6 {</CODE></p>
<p class=book><CODE>7 int status, status2;</CODE> </p>
<p class=book><CODE>8</CODE></p>
<p class=book><CODE>9 if (rwl-&gt;valid != RWLOCK_VALID)</CODE></p>
<p class=book><CODE>10 	return EINVAL;</CODE></p>
<p class=book><CODE>11 status = pthread_mutex_lock (&rwl-&gt;mutex);</CODE></p>
<p class=book><CODE>12 if (status != 0)</CODE></p>
<p class=book><CODE>13 	return status;</CODE></p>
<p class=book><CODE>14 if (rwl-&gt;w_active || rwl-&gt;r_active &gt; 0)</CODE></p>
<p class=book><CODE>15 	status = EBUSY;</CODE></p>
<p class=book><CODE>16 else</CODE></p>
<p class=book><CODE>17 	rwl-&gt;w_active = 1;</CODE></p>
<p class=book><CODE>18 status2 = pthread_mutex_unlock (&rwl-&gt;mutex);</CODE></p>
<p class=book><CODE>19 return (status != 0 ? status : status2);</CODE></p>
<p class=book><CODE>20 }</CODE></p>
<p class=book>Finally, part 9 shows <CODE>rwl_writeunlock</CODE>. This function is called by a thread with a write lock, to release the lock.</p>
<p class=book><b>13-19</b> When a writer releases the read/write lock, it is always free; if there are any threads waiting for access, we must wake one. Because we implement "preferred read" access, we first look for threads that are waiting for read access. If there are any, we broadcast the read condition variable to wake them all.</p>
<p class=book><b>20-26</b> If there were no waiting readers, but there are one or more waiting writers, wake one of them by signaling the write condition variable.</p>
<p class=book>To implement a "preferred write" lock, you would reverse the two tests, waking a waiting writer, if any, before looking for waiting readers.</p>
<p class=book>■ rwlock.c part 9 rwl_writeunlock</p>
<p class=book><CODE>1 /*</CODE></p>
<p class=book><CODE>2 * Unlock a read/write lock from write access.</CODE></p>
<p class=book><CODE>3 */</CODE></p>
<p class=book><CODE>4 int rwl_writeunlock (rwlock_t *rwl)</CODE></p>
<p class=book><CODE>5 {</CODE></p>
<p class=book><CODE>6 int status;</CODE></p>
<p class=book><CODE>7</CODE></p>
<p class=book><CODE>8 if (rwl-&gt;valid != RWLOCK_VALID)</CODE></p>
<p class=book><CODE>9 	return EINVAL;</CODE></p>
<p class=book><CODE>10 status = pthread_mutex_lock (&rwl-&gt;mutex);</CODE></p>
<p class=book><CODE>11 if (status != 0)</CODE></p>
<p class=book><CODE>12 	return status;</CODE></p>
<p class=book><CODE>13 rwl-&gt;w_active = 0;</CODE></p>
<p class=book><CODE>14 if (rwl-&gt;r_wait &gt; 0) {</CODE></p>
<p class=book><CODE>15 	status = pthread_cond_broadcast(&rwl-&gt;read);</CODE></p>
<p class=book><CODE>16 	if (status != 0) {</CODE></p>
<p class=book><CODE>17 		pthread_mutex_unlock (&rwl-&gt;mutex);</CODE></p>
<p class=book><CODE>18 	return status;</CODE></p>
<p class=book><CODE>19 }</CODE></p>
<p class=book><CODE>20 } else if (rwl-&gt;w_wait &gt; 0) {</CODE></p>
<p class=book><CODE>21 	status = pthread_cond_signal (&rwl-&gt;write);</CODE></p>
<p class=book><CODE>22 	if (status != 0) {</CODE></p>
<p class=book><CODE>23 		pthread_mutex_unlock (&rwl-&gt;mutex);</CODE></p>
<p class=book><CODE>24 		return status;</CODE></p>
<p class=book><CODE>25 	}</CODE></p>
<p class=book><CODE>26 }</CODE></p>
<p class=book><CODE>27 status = pthread_mutex_unlock (&rwl-&gt;mutex);</CODE></p>
<p class=book><CODE>28 return status;</CODE></p>
<p class=book><CODE>29 }</CODE></p>
<p class=book>■ <b>rwlock.c</b> <b>part 9 writelock</b></p>
<p class=book>Now that we have all the pieces, rwlock_main.c shows a program that uses read/write locks.</p>
<p class=book><b>11-17</b> Each thread is described by a structure of type thread_t. The thread_num member is the thread's index within the array of thread_t structures. The thread_id member is the pthread_t (thread identifier) returned by pthread_ create when the thread was created. The updates and reads members are counts of the number of read lock and write lock operations performed by the thread. The interval member is generated randomly as each thread is created, to determine how many iterations the thread will read before it performs a write.</p>
<p class=book><b>22-26</b> The threads cycle through an array of data_t elements. Each element has a read/write lock, a data element, and a count of how many times some thread has updated the element.</p>
<p class=book><b>48-58</b> The program creates a set of threads running the thread_routine function. Each thread loops <b>ITERATIONS</b> times, practicing use of the read/write lock. It cycles through the array of data elements in sequence, resetting the index (element) to 0 when it reaches the end. At intervals specified by each thread's interval member, the thread will modify the current data element instead of reading it. The thread locks the read/write lock for write access, stores its <CODE>thread_num</CODE> as the new data value, and increases the updates counter.</p>
<p class=book><b>59-73</b> On all other iterations, thread_routine reads the current data element, locking the read/write lock for read access. It compares the data value against its <CODE>thread_num</CODE> to determine whether it was the most recent thread to update that data element, and, if so, it increments a counter. </p>
<p class=book><b>95-103</b> On Solaris systems, increase the thread concurrency level to generate more interesting activity. Without timeslicing of user threads, each thread would tend to execute sequentially otherwise.</p>
<p class=book>■ <b>rwlock_main.c</b></p>
<p class=book><CODE>1 #include "rwlock.h"</CODE></p>
<p class=book><CODE>2 #include "errors.h"</CODE> </p>
<p class=book><CODE>3</CODE></p>
<p class=book><CODE>4 #define THREADS 5</CODE></p>
<p class=book><CODE>5 #define DATASIZE 15</CODE></p>
<p class=book><CODE>6 #define ITERATIONS 10000</CODE></p>
<p class=book><CODE>7</CODE></p>
<p class=book><CODE>8 /*</CODE></p>
<p class=book><CODE>9 * Keep statistics for each thread.</CODE></p>
<p class=book><CODE>10 */</CODE></p>
<p class=book><CODE>11 typedef struct thread_tag {</CODE></p>
<p class=book><CODE>12 	int thread_num;</CODE></p>
<p class=book><CODE>13 	pthread_t thread_id;</CODE></p>
<p class=book><CODE>14 	int updates;</CODE></p>
<p class=book><CODE>15 	int reads;</CODE></p>
<p class=book><CODE>16 	int interval;</CODE></p>
<p class=book><CODE>17 } thread_t;</CODE> </p>
<p class=book><CODE>18</CODE></p>
<p class=book><CODE>19 /*</CODE></p>
<p class=book><CODE>20 * Read/write lock and shared data.</CODE></p>
<p class=book><CODE>21 */</CODE></p>
<p class=book><CODE>22 typedef struct data_tag {</CODE></p>
<p class=book><CODE>23 	rwlock_t lock;</CODE></p>
<p class=book><CODE>24 	int data;</CODE></p>
<p class=book><CODE>25 	int updates;</CODE></p>
<p class=book><CODE>26 } data_t;</CODE> </p>
<p class=book><CODE>27</CODE></p>
<p class=book><CODE>28 thread_t threads[THREADS];</CODE></p>
<p class=book><CODE>29 data_t data[DATASIZE];</CODE> </p>
<p class=book><CODE>30</CODE></p>
<p class=book><CODE>31 /*</CODE></p>
<p class=book><CODE>32 * Thread start routine that uses read/write locks.</CODE></p>
<p class=book><CODE>33 */</CODE></p>
<p class=book><CODE>34 void *thread_routine (void *arg)</CODE></p>
<p class=book><CODE>35 {</CODE></p>
<p class=book><CODE>36 thread_t *self = (thread_t*)arg;</CODE></p>
<p class=book><CODE>37 int repeats = 0;</CODE></p>
<p class=book><CODE>38 int iteration;</CODE></p>
<p class=book><CODE>39 int element = 0;</CODE></p>
<p class=book><CODE>40 int status;</CODE> </p>
<p class=book><CODE>41</CODE></p>
<p class=book><CODE>42 for (iteration = 0; iteration &lt; ITERATIONS; iteration++) {</CODE></p>
<p class=book><CODE>43 /*</CODE></p>
<p class=book><CODE>44 * Each "self-&gt;interval" iterations, perform an</CODE></p>
<p class=book><CODE>45 * update operation (write lock instead of read</CODE></p>
<p class=book><CODE>46 * lock).</CODE></p>
<p class=book><CODE>47 */</CODE></p>
<p class=book><CODE>48 	if ((iteration % self-&gt;interval) == 0) {</CODE></p>
<p class=book><CODE>49 		status = rwl_writelock (&data[element].lock);</CODE></p>
<p class=book><CODE>50 		if (status != 0)</CODE></p>
<p class=book><CODE>51 			err_abort (status, "Write lock");</CODE></p>
<p class=book><CODE>52 		data[element].data = self-&gt;thread_num;</CODE></p>
<p class=book><CODE>53 		data[element].updates++;</CODE></p>
<p class=book><CODE>54 		self-&gt;updates++;</CODE></p>
<p class=book><CODE>55 		status = rwl_writeunlock(&data[element].lock);</CODE></p>
<p class=book><CODE>56 		if (status != 0)</CODE></p>
<p class=book><CODE>57 			err_abort (status, "Write unlock");</CODE></p>
<p class=book><CODE>58 	} else {</CODE></p>
<p class=book><CODE>59 /*</CODE></p>
<p class=book><CODE>60 * Look at the current data element to see whether</CODE></p>
<p class=book><CODE>61 * the current thread last updated it. Count the</CODE></p>
<p class=book><CODE>62 * times, to report later.</CODE></p>
<p class=book><CODE>63 */</CODE></p>
<p class=book><CODE>64 		status = rwl_readlock (&data[element].lock);</CODE></p>
<p class=book><CODE>65 		if (status != 0)</CODE></p>
<p class=book><CODE>66 			err_abort (status, "Read lock");</CODE></p>
<p class=book><CODE>67 		self-&gt;reads++;</CODE></p>
<p class=book><CODE>68 		if (data[element].data == self-&gt;thread_num)</CODE></p>
<p class=book><CODE>69 			repeats++;</CODE></p>
<p class=book><CODE>70 		status = rwl_readunlock (&data[element].lock);</CODE></p>
<p class=book><CODE>71 		if (status != 0)</CODE></p>
<p class=book><CODE>72 		err_abort (status, "Read unlock");</CODE></p>
<p class=book><CODE>73 	}	</CODE></p>
<p class=book><CODE>74 	element++;</CODE></p>
<p class=book><CODE>75 	if (element &gt;= DATASIZE)</CODE></p>
<p class=book><CODE>76 		element = 0;</CODE></p>
<p class=book><CODE>77 }</CODE> </p>
<p class=book><CODE>78</CODE></p>
<p class=book><CODE>79 if (repeats &gt; 0)</CODE></p>
<p class=book><CODE>80 	printf (</CODE></p>
<p class=book><CODE>81 		"Thread %d found unchanged elements %d times\n",</CODE></p>
<p class=book><CODE>82 		self-&gt;thread_num, repeats);</CODE></p>
<p class=book><CODE>83 	return NULL;</CODE></p>
<p class=book><CODE>84 }</CODE> </p>
<p class=book><CODE>85</CODE></p>
<p class=book><CODE>86 int main (int argc, char *argv[])</CODE></p>
<p class=book><CODE>87 {</CODE></p>
<p class=book><CODE>88 int count;</CODE></p>
<p class=book><CODE>89 int data_count;</CODE></p>
<p class=book><CODE>90 int status;</CODE></p>
<p class=book><CODE>91 unsigned int seed = 1;</CODE></p>
<p class=book><CODE>92 int thread_updates = 0;</CODE></p>
<p class=book><CODE>93 int data_updates = 0;</CODE> </p>
<p class=book><CODE>94</CODE></p>
<p class=book><CODE>95 #ifdef sun</CODE></p>
<p class=book><CODE>96 /*</CODE></p>
<p class=book><CODE>97 * On Solaris 2.5, threads are not timesliced. To ensure</CODE></p>
<p class=book><CODE>98 * that our threads can run concurrently, we need to</CODE></p>
<p class=book><CODE>99 * increase the concurrency level to THREADS.</CODE></p>
<p class=book><CODE>100 */</CODE></p>
<p class=book><CODE>101 DPRINTF (("Setting concurrency level to %d\n", THREADS));</CODE></p>
<p class=book><CODE>102 thr_setconcurrency (THREADS);</CODE></p>
<p class=book><CODE>103 #endif</CODE> </p>
<p class=book><CODE>104</CODE></p>
<p class=book><CODE>105 /*</CODE></p>
<p class=book><CODE>106 * Initialize the shared data.</CODE></p>
<p class=book><CODE>107 */</CODE></p>
<p class=book><CODE>108 for (data_count = 0; data_count &lt; DATASIZE; data_count++) {</CODE></p>
<p class=book><CODE>109 	data[data_count].data = 0;</CODE></p>
<p class=book><CODE>110 	data[data_count].updates = 0;</CODE></p>
<p class=book><CODE>111 	status = rwl_init (&data[data_count].lock);</CODE></p>
<p class=book><CODE>112 	if (status != 0)</CODE></p>
<p class=book><CODE>113 		err_abort (status, "Init rw lock");</CODE></p>
<p class=book><CODE>114 }</CODE> </p>
<p class=book><CODE>115</CODE></p>
<p class=book><CODE>116 /*</CODE></p>
<p class=book><CODE>117 * Create THREADS threads to access shared data.</CODE></p>
<p class=book><CODE>118 */</CODE></p>
<p class=book><CODE>119 for (count = 0; count &lt; THREADS; count++) {</CODE></p>
<p class=book><CODE>120 	threads[count].thread_num = count;</CODE></p>
<p class=book><CODE>121 	threads[count].updates = 0;</CODE></p>
<p class=book><CODE>122 	threads[count].reads = 0;</CODE></p>
<p class=book><CODE>123 	threads[count].interval = rand_r (&seed) % 71;</CODE></p>
<p class=book><CODE>124 	status = pthread_create (&threads[count].thread_id,</CODE></p>
<p class=book><CODE>125 		NULL, thread_routine, (void*)&threads[count]);</CODE></p>
<p class=book><CODE>126 	if (status != 0)</CODE></p>
<p class=book><CODE>127 		err_abort (status, "Create thread");</CODE></p>
<p class=book><CODE>128 }</CODE> </p>
<p class=book><CODE>129</CODE></p>
<p class=book><CODE>130 /*</CODE></p>
<p class=book><CODE>131 * Wait for all threads to complete, and collect</CODE></p>
<p class=book><CODE>132 * statistics.</CODE></p>
<p class=book><CODE>133 */</CODE></p>
<p class=book><CODE>134 for (count = 0; count &lt; THREADS; count++) {</CODE></p>
<p class=book><CODE>135 	status = pthread_join (threads[count].thread_id, NULL);</CODE></p>
<p class=book><CODE>136 	if (status != 0)</CODE></p>
<p class=book><CODE>137 		err_abort (status, "Join thread");</CODE></p>
<p class=book><CODE>138 	thread_updates += threads[count].updates;</CODE></p>
<p class=book><CODE>139 	printf ("%02d: interval %d, updates %d, reads %d\n",</CODE></p>
<p class=book><CODE>140 		count, threads[count].interval,</CODE></p>
<p class=book><CODE>141 		threads[count].updates, threads[count].reads);</CODE></p>
<p class=book><CODE>142 }</CODE> </p>
<p class=book><CODE>143</CODE></p>
<p class=book><CODE>144 /*</CODE></p>
<p class=book><CODE>145 * Collect statistics for the data.</CODE></p>
<p class=book><CODE>146 */</CODE></p>
<p class=book><CODE>147 for (data_count = 0; data_count &lt; DATASIZE; data_count++) {</CODE></p>
<p class=book><CODE>148 	data_updates += data[data_count].updates;</CODE></p>
<p class=book><CODE>149 	printf ("data %02d: value %d, %d updates\n",</CODE></p>
<p class=book><CODE>150 		data_count, data[data_count].data,</CODE></p>
<p class=book><CODE>151 		data[data_count].updates);</CODE></p>
<p class=book><CODE>152 	rwl_destroy (&data[data_count].lock);</CODE></p>
<p class=book><CODE>153 }</CODE> </p>
<p class=book><CODE>154</CODE></p>
<p class=book><CODE>155 printf ("%d thread updates, %d data updates\n",</CODE></p>
<p class=book><CODE>156 thread_updates, data_updates);</CODE></p>
<p class=book><CODE>157 return 0;</CODE></p>



<a name=t118></a><h3 class=book>
7.2 Work queue manager
</h3>
<p class=book>I've already briefly outlined the various models of thread cooperation. These include pipelines, work crews, client/servers, and so forth. In this section, I present the development of a "work queue," a set of threads that accepts work requests from a common queue, processing them (potentially) in parallel.</p>
<p class=book>The work <i>queue</i> manager could also be considered a work <i>crew</i> manager, depending on your reference point. If you think of it as a way to feed work to a set of threads, then "work crew" might be more appropriate. I prefer to think of it as a queue that magically does work for you in the background, since the presence of the work crew is almost completely invisible to the caller.</p>
<p class=book>When you create the work queue, you can specify the maximum level of parallelism that you need. The work queue manager interprets that as the maximum number of "engine" threads that it may create to process your requests. Threads will be started and stopped as required by the amount of work. A thread that finds nothing to do will wait a short time and then terminate. The optimal "short time" depends on how expensive it is to create a new thread on your system, the cost in system resources to keep a thread going that's not doing anything, and how likely it is that you'll need the thread again soon. I've chosen two seconds, which is probably much too long.</p>
<p class=book>The header file workq.h and the C source file workq.c demonstrate an implementation of a work queue manager. Part 1 shows the two structure types used by the work queue package. The <CODE>workq_t</CODE> type is the external representation of a work queue, and the <CODE>workq_ele_t</CODE> is an internal representation of work items that have been queued. </p>
<p class=book><b>6-9</b> The <CODE>workq_ele_t</CODE> structure is used to maintain a linked list of work items. It has a link element (called next) and a data value, which is stored when the work item is queued and passed to the caller's "engine function" with no interpretation. </p>
<p class=book><b>14-16</b> Of course, there's a mutex to serialize access to the <CODE>workq_t</CODE>, and a condition variable (<CODE>cv</CODE>) on which the engine threads wait for work to be queued.</p>
<p class=book><b>17</b> The <CODE>attr</CODE> member is a thread attributes object, used when creating new engine threads. The attributes object could instead have been a static variable within workq.c, but I chose to add a little memory overhead to each work queue, rather than add the minor complexity of one-time initialization of a static data item.</p>
<p class=book><b>18</b> The first member points to the first item on the work queue. As an optimization to make it easier to queue new items at the end of the queue, the last member points to the last item on the queue.</p>
<p class=book><b>19-24</b> These members record assorted information about the work queue. The valid member is a magic number that's set when the work queue is initialized, as we've seen before in barriers and read/write locks. (In this case, the magic number is the month and year of my daughter's birthday.) The quit member is a flag that allows the "work queue manager" to tell engine threads to terminate as soon as the queue is empty. The parallelism member records how many threads the creator chose to allow the work queue to utilize, counter records the number of threads created, and idle records the current number of threads that are waiting for work. The engine member is the user's "engine function," supplied when the work queue was created. As you can see, the engine function takes an "untyped" (void *) argument, and has no return value.</p>
<p class=book>■ workq.h part 1 workq_t</p>
<p class=book><CODE>1 #include &lt;pthread.h&gt;</CODE> </p>
<p class=book><CODE>2</CODE></p>
<p class=book><CODE>3 /*</CODE></p>
<p class=book><CODE>4 * Structure to keep track of work queue requests.</CODE></p>
<p class=book><CODE>5 */</CODE></p>
<p class=book><CODE>6 typedef struct workq_ele_tag {</CODE></p>
<p class=book><CODE>7 	struct workq_ele_tag *next;</CODE></p>
<p class=book><CODE>8 	void *data;</CODE></p>
<p class=book><CODE>9 } workq_ele_t;</CODE> </p>
<p class=book><CODE>10</CODE></p>
<p class=book><CODE>11 /*</CODE></p>
<p class=book><CODE>12 * Structure describing a work queue.</CODE></p>
<p class=book><CODE>13 */</CODE></p>
<p class=book><CODE>14 typedef struct workq_tag {</CODE></p>
<p class=book><CODE>15	pthread_mutex_t	mutex;	/* control access to queue	<b>*/</b></CODE></p>
<p class=book><CODE>16	pthread_cond_t	cv;	/* wait for work */	</CODE></p>
<p class=book><CODE>17	pthread_attr_t	attr;	/* create detached threads	<b>*/</b></CODE></p>
<p class=book><CODE>18	workq_ele_t	*first, *last;	/* work queue */	</CODE></p>
<p class=book><CODE>19	int	valid;	/* valid */	</CODE></p>
<p class=book><CODE>20	int	quit;	/* workq should quit */	</CODE></p>
<p class=book><CODE>21	int	parallelism;	/* maximum threads */	</CODE></p>
<p class=book><CODE>22	int	counter;	/* current threads */	</CODE></p>
<p class=book><CODE>23	int	idle;	/* number of idle threads *	<b>/</b></CODE></p>
<p class=book><CODE>24	void	(*engine)(void	*arg); /* user engine */	</CODE></p>
<p class=book><CODE>25 } workq_t; 26</CODE></p>
<p class=book><CODE>27 #define WORKQ_VALID 0xdec1992</CODE></p>
<p class=book>Part 2 shows the interfaces we'll create for our work queue. We need to create and destroy work queue managers, so we'll define <CODE>workq_init</CODE> and <CODE>workq_destroy</CODE>. Both take a pointer to a <CODE>workq_t</CODE> structure. In addition, the initializer needs the maximum number of threads the manager is allowed to create to service the queue, and the engine function. Finally, the program needs to be able to queue work items for processing — we'll call the interface for this <CODE>workq_add</CODE>. It takes a pointer to the <CODE>workq_t</CODE> and the argument that should be passed to the engine function.</p>
<p class=book>■ workq.h  part 2 interfaces</p>
<p class=book><CODE>1 /*</CODE></p>
<p class=book><CODE>2 * Define work queue functions.</CODE></p>
<p class=book><CODE>3 */</CODE></p>
<p class=book><CODE>4 extern int workq_init (</CODE></p>
<p class=book><CODE>5 	workq_t *wq,</CODE></p>
<p class=book><CODE>6 	int threads, /* maximum threads */</CODE></p>
<p class=book><CODE>7 	void (*engine)(void *)); /* engine routine */</CODE></p>
<p class=book><CODE>8 extern int workq_destroy (workq_t *wq);</CODE></p>
<p class=book><CODE>9 extern int workq_add (workq_t *wq, void *data);</CODE></p>
<p class=book>The file workq.c contains the implementation of our work queue. The following examples break down each of the functions used to implement the workq.h interfaces.</p>
<p class=book>Part 1 shows the <CODE>workq_init</CODE> function, which initializes a work queue. We create the Pthreads synchronization objects that we need, and fill in the remaining members.</p>
<p class=book><b>14-22</b> Initialize the thread attributes object <CODE>attr</CODE> so that the engine threads we create will run detached. That means we do not need to keep track of their thread identifier values, or worry about joining with them.</p>
<p class=book><b>34-40</b> We're not ready to quit yet (we've hardly started!), so clear the quit flag. The parallelism member records the maximum number of threads we are allowed to create, which is the <CODE>workq_init</CODE> parameter threads. The counter member will record the current number of active engine threads, initially 0, and idle will record the number of active threads waiting for more work. And of course, finally, we set the valid member.</p>
<p class=book>■ workq.c part 1 workq_init</p>
<p class=book><CODE>1 #include &lt;pthread.h&gt;</CODE></p>
<p class=book><CODE>2 #include &lt;stdlib.h&gt;</CODE></p>
<p class=book><CODE>3 #include &lt;time.h&gt;</CODE></p>
<p class=book><CODE>4 #include "errors.h"</CODE></p>
<p class=book><CODE>5 #include "workq.h"</CODE> </p>
<p class=book><CODE>6</CODE></p>
<p class=book><CODE>7 /*</CODE></p>
<p class=book><CODE>8 * Initialize a work queue.</CODE></p>
<p class=book><CODE>9 */</CODE></p>
<p class=book><CODE>10 int workq_init (workq_t *wq, int threads, void (*engine)(void *arg))</CODE></p>
<p class=book><CODE>11 {</CODE></p>
<p class=book><CODE>12 int status;</CODE></p>
<p class=book><CODE>13</CODE></p>
<p class=book><CODE>14 status = pthread_attr_init (&wq-&gt;attr);</CODE></p>
<p class=book><CODE>15 if (status != 0)</CODE></p>
<p class=book><CODE>16 	return status;</CODE></p>
<p class=book><CODE>17 status = pthread_attr_setdetachstate (</CODE></p>
<p class=book><CODE>18 	&wq-&gt;attr, PTHREAD_CREATE_DETACHED);</CODE></p>
<p class=book><CODE>19 if (status != 0) {</CODE></p>
<p class=book><CODE>20 	pthread_attr_destroy (&wq-&gt;attr);</CODE></p>
<p class=book><CODE>21 	return status;</CODE></p>
<p class=book><CODE>22 }</CODE></p>
<p class=book><CODE>23 status = pthread_mutex_init (&wq-&gt;mutex, NULL);</CODE></p>
<p class=book><CODE>24 if (status != 0) {</CODE></p>
<p class=book><CODE>25 	pthread_attr_destroy (&wq-&gt;attr);</CODE> </p>
<p class=book><CODE>26 	return status;</CODE></p>
<p class=book><CODE>27 }</CODE></p>
<p class=book><CODE>28 status = pthread_cond_init (&wq-&gt;cv, NULL);</CODE></p>
<p class=book><CODE>29 if (status != 0) {</CODE></p>
<p class=book><CODE>30 	pthread_mutex_destroy (&wq-&gt;mutex);</CODE></p>
<p class=book><CODE>31 	pthread_attr_destroy (&wq-&gt;attr);</CODE></p>
<p class=book><CODE>32 	return status;</CODE></p>
<p class=book><CODE>33 }</CODE></p>
<p class=book><CODE>34 wq-&gt;quit = 0; /* not time to quit */</CODE></p>
<p class=book><CODE>35 wq-&gt;first = wq-&gt;last = NULL; /* no queue entries */</CODE></p>
<p class=book><CODE>36 wq-&gt;parallelism = threads; /* max servers */</CODE></p>
<p class=book><CODE>37 wq-&gt;counter = 0; /* no server threads yet */</CODE></p>
<p class=book><CODE>38 wq-&gt;idle = 0; /* no idle servers */</CODE></p>
<p class=book><CODE>39 wq-&gt;engine = engine;</CODE></p>
<p class=book><CODE>40 wq-&gt;valid = WORKQ_VALID;</CODE></p>
<p class=book><CODE>41 return 0;</CODE></p>
<p class=book><CODE>42 }</CODE></p>
<p class=book>■ workq.c part 1 workq_init</p>
<p class=book>Part 2 shows the <CODE>workq_destroy</CODE> function. The procedure for shutting down a work queue is a little different than the others we've seen. Remember that the Pthreads mutex and condition variable destroy function fail, returning EBUSY, when you try to destroy an object that is in use. We used the same model for barriers and read/write locks. But we cannot do the same for work queues — the calling program cannot know whether the work queue is in use, because the caller only queues requests that are processed asynchronously.</p>
<p class=book>The work queue manager will accept a request to shut down at any time, but it will wait for all existing engine threads to complete their work and terminate. Only when the last work queue element has been processed and the last engine thread has exited will <CODE>workq_destroy</CODE> return successfully. </p>
<p class=book><b>24</b> If the work queue has no threads, either it was never used or all threads have timed out and shut down since it was last used. That makes things easy, and we can skip all the shutdown complication.</p>
<p class=book><b>25-33</b> If there are engine threads, they are asked to shut down by setting the quit flag in the <CODE>workq_t</CODE> structure and broadcasting the condition variable to awaken any waiting (idle) engine threads. Each engine thread will eventually run and see this flag. When they see it and find no more work, they'll shut themselves down.</p>
<p class=book><b>44-50</b> The last thread to shut down will wake up the thread that's waiting in <CODE>workq_destroy</CODE>, and the shutdown will complete. Instead of creating a condition variable that's used only to wake up workq_destroy, the last thread will signal the same condition variable used to inform idle engine threads of new work. At this point, all waiters have already been awakened by a broadcast, and they won't wait again because the quit flag is set. Shutdown occurs only once during the life of the work queue manager, so there's little point to creating a separate condition variable for this purpose.</p>
<p class=book>■ workq.c part 2 workq_destroy</p>
<p class=book><CODE>1 /*</CODE></p>
<p class=book><CODE>2 * Destroy a work queue.</CODE></p>
<p class=book><CODE>3 */</CODE></p>
<p class=book><CODE>4 int workq_destroy (workq_t *wq)</CODE></p>
<p class=book><CODE>5 {</CODE></p>
<p class=book><CODE>6 int status, status1, status2;</CODE></p>
<p class=book><CODE>7</CODE></p>
<p class=book><CODE>8 if (wq-&gt;valid != WORKQ_VALID)</CODE></p>
<p class=book><CODE>9 	return EINVAL;</CODE></p>
<p class=book><CODE>10 status = pthread_mutex_lock (&wq-&gt;mutex);</CODE></p>
<p class=book><CODE>11 if (status != 0)</CODE></p>
<p class=book><CODE>12 	return status;</CODE></p>
<p class=book><CODE>13 wq-&gt;valid = 0; /* prevent any other operations */</CODE> </p>
<p class=book><CODE>14</CODE></p>
<p class=book><CODE>15 /*</CODE></p>
<p class=book><CODE>16 * Check whether any threads are active, and run them down:</CODE></p>
<p class=book><CODE>17 *</CODE></p>
<p class=book><CODE>18 * 1. set the quit flag</CODE></p>
<p class=book><CODE>19 * 2. broadcast to wake any servers that may be asleep</CODE></p>
<p class=book><CODE>20 * 4. wait for all threads to quit (counter goes to 0)</CODE></p>
<p class=book><CODE>21 * Because we don't use join, we don't need to worry</CODE></p>
<p class=book><CODE>22 * about tracking thread IDs.</CODE></p>
<p class=book><CODE>23 */</CODE></p>
<p class=book><CODE>24 if (wq-&gt;counter &gt; 0) {</CODE></p>
<p class=book><CODE>25 	wq-&gt;quit = 1;</CODE></p>
<p class=book><CODE>26 /* if any threads are idling, wake them. */</CODE></p>
<p class=book><CODE>27 if (wq-&gt;idle &gt; 0) {</CODE></p>
<p class=book><CODE>28 	status = pthread_cond_broadcast (&wq-&gt;cv);</CODE></p>
<p class=book><CODE>29 	if (status != 0) {</CODE></p>
<p class=book><CODE>30 		pthread_mutex_unlock (&wq-&gt;mutex);</CODE></p>
<p class=book><CODE>31 		return status;</CODE></p>
<p class=book><CODE>32 	}</CODE></p>
<p class=book><CODE>33 }</CODE> </p>
<p class=book><CODE>34</CODE></p>
<p class=book><CODE>35 /*</CODE></p>
<p class=book><CODE>36 * Just to prove that every rule has an exception, I'm</CODE></p>
<p class=book><CODE>37 * using the "cv" condition for two separate predicates</CODE></p>
<p class=book><CODE>38 * here. That's OK, since the case used here applies</CODE></p>
<p class=book><CODE>39 * only once during the life of a work queue — during</CODE></p>
<p class=book><CODE>40 * rundown. The overhead is minimal and it's not worth</CODE></p>
<p class=book><CODE>41 * creating a separate condition variable that would</CODE></p>
<p class=book><CODE>42 * wait and be signaled exactly once!</CODE></p>
<p class=book><CODE>43 */</CODE></p>
<p class=book><CODE>44 while (wq-&gt;counter &gt; 0) {</CODE></p>
<p class=book><CODE>45 	status = pthread_cond_wait (&wq-&gt;cv, &wq-&gt;mutex);</CODE></p>
<p class=book><CODE>46 	if (status != 0) {</CODE></p>
<p class=book><CODE>47 		pthread_mutex_unlock (&wq-&gt;mutex);</CODE></p>
<p class=book><CODE>48 r		eturn status;</CODE></p>
<p class=book><CODE>49 	}</CODE></p>
<p class=book><CODE>50 }</CODE></p>
<p class=book><CODE>51 }</CODE></p>
<p class=book><CODE>52 status = pthread_mutex_unlock (&wq-&gt;mutex);</CODE></p>
<p class=book><CODE>53 if (status != 0)</CODE></p>
<p class=book><CODE>54 	return status;</CODE></p>
<p class=book><CODE>55 status = pthread_mutex_destroy (&wq-&gt;mutex);</CODE></p>
<p class=book><CODE>56 status1 = pthread_cond_destroy (&wq-&gt;cv);</CODE></p>
<p class=book><CODE>57 status2 = pthread_attr_destroy (&wq-&gt;attr);</CODE></p>
<p class=book><CODE>58 return (status ? status : (status1 ? status1 : status2));</CODE></p>
<p class=book><CODE>59 }</CODE></p>
<p class=book>Part 3 shows <CODE>workq_add</CODE>, which accepts work for the queue manager system. </p>
<p class=book><b>16-35</b> It allocates a new work queue element and initializes it from the parameters. It</p>
<p class=book>queues the element, updating the first and last pointers as necessary. </p>
<p class=book><b>40-45</b> If there are idle engine threads, which were created but ran out of work, signal</p>
<p class=book>the condition variable to wake one. </p>
<p class=book><b>46-59</b> If there are no idle engine threads, and the value of parallelism allows for</p>
<p class=book>more, create a new engine thread. If there are no idle threads and it can't create a</p>
<p class=book>new engine thread, <CODE>workq_add</CODE> returns, leaving the new element for the next</p>
<p class=book>thread that finishes its current assignment.</p>
<p class=book>■ <b>workq.c part 3 workq_add</b></p>
<p class=book><CODE>1 /*</CODE></p>
<p class=book><CODE>2 * Add an item to a work queue.</CODE></p>
<p class=book><CODE>3 */</CODE></p>
<p class=book><CODE>4 int workq_add (workq_t *wq, void *element)</CODE></p>
<p class=book><CODE>5 {</CODE></p>
<p class=book><CODE>6 workq_ele_t *item;</CODE></p>
<p class=book><CODE>7 pthread_t id;</CODE></p>
<p class=book><CODE>8 int status;</CODE> </p>
<p class=book><CODE>9</CODE></p>
<p class=book><CODE>10 if (wq-&gt;valid != WORKQ_VALID)</CODE></p>
<p class=book><CODE>11 	return EINVAL;</CODE> </p>
<p class=book><CODE>12</CODE></p>
<p class=book><CODE>13 /*</CODE></p>
<p class=book><CODE>14 * Create and initialize a request structure.</CODE></p>
<p class=book><CODE>15 */</CODE></p>
<p class=book><CODE>16 item = (workq_ele_t *)malloc (sizeof (workq_ele_t));</CODE></p>
<p class=book><CODE>17 if (item == NULL)</CODE></p>
<p class=book><CODE>18 	return ENOMEM;</CODE></p>
<p class=book><CODE>19 item-&gt;data = element;</CODE></p>
<p class=book><CODE>20 item-&gt;next = NULL;</CODE></p>
<p class=book><CODE>21 status = pthread_mutex_lock (&wq-&gt;mutex);</CODE></p>
<p class=book><CODE>22 if (status != 0) {</CODE></p>
<p class=book><CODE>23 	free (item);</CODE></p>
<p class=book><CODE>24 	return status;</CODE></p>
<p class=book><CODE>25 }</CODE> </p>
<p class=book><CODE>26</CODE></p>
<p class=book><CODE>27 /*</CODE></p>
<p class=book><CODE>28 * Add the request to the end of the queue, updating the</CODE></p>
<p class=book><CODE>29 * first and last pointers.</CODE></p>
<p class=book><CODE>30 */</CODE></p>
<p class=book><CODE>31 if (wq-&gt;first == NULL)</CODE></p>
<p class=book><CODE>32 wq-&gt;first = item;</CODE></p>
<p class=book><CODE>33 else</CODE></p>
<p class=book><CODE>34 wq-&gt;last-&gt;next = item;</CODE></p>
<p class=book><CODE>35 wq-&gt;last = item;</CODE> </p>
<p class=book><CODE>36</CODE></p>
<p class=book><CODE>37 /*</CODE></p>
<p class=book><CODE>38 * if any threads are idling, wake one.</CODE></p>
<p class=book><CODE>39 */</CODE></p>
<p class=book><CODE>40 if (wq-&gt;idle &gt; 0) {</CODE></p>
<p class=book><CODE>41 	status = pthread_cond_signal (&wq-&gt;cv);</CODE></p>
<p class=book><CODE>42 	if (status != 0) {</CODE></p>
<p class=book><CODE>43 		pthread_mutex_unlock (&wq-&gt;mutex);</CODE></p>
<p class=book><CODE>44 		return status;</CODE></p>
<p class=book><CODE>45 	}</CODE></p>
<p class=book><CODE>46 } else if (wq-&gt;counter &lt; wq-&gt;parallelism) {</CODE></p>
<p class=book><CODE>47 /*</CODE></p>
<p class=book><CODE>48 * If there were no idling threads, and we're allowed to</CODE></p>
<p class=book><CODE>49 * create a new thread, do so.</CODE></p>
<p class=book><CODE>50 */</CODE></p>
<p class=book><CODE>51 	DPRINTF (("Creating new worker\n"));</CODE></p>
<p class=book><CODE>52 	status = pthread_create (</CODE></p>
<p class=book><CODE>53 		&id, &wq-&gt;attr, workq_server, (void*)wq);</CODE></p>
<p class=book><CODE>54 	if (status != 0) {</CODE></p>
<p class=book><CODE>55 		pthread_mutex_unlock (&wq-&gt;mutex);</CODE></p>
<p class=book><CODE>56 		return status;</CODE></p>
<p class=book><CODE>57 	}</CODE></p>
<p class=book><CODE>58 wq-&gt;counter++;</CODE></p>
<p class=book><CODE>59 }</CODE></p>
<p class=book><CODE>60 pthread_mutex_unlock (&wq-&gt;mutex);</CODE></p>
<p class=book><CODE>61 return 0;</CODE></p>
<p class=book>That takes care of all the external interfaces, but we will need one more function, the start function for the engine threads. The function, shown in part 4, is called <CODE>workq_server</CODE>. Although we could start a thread running the caller's engine with the appropriate argument for each request, this is more efficient. The <CODE>workq_server</CODE> function will dequeue the next request and pass it to the engine function, then look for new work. It will wait if necessary and shut down only when a certain period of time passes without any new work appearing, or when told to shut down by <CODE>workq_destroy</CODE>.</p>
<p class=book>Notice that the server begins by locking the work queue mutex, and the "matching" unlock does not occur until the engine thread is ready to terminate. Despite this, the thread spends most of its life with the mutex unlocked, either waiting for work in the condition variable wait or within the caller's engine function.</p>
<p class=book><b>29-62</b> When a thread completes the condition wait loop, either there is work to be done or the work queue is shutting down (<CODE>wq-&gt;quit</CODE> is nonzero).</p>
<p class=book><b>67-80</b> First, we check for work and process the work queue element if there is one. There could still be work queued when workq_destroy is called, and it must all be processed before any engine thread terminates.</p>
<p class=book>The user's engine function is called with the mutex unlocked, so that the user's engine can run a long time, or block, without affecting the execution of other engine threads. That does not necessarily mean that engine functions can run in parallel — the caller-supplied engine function is responsible for ensuring whatever synchronization is needed to allow the desired level of concurrency or parallelism. Ideal engine functions would require little or no synchronization and would run in parallel.</p>
<p class=book><b>86-104</b> When there is no more work and the queue is being shut down, the thread terminates, awakening workq_destroy if this was the last engine thread to shut down.</p>
<p class=book><b>110-114</b> Finally we check whether the engine thread timed out looking for work, which</p>
<p class=book>would mean the engine has waited long enough. If there's still no work to be found, the engine thread exits.</p>
<p class=book>■ <b>workq.c</b> part 4 workq_server</p>
<p class=book><CODE>1 /*</CODE></p>
<p class=book><CODE>2 * Thread start routine to serve the work queue.</CODE></p>
<p class=book><CODE>3 */</CODE></p>
<p class=book><CODE>4 static void *workq_server (void *arg)</CODE></p>
<p class=book><CODE>5 {</CODE></p>
<p class=book><CODE>6 struct timespec timeout;</CODE></p>
<p class=book><CODE>7 workq_t *wq = (workq_t *)arg;</CODE></p>
<p class=book><CODE>8 workq_ele_t *we;</CODE></p>
<p class=book><CODE>9 int status, timedout;</CODE></p>
<p class=book><CODE>10</CODE></p>
<p class=book><CODE>11  /*</CODE></p>
<p class=book><CODE>12 * We don't need to validate the workq_t here... we don't</CODE></p>
<p class=book><CODE>13 * create server threads until requests are queued (the</CODE></p>
<p class=book><CODE>14 * queue has been initialized by then!) and we wait for all</CODE></p>
<p class=book><CODE>15 * server threads to terminate before destroying a work</CODE></p>
<p class=book><CODE>16 * queue.</CODE></p>
<p class=book><CODE>17 */</CODE></p>
<p class=book><CODE>18 DPRINTF (("A worker is starting\n"));</CODE></p>
<p class=book><CODE>19 status = pthread_mutex_lock (&wq-&gt;mutex);</CODE></p>
<p class=book><CODE>20 if (status != 0)</CODE></p>
<p class=book><CODE>21 	return NULL;</CODE> </p>
<p class=book><CODE>22</CODE></p>
<p class=book><CODE>23 while (1) {</CODE></p>
<p class=book><CODE>24 	timedout = 0;</CODE></p>
<p class=book><CODE>25 	DPRINTF (("Worker waiting for work\n"));</CODE></p>
<p class=book><CODE>26 	clock_gettime (CLOCK_REALTIME, &timeout);</CODE></p>
<p class=book><CODE>27 	timeout.tv_sec += 2;</CODE> </p>
<p class=book><CODE>28</CODE></p>
<p class=book><CODE>29 	while (wq-&gt;first == NULL && !wq-&gt;quit) {</CODE></p>
<p class=book><CODE>30 /*</CODE></p>
<p class=book><CODE>31 * Server threads time out after spending 2 seconds</CODE></p>
<p class=book><CODE>32 * waiting for new work, and exit.</CODE></p>
<p class=book><CODE>33 */</CODE></p>
<p class=book><CODE>34 		status = pthread_cond_timedwait (</CODE></p>
<p class=book><CODE>35 			&wq-&gt;cv, &wq-&gt;mutex, &timeout);</CODE></p>
<p class=book><CODE>36 		If (status == ETIMEDOUT) {</CODE></p>
<p class=book><CODE>37 			DPRINTF (("Worker wait timed out\n"));</CODE></p>
<p class=book><CODE>38 			timedout = 1;</CODE></p>
<p class=book><CODE>39 			break;</CODE></p>
<p class=book><CODE>40 		} else if (status != 0) {</CODE></p>
<p class=book><CODE>41 /*</CODE></p>
<p class=book><CODE>42 * This shouldn't happen, so the work queue</CODE></p>
<p class=book><CODE>43 * package should fail. Because the work queue</CODE></p>
<p class=book><CODE>44 * API is asynchronous, that would add</CODE></p>
<p class=book><CODE>45 * complication. Because the chances of failure</CODE></p>
<p class=book><CODE>46 * are slim, I choose to avoid that</CODE></p>
<p class=book><CODE>47 * complication. The server thread will return,</CODE></p>
<p class=book><CODE>48 * and allow another server thread to pick up</CODE></p>
<p class=book><CODE>49 * the work later. Note that if this were the</CODE></p>
<p class=book><CODE>50 * only server thread, the queue wouldn't be</CODE></p>
<p class=book><CODE>51 * serviced until a new work item is</CODE></p>
<p class=book><CODE>52 * queued. That could be fixed by creating a new</CODE></p>
<p class=book><CODE>53 * server here.</CODE></p>
<p class=book><CODE>54 */</CODE></p>
<p class=book><CODE>55 			DPRINTF ((</CODE></p>
<p class=book><CODE>56 				"Worker wait failed, %d (%s)\n",</CODE></p>
<p class=book><CODE>57 				status, strerror (status)));</CODE></p>
<p class=book><CODE>58 			wq-&gt;counter--;</CODE></p>
<p class=book><CODE>59 			pthread_mutex_unlock (&wq-&gt;mutex);</CODE></p>
<p class=book><CODE>60 			return NULL;</CODE></p>
<p class=book><CODE>61 		}</CODE></p>
<p class=book><CODE>62 	}</CODE></p>
<p class=book><CODE>63 	DPRINTF (("Work queue: %#lx, quit: %d\n",</CODE></p>
<p class=book><CODE>64 		wq-&gt;first, wq-&gt;quit));</CODE></p>
<p class=book><CODE>65 	we = wq-&gt;first;</CODE> </p>
<p class=book><CODE>66</CODE></p>
<p class=book><CODE>67 	if (we != NULL) {</CODE></p>
<p class=book><CODE>68 		wq-&gt;first = we-&gt;next;</CODE></p>
<p class=book><CODE>69 	If (wq-&gt;last == we)</CODE></p>
<p class=book><CODE>70 		wq-&gt;last = NULL;</CODE></p>
<p class=book><CODE>71 	status = pthread_mutex_unlock (&wq-&gt;mutex);</CODE></p>
<p class=book><CODE>72 	If (status != 0)</CODE></p>
<p class=book><CODE>73 		return NULL;</CODE></p>
<p class=book><CODE>74 	DPRINTF (("Worker calling engine\n"));</CODE></p>
<p class=book><CODE>75 	wq-&gt;engine (we-&gt;data);</CODE></p>
<p class=book><CODE>76 	free (we);</CODE></p>
<p class=book><CODE>77 	status = pthread_mutex_lock (&wq-&gt;mutex);</CODE></p>
<p class=book><CODE>78 	if (status ! = 0)</CODE></p>
<p class=book><CODE>79 		return NULL;</CODE></p>
<p class=book><CODE>80 }</CODE> </p>
<p class=book><CODE>81</CODE></p>
<p class=book><CODE>82 /*</CODE></p>
<p class=book><CODE>83 * If there are no more work requests, and the servers</CODE></p>
<p class=book><CODE>84 * have been asked to quit, then shut down.</CODE></p>
<p class=book><CODE>85 */</CODE></p>
<p class=book><CODE>86 if (wq-&gt;first == NULL && wq-&gt;quit) {</CODE></p>
<p class=book><CODE>87 	DPRINTF (("Worker shutting down\n"));</CODE></p>
<p class=book><CODE>88 	wq-&gt;counter--;</CODE> </p>
<p class=book><CODE>89</CODE></p>
<p class=book><CODE>90 /*</CODE></p>
<p class=book><CODE>91 * NOTE: Just to prove that every rule has an</CODE></p>
<p class=book><CODE>92 * exception, I'm using the "cv" condition for two</CODE></p>
<p class=book><CODE>93 * separate predicates here. That's OK, since the</CODE></p>
<p class=book><CODE>94 * case used here applies only once during the life</CODE></p>
<p class=book><CODE>95 * of a work queue — during rundown. The overhead</CODE></p>
<p class=book><CODE>96 * is minimal and it's not worth creating a separate</CODE></p>
<p class=book><CODE>97 * condition variable that would wait and be</CODE></p>
<p class=book><CODE>98 * signaled exactly once!</CODE></p>
<p class=book><CODE>99 */</CODE></p>
<p class=book><CODE>100 	if (wq-&gt;counter == 0)</CODE></p>
<p class=book><CODE>101 		pthread_cond_broadcast (&wq-&gt;cv);</CODE></p>
<p class=book><CODE>102 	pthread_mutex_unlock (&wq-&gt;mutex);</CODE></p>
<p class=book><CODE>103 	return NULL;</CODE></p>
<p class=book><CODE>104 }</CODE> </p>
<p class=book><CODE>105</CODE></p>
<p class=book><CODE>106 /*</CODE></p>
<p class=book><CODE>107 * If there's no more work, and we wait for as long as</CODE></p>
<p class=book><CODE>108 * we're allowed, then terminate this server thread.</CODE></p>
<p class=book><CODE>109 */</CODE></p>
<p class=book><CODE>110 if (wq-&gt;first == NULL && timedout) {</CODE></p>
<p class=book><CODE>111 	DPRINTF (("engine terminating due to timeout.\n"));</CODE></p>
<p class=book><CODE>112	 wq-&gt;counter--;</CODE> </p>
<p class=book><CODE>113 	break;</CODE></p>
<p class=book><CODE>114 }</CODE></p>
<p class=book><CODE>115 }</CODE></p>
<p class=book><CODE>116</CODE></p>
<p class=book><CODE>117 pthread_mutex_unlock (&wq-&gt;mutex);</CODE></p>
<p class=book><CODE>118  DPRINTF (("Worker exiting\n"));</CODE></p>
<p class=book><CODE>119  return NULL;</CODE></p>
<p class=book><CODE>120 }</CODE></p>
<p class=book>Finally, workq_main.c is a sample program that uses our work queue manager. Two threads queue work elements to the work queue in parallel. The engine function is designed to gather some statistics about engine usage. To accomplish this, it uses thread-specific data. When the sample run completes, main collects all of the thread-specific data and reports some statistics.</p>
<p class=book><b>15-19</b> Each engine thread has an engine_t structure associated with the thread-specific data key engine_key. The engine function gets the calling thread's value of this key, and if the current value is <b>NULL,</b> creates a new engine_t structure and assigns it to the key. The calls member of engine_t structure records the number of calls to the engine function within each thread.</p>
<p class=book><b>29-37</b> The thread-specific data key's destructor function, destructor, adds the terminating thread's engine_t to a list (engine_list_head), where main can find it later to generate the final report.</p>
<p class=book><b>43-68</b> The engine function's work is relatively boring. The argument is a pointer to a power_t structure, containing the members value and power. It uses a trivial loop to multiply value by itself power times. The result is discarded in this example, and the power_t structure is freed.</p>
<p class=book><b>73-98</b> A thread is started, by main, running the thread_routine function. In addition, main calls thread_routine. The thread_routine function loops for some number of iterations, determined by the macro <b>ITERATIONS,</b> creating and queuing work queue elements. The value and power members of the power_t structure are determined semirandomly using rand_r. The function sleeps for a random period of time, from zero to four seconds, to occasionally allow engine threads to time out and terminate. Typically when you run this program you would expect to see summary messages reporting some small number of engine threads, each of which processed some number of calls — which total 50 calls (25 each from the two threads).</p>
<p class=book>■ <b>workq_main.c</b></p>
<p class=book><CODE>1 #include &lt;pthread.h&gt;</CODE></p>
<p class=book><CODE>2 #include &lt;stdlib.h&gt;</CODE></p>
<p class=book><CODE>3 #include &lt;stdio.h&gt;</CODE></p>
<p class=book><CODE>4 #include &lt;time.h&gt;</CODE></p>
<p class=book><CODE>5 #include "workq.h"</CODE></p>
<p class=book><CODE>6 #include "errors.h"</CODE></p>
<p class=book><CODE>7</CODE></p>
<p class=book><CODE>8 #define ITERATIONS 25</CODE></p>
<p class=book><CODE>9</CODE></p>
<p class=book><CODE>10 typedef struct power_tag {</CODE></p>
<p class=book><CODE>11 int value;</CODE></p>
<p class=book><CODE>12 int power;</CODE></p>
<p class=book><CODE>13 } power_t; 14</CODE></p>
<p class=book><CODE>15 typedef struct engine_tag {</CODE></p>
<p class=book><CODE>16 struct engine_tag *link;</CODE></p>
<p class=book><CODE>17 pthread_t thread_id;</CODE></p>
<p class=book><CODE>18 int calls;</CODE></p>
<p class=book><CODE>19 } engine_t; 20</CODE></p>
<p class=book><CODE>21 pthread_key_t engine_key; /* Keep track of active engines */</CODE></p>
<p class=book><CODE>22 pthread_mutex_t engine_list_mutex = PTHREAD_MUTEX_INITIALIZER;</CODE></p>
<p class=book><CODE>23 engine_t *engine_list_head = NULL;</CODE></p>
<p class=book><CODE>24 workq_t workq; 25</CODE></p>
<p class=book><CODE>26 /*</CODE></p>
<p class=book><CODE>27 * Thread-specific data destructor routine for engine_key.</CODE></p>
<p class=book><CODE>28 */</CODE></p>
<p class=book><CODE>29 void destructor (void *value_ptr)</CODE></p>
<p class=book><CODE>30 {</CODE></p>
<p class=book><CODE>31 engine_t *engine = (engine_t*)value_ptr; 32</CODE></p>
<p class=book><CODE>33 pthread_mutex_lock (&engine_list_mutex);</CODE></p>
<p class=book><CODE>34 engine-&gt;link = engine_list_head;</CODE></p>
<p class=book><CODE>35 engine_list_head = engine;</CODE></p>
<p class=book><CODE>36 pthread_mutex_unlock (&engine_list_mutex);</CODE></p>
<p class=book><CODE>37 } 38</CODE></p>
<p class=book><CODE>39 /*</CODE></p>
<p class=book><CODE>40 * This is the routine called by the work queue servers to</CODE></p>
<p class=book><CODE>41 * perform operations in parallel.</CODE></p>
<p class=book><CODE>42 */</CODE></p>
<p class=book><CODE>43 void engine_routine (void *arg)</CODE></p>
<p class=book><CODE>44 {</CODE></p>
<p class=book><CODE>45 engine_t *engine;</CODE></p>
<p class=book><CODE>46 power_t *power = (power_t*)arg;</CODE></p>
<p class=book><CODE>47 int result, count; 4 8 int status;</CODE></p>
<p class=book><CODE>49</CODE></p>
<p class=book><CODE>50 engine = pthread_getspecific (engine_key);</CODE></p>
<p class=book><CODE>51 if (engine == NULL) {</CODE></p>
<p class=book><CODE>52 engine = (engine_t*)malloc (sizeof (engine_t));</CODE></p>
<p class=book><CODE>53 status = pthread_setspecific (</CODE></p>
<p class=book><CODE>54 engine_key, (void*)engine);</CODE></p>
<p class=book><CODE>55 if (status != 0)</CODE></p>
<p class=book><CODE>56 err_abort (status, "Set tsd");</CODE></p>
<p class=book><CODE>57 engine-&gt;thread_id = pthread_self ();</CODE></p>
<p class=book><CODE>58 engine-&gt;calls = 1;</CODE></p>
<p class=book><CODE>59 } else</CODE></p>
<p class=book><CODE>60 engine-&gt;calls++;</CODE></p>
<p class=book><CODE>61 result = 1;</CODE></p>
<p class=book><CODE>62 printf (</CODE></p>
<p class=book><CODE>63 "Engine: computing %d^%d\n",</CODE></p>
<p class=book><CODE>64 power-&gt;value, power-&gt;power);</CODE></p>
<p class=book><CODE>65 for (count = 1; count &lt;= power-&gt;power; count++)</CODE></p>
<p class=book><CODE>66 result *= power-&gt;value;</CODE></p>
<p class=book><CODE>67 free (arg);</CODE></p>
<p class=book><CODE>68 }</CODE></p>
<p class=book><CODE>69</CODE></p>
<p class=book><CODE>70 /*</CODE></p>
<p class=book><CODE>71 * Thread start routine that issues work queue requests.</CODE></p>
<p class=book><CODE>72 */</CODE></p>
<p class=book><CODE>73 void *thread_routine (void *arg)</CODE></p>
<p class=book><CODE>74 {</CODE></p>
<p class=book><CODE>75 power_t *element;</CODE></p>
<p class=book><CODE>76 int count;</CODE></p>
<p class=book><CODE>77 unsigned int seed = (unsigned int)time (NULL);</CODE></p>
<p class=book><CODE>78 int status;</CODE> </p>
<p class=book><CODE>79</CODE></p>
<p class=book><CODE>80 /*</CODE></p>
<p class=book><CODE>81 * Loop, making requests.</CODE></p>
<p class=book><CODE>82 */</CODE></p>
<p class=book><CODE>83 for (count = 0; count &lt; ITERATIONS; count++) {</CODE></p>
<p class=book><CODE>84 element = (power_t*)malloc (sizeof (power_t));</CODE></p>
<p class=book><CODE>85 if (element == NULL)</CODE></p>
<p class=book><CODE>86 errno_abort ("Allocate element");</CODE></p>
<p class=book><CODE>87 element-&gt;value = rand_r (&seed) % 20;</CODE></p>
<p class=book><CODE>88 element-&gt;power = rand_r (&seed) % 7;</CODE></p>
<p class=book><CODE>89 DPRINTF ((</CODE></p>
<p class=book><CODE>90 "Request: %d^%d\n",</CODE></p>
<p class=book><CODE>91 element-&gt;value, element-&gt;power));</CODE></p>
<p class=book><CODE>92 status = workq_add (&workq, (void*)element);</CODE></p>
<p class=book><CODE>93 if (status != 0)</CODE></p>
<p class=book><CODE>94 err_abort (status, "Add to work queue");</CODE></p>
<p class=book><CODE>95 sleep (rand_r (&seed) % 5);</CODE></p>
<p class=book><CODE>96 }</CODE></p>
<p class=book><CODE>97 return NULL;</CODE></p>
<p class=book><CODE>98 } 99</CODE></p>
<p class=book><CODE>100 int main (int argc, char *argv[])</CODE></p>
<p class=book><CODE>101 {</CODE></p>
<p class=book><CODE>102 pthread_t thread_id;</CODE></p>
<p class=book><CODE>103 engine_t *engine;</CODE></p>
<p class=book><CODE>104 int count = 0, calls = 0;</CODE></p>
<p class=book><CODE>105 int status;</CODE> </p>
<p class=book><CODE>106</CODE></p>
<p class=book><CODE>107 status = pthread_key_create (&engine_key, destructor);</CODE></p>
<p class=book><CODE>108 if (status != 0)</CODE></p>
<p class=book><CODE>109 err_abort (status, "Create key");</CODE></p>
<p class=book><CODE>110 status = workq_init (&workq, 4, engine_routine);</CODE></p>
<p class=book><CODE>111 if (status != 0)</CODE></p>
<p class=book><CODE>112 err_abort (status, "Init work queue");</CODE></p>
<p class=book><CODE>113 status = pthread_create (&thread_id, NULL, thread_routine, NULL);</CODE></p>
<p class=book><CODE>114 if (status != 0)</CODE></p>
<p class=book><CODE>115 err_abort (status, "Create thread");</CODE></p>
<p class=book><CODE>116 (void)thread_routine (NULL);</CODE></p>
<p class=book><CODE>117 status = pthread_join (thread_id, NULL);</CODE></p>
<p class=book><CODE>118 if (status != 0)</CODE></p>
<p class=book><CODE>119 err_abort (status, "Join thread");</CODE></p>
<p class=book><CODE>120 status = workq_destroy (&workq);</CODE></p>
<p class=book><CODE>121 if (status != 0)</CODE></p>
<p class=book><CODE>122 err_abort (status, "Destroy work queue"); 123</CODE></p>
<p class=book><CODE>124 /*</CODE></p>
<p class=book><CODE>125 * By now, all of the engine_t structures have been placed</CODE></p>
<p class=book><CODE>126 * on the list (by the engine thread destructors), so we</CODE></p>
<p class=book><CODE>127 * can count and summarize them.</CODE></p>
<p class=book><CODE>128 */</CODE></p>
<p class=book><CODE>129 engine = engine_list_head;</CODE></p>
<p class=book><CODE>130 while (engine != NULL) {</CODE></p>
<p class=book><CODE>131 count++;</CODE></p>
<p class=book><CODE>132 calls += engine-&gt;calls;</CODE></p>
<p class=book><CODE>133 printf ("engine %d: %d calls\n", count, engine-&gt;calls);</CODE></p>
<p class=book><CODE>134 engine = engine-&gt;link;</CODE></p>
<p class=book><CODE>135 }</CODE></p>
<p class=book><CODE>136 printf ("%d engine threads processed %d calls\n",</CODE></p>
<p class=book><CODE>137 count, calls);</CODE></p>
<p class=book><CODE>138 return 0;</CODE></p>
<p class=book><CODE>139 }</CODE></p>


<a name=t119></a><h3 class=book>
7.3 But what about existing libraries?
</h3>
<blockquote class="epigraph">
<p class=book>"The great art of riding, as I was saying is—</p>
<p class=book>to keep your balance properly. Like this, you know—" He let go the bridle, and stretched out both his arms to</p>
<p class=book>show Alice what he meant, and this time he fell flat on</p>
<p class=book>his back, right under the horse's feet.</p>
<blockquote class=book><i>— <i>Lewis Carroll, Through the Looking-Glass</i></i></blockquote>
</blockquote>

<p class=book>When you create a new library, all it takes is careful design to ensure that the library will be thread-safe. As you decide what state is needed for the function, you can determine which state needs to be shared between threads, which state should be managed by the caller through external context handles, which state can be kept in local variables within a function, and so forth. You can define the interfaces to the functions to support that state in the most efficient manner. But when you're modifying an existing library to work with threads, you usually don't have that luxury. And when you are using someone else's library, you may need simply to "make do."</p>


<a name=t120></a><h3 class=book>
7.3.1 Modifying libraries to be thread-safe
</h3>
<p class=book>Many functions rely on static storage across a sequence of calls, for example, strtok or getpwd. Others depend on returning a pointer to static storage, for example, asctime. This section points out some techniques that can help when you need to make "legacy" libraries thread-safe, using some well-known examples in the ANSI C run-time library.</p>
<p class=book>The simplest technique is to assign a mutex to each subsystem. At any call into the subsystem you lock the mutex; at any exit from the subsystem you unlock the mutex. Because this single mutex covers the entire subsystem, we often refer to such a mechanism as a "big mutex" (see Section 3.2.4). The mutex prevents more than one thread from executing within the subsystem at a time. Note that this fixes only <i>synchronization races,</i> not <i>sequence races</i> (Section 8.1.2 describes the distinction between the two). The best candidates for this approach are functions that do little except maintain some internal database. That includes functions such as malloc and free that manage an internal resource pool but grant limited (or no) external visibility into that pool.</p>
<p class=book>One problem with using the "big mutex" approach is that you have to be careful about your definition of "subsystem." You need to include all functions that share data or that call each other. If malloc and free have one mutex while realloc uses another, then you've got a race as soon as one thread calls realloc while another thread is in malloc or free.</p>
<p class=book>And what if realloc is implemented to call malloc, copy data, and then call free on the old pointer? The realloc function would lock the heap mutex and call malloc. The malloc function would immediately try to lock the heap mutex itself, resulting in a deadlock. There are several ways to solve this. One is to carefully separate each of the external interfaces into an internal "engine" function that does the actual work and an external entry point that locks the subsystem mutex and calls the engine. Other entry points within the subsystem that need the same engine function would call it directly rather than using the normal entry point. That's often the most efficient solution, but it is also harder to do. Another possibility is to construct a "recursive" mutex that allows the subsystem to relock</p>
<p class=book>its own mutex without deadlock.* Now malloc and free are allowed to relock the mutex held by realloc, but another thread trying to call any of them will be blocked until realloc completely unlocks the recursive mutex.</p>
<p class=book>Most functions with persistent state require more substantial changes than just a "big mutex," especially to avoid altering the interface. The asctime function, for example, returns a pointer to the character string representation of a binary time. Traditionally, the string is formatted into a static buffer declared within the asctime function, and the function returns a pointer to that buffer.</p>
<p class=book>Locking a mutex within asctime isn't enough to protect the data. In fact, it is not even particularly useful. After asctime returns, the mutex has been unlocked. The caller needs to read the buffer, and there is nothing to prevent another thread from calling asctime (and "corrupting" the first thread's result) before the first thread has finished reading or copying it. To solve this problem using a mutex, the caller would need to lock a mutex before calling asctime, and then unlock it only after it had finished with the data or copied the returned buffer somewhere "safe."</p>
<p class=book>The problem can instead be fixed by recoding asctime to allocate a heap buffer using malloc, formatting the time string into that buffer, and returning its address. The function can use a thread-specific data key to keep track of the heap address so that it can be reused on the next call within that thread. When the thread terminates, a destructor function can free the storage.</p>
<p class=book>It would be more efficient to avoid using malloc and thread-specific data, but that requires changing the interface to asctime. Pthreads adds a new thread-safe alternative to asctime, called asctime_r, which requires the caller to pass the address and length of a buffer. The asctime_r function formats the time string into the caller's buffer. This allows the caller to manage the buffer in any way that's convenient. It can be on the thread's stack, in heap, or can even be shared between threads. Although in a way this is "giving up" on the existing function and defining a new function, it is often the best way (and sometimes the only practical way) to make a function thread-safe.</p>


<a name=t121></a><h3 class=book>
7.3.2 Living with legacy libraries
</h3>
<p class=book>Sometimes you have to work with code you didn't write, and can't change. A lot of code is now being made thread-safe, and most operating systems that support threads can be expected to supply thread-safe implementations of the</p>
<p class=book>* It is easy to construct a "recursive" mutex using a mutex, a condition variable, the pthread_ t value of the current owner (if any), and a count of the owner's "recursion depth." The depth is 0 when the recursive mutex is not locked, and greater than 0 when it is locked. The mutex protects access to the depth and owner members, and the condition variable is used to wait for the depth to become 0, should a thread wish to lock the recursive mutex while another thread has it locked.</p>
<p class=book>common bundled Library packages. The "inner circle" of thread-safe Libraries will gradually increase to become the rule rather than the exception as more applica-tion and library developers demand thread-safety.</p>
<p class=book>But inevitably you'll find that a library you need hasn't been made thread-safe, for example, an older version of the X Windows windowing system, or a database engine, or a simulation package. And you won't have source code. Of course you'll immediately complain to the supplier of the library and convince them to make the next version fully thread-safe. But what can you do until the new version arrives?</p>
<p class=book>If you really need the library, the answer is "use it anyway." There are a number of techniques you can use, from simple to complex. The appropriate level of complexity required depends entirely on the Library's interface and how (as well as how much) you use the library in your code.</p>
<p class=book> Make the unsafe library into a server thread.</p>
<p class=book>In some cases, you may find it convenient to restrict use of the library to one thread, making that thread a "server" for the capabilities provided by the unsafe library. This technique is commonly applied, for example, when using versions of the X11 protocol client library that are not thread-safe. The main thread or some other thread created for the purpose processes queued Xll requests on behalf of other threads. Only the server thread makes calls into the X11 library, so it does not matter whether X11 is thread-safe.</p>
<p class=book> Write your own "big mutex" wrappers around the interfaces.</p>
<p class=book>If the function you need has a "thread-safe interface" but not a "thread-safe implementation," then you may be able to encapsulate each call inside a wrapper function (or a macro) that locks a mutex, calls the function, and then unlocks the mutex. This is just an external version of the "big mutex" approach. By "thread-safe interface" I mean that the function relies on the static state, but that any data returned to the caller isn't subject to alteration by later calls. For example, malloc fits that category. The allocation of memory involves static data that needs to be protected, but once a block has been allocated and returned to a caller, that address (and the memory to which it points) will not be affected by later calls to malloc. The external "big mutex" is not a good solution for libraries that may block for substantial periods of time—like X11 or any other network protocol. While the result may be safe, it will be very inefficient unless you rarely use the library, because other threads may be locked out for long periods of time while remote operations are taking place.</p>
<p class=book>Extend the implementation with external state.</p>
<p class=book>A big mutex won't fix a function like asctime that writes data into a static buffer and returns the address: The returned data must be protected until the</p>
<p class=book>caller is finished using it, and the data is used outside the wrapper. For a function like strtok the data is in use until the entire <i>sequence</i> of tokens has been parsed. In general, functions that have persistent static data are more difficult to encapsulate.</p>
<p class=book>A function like asctime can be encapsulated by creating a wrapper function that locks a mutex, calls the function, copies the return value into a thread-safe buffer, unlocks the mutex, and then returns. The thread-safe buffer can be dynamically allocated by the wrapper function using malloc, for instance. You can require the caller to free the buffer when done, which changes the interface, or you can make the wrapper keep track of a per-thread buffer using thread-specific data.</p>
<p class=book>Alternatively, you could invent a new interface that requires the caller to supply a buffer. The caller can use a stack buffer, or a buffer in heap, or, if properly synchronized (by the caller}, it can share the buffer between threads. Remember that if the wrapper uses thread-specific data to keep track of a per-thread heap buffer, the wrapper can be made compatible with the original interface. The other variants require interface changes: The caller must supply different inputs or it must be aware of the need to free the returned buffer.</p>
<p class=book>A function that keeps persistent state across a sequence of calls is more difficult to encapsulate neatly. The static data must be protected throughout. The easiest way to do this is simply to change the caller to lock a mutex before the first call and keep it locked until after the final call of a sequence. But remember that no other thread can use the function until the mutex is unlocked. If the caller does a substantial amount of processing between calls, a major processing bottleneck can occur. Of course, this may also be difficult or impossible to integrate into a simple wrapper — the wrapper would have to be able to recognize the first and last of any series of calls.</p>
<p class=book>A better, but harder, way is to find some way to encapsulate the function (or a set of related functions) into a new thread-safe interface. There is no general model for this transformation, and in many cases it may be impossible. But often you just need to be creative, and possibly apply some constraints. While the library function may not be easy to encapsulate, you may be able to encapsulate "special cases" that you use. While strtok, for example, allows you to alter the token delimiters at each call, most code does not take advantage of this flexibility. Without the complication of varying delimiters, you could define a new token parsing model on top of strtok where all tokens in a string are found by a thread-safe setup function and stored where they can be retrieved one by one without calling strtok again. Thus, while the setup function would lock a common mutex and serialize access across all threads, the information retrieval function could run without any serialization.</p>




<a name=t122></a><h3 class=book>
8 Hints to avoid debugging
</h3>
<blockquote class="epigraph">
<p class=book>"Other maps are such shapes, with their islands and capes!</p>
<p class=book>But we've got our brave Captain to thank"</p>
<p class=book>(So the crew would protest) </p>
<p class=book>"that he's bought us the best— </p>
<p class=book>A perfect and absolute blank!"</p>
<blockquote class=book><i>— <i>Lewis Carroll, The Hunting of the Snark</i></i></blockquote>
</blockquote>

<p class=book>Writing a complicated threaded program is a lot harder than writing a simple synchronous program, but once you learn the rules it is not much harder than writing a complicated synchronous program. Writing a threaded program to perform a complicated <i>asynchronous</i> function will usually be easier than writing the same program using more traditional asynchronous programming techniques.</p>
<p class=book>The complications begin when you need to debug or analyze your threaded program. That's not so much because using threads is hard, but rather because the tools for debugging and analyzing threaded code are less well developed and understood than the programming interfaces. You may feel as if you are navigating from a blank map. That doesn't mean you can't utilize the power of threaded programming right now, but it does mean that you need to be careful, and maybe a little more creative, in avoiding the rocks and shoals of the uncharted waters.</p>
<p class=book>Although this chapter mentions some thread debugging and analysis tools and suggests what you can accomplish with them, my goal isn't to tell you about tools you can use to solve problems. Instead, I will describe some of the common problems that you may encounter and impart something resembling "sage advice" on avoiding those problems before you have to debug them — or, perhaps more realistically, how to recognize which problems you may be encountering.</p>
<p class=book>Check your assumptions at the door.</p>
<p class=book>Threaded programming is probably new to you. Asynchronous programming may be new to you. If so, you'll need to be careful about your assumptions. You've crossed a bridge, and behavior that's acceptable—or even required — in Synchronous Land can be dangerous across the river in Asynchronous Land. You can learn the new rules without a lot of trouble, and with practice you'll probably even feel comfortable with them. But you have to start by being constantly aware that something's changed.</p>


<a name=t123></a><h3 class=book>
8.1 Avoiding incorrect code
</h3>
<blockquote class="epigraph">
<p class=book>"For instance, now," she went on, sticking a large piece of plaster on her finger as she spoke, "there's the King's Messenger. He's in prison now, being punished: and the trial doesn't even begin till next Wednesday: and of course the crime comes last of all."</p>
<p class=book>"Suppose he never commits the crime?" said Alice.</p>
<p class=book>"That would be all the better, wouldn't it?" the Queen said, as she bound the plaster round her finger with a bit of ribbon. </p>
<blockquote class=book><i>— <i>Lewis Carroll, Through the Looking-Glass</i></i></blockquote>
</blockquote>

<p class=book>Pthreads doesn't provide much assistance in debugging your threaded code. That is not surprising, since POSIX does not recognize the concept of debugging at all, even in explaining why the nearly universal <b>SIGTRAP</b> signal is not included in the standard. There is no standard way to interact with your program or observe its behavior as it runs, although every threaded system will provide some form of debugging tool. Even in the unlikely event that the developers of the system had no concern for you, the poor programmer, they needed to debug their own code.</p>
<p class=book>A vendor that provides threads with an operating system will provide at least a basic thread "observation window" in a debugging utility. You should expect at minimum the ability to display a list of the running threads and their current state, the state of mutexes and condition variables, and the stack trace of all threads. You should also be able to set breakpoints in specified threads and specify a "current thread" to examine registers, variables, and stack traces.</p>
<p class=book>Because implementations of Pthreads are likely to maintain a lot of state in user mode, within the process, debugging using traditional UNIX mechanisms such as ptrace or the proc file system can be difficult. A common solution is to provide a special library that is called by the debugger, which knows how to search through the address space of the process being debugged to find the state of threads and synchronization objects. Solaris, for example, provides the <CODE>libthread_db.so</CODE> shared library, and Digital UNIX provides <CODE>libpthreaddebug.so</CODE>.</p>
<p class=book>A thread package placed on top of an operating system by a third party will not be able to provide much integration with a debugger. For example, the portable "DCE threads" library provides a built-in debug command parser that you can invoke from the debugger using the <b>print</b> or <b>call</b> command to report the state of threads and synchronization objects within the process<sup><a name=r8><a href="#n8" title="
For historical reasons, the function is called cma_debug. Should you find yourself stuck with DCE threads code, try calling it, and enter the help command for a list of additional commands.
">[8]</sup></A>. This limited debugging support is at best inconvenient — you can't analyze thread state within a core file after a program has failed, and it cannot understand (or report) the symbolic names of program variables.</p>
<p class=book>The following sections describe some of the most common classes of threaded programming errors, with the intention of helping you to avoid these problems while designing, as well as possibly making it easier to recognize them while debugging.</p>


<a name=t124></a><h3 class=book>
8.1.1 Avoid relying on "thread inertia"
</h3>
<p class=book>Always, <i>always,</i> remember that threads are asynchronous. That's especially important to keep in mind when you develop code on uniprocessor systems where threads may be "slightly synchronous." Nothing happens simultaneously on a uniprocessor, where <i>ready</i> threads are serially timesliced at relatively predictable intervals. When you create a new thread on a uniprocessor or unblock a thread waiting for a mutex or condition variable, it cannot run immediately unless it has a higher priority than the creator or waker.</p>
<p class=book>The same phenomenon may occur even on a multiprocessor, if you have reached the "concurrency limit" of the process, for example, when you have more <i>ready</i> threads than there are processors. The creator, or the thread waking another thread, given equal priority, will continue running until it blocks or until the next timeslice (which may be many nanoseconds away).</p>
<p class=book>This means that the thread that currently has a processor has an advantage. It tends to remain in motion, exhibiting behavior vaguely akin to physical inertia. As a result, you may get away with errors that will cause your code to break in mysterious ways when the newly created or awakened thread is able to run immediately — when there are free processors. The following program, inertia.c, demonstrates how this phenomenon can disrupt your program. </p>
<p class=book><b>27-41</b> The question is one of whether the thread function printer_thread will see the value of stringPtr that was set before the call to pthread_create, or the value set after the call to pthread_create. The desired value is "After value." This is a very common class of programming error. Of course, in most cases the problem is less obvious than in this simple example. Often, the variable is uninitialized, not set to some benign value, and the result may be data corruption or a segmentation fault.</p>
<p class=book><b>39</b> Now, notice the delay loop. Even on a multiprocessor, this program won't break all the time. The program will usually be able to change stringPtr before the new thread can begin executing — it takes time for a newly created thread to get into your code, after all, and the "window of opportunity" in this particular program is only a few instructions. The loop allows me to demonstrate the problem by delaying the main thread long enough to give the printer thread time to start. If you make this loop long enough, you will see the problem even on a uniprocessor, if main is eventually timesliced.</p>
<p class=book>■ <b>inertia.c</b></p>
<p class=book><CODE>1 #include &lt;pthread.h&gt;</CODE></p>
<p class=book><CODE>2 #include "errors.h"</CODE></p>
<p class=book><CODE>3</CODE></p>
<p class=book><CODE>4 void *printer_thread (void *arg)</CODE></p>
<p class=book><CODE>5 {</CODE></p>
<p class=book><CODE>6 char *string = *(char**)arg;</CODE></p>
<p class=book><CODE>7</CODE></p>
<p class=book><CODE>8 printf ("%s\n", string);</CODE></p>
<p class=book><CODE>9 return NULL;</CODE> </p>
<p class=book><CODE>10 }</CODE></p>
<p class=book><CODE>11</CODE></p>
<p class=book><CODE>12 int main (int argc, char *argv[])</CODE></p>
<p class=book><CODE>13 {</CODE></p>
<p class=book><CODE>14 pthread_t printer_id;</CODE></p>
<p class=book><CODE>15 char *string_ptr;</CODE></p>
<p class=book><CODE>16 int i, status; 17</CODE></p>
<p class=book><CODE>18 #ifdef sun</CODE></p>
<p class=book><CODE>19 /*</CODE></p>
<p class=book><CODE>20 * On Solaris 2.5, threads are not timesliced. To ensure</CODE></p>
<p class=book><CODE>21 * that our two threads can run concurrently, we need to</CODE></p>
<p class=book><CODE>22 * increase the concurrency level to 2.</CODE></p>
<p class=book><CODE>23 */</CODE></p>
<p class=book><CODE>24 DPRINTF (("Setting concurrency level to 2\n"));</CODE></p>
<p class=book><CODE>25 thr_setconcurrency (2);</CODE></p>
<p class=book><CODE>26 #endif</CODE></p>
<p class=book><CODE>27 string_ptr = "Before value";</CODE></p>
<p class=book><CODE>28 status = pthread_create (</CODE></p>
<p class=book><CODE>29 	&printer_id, NULL, printer_thread, (void*)&string_ptr);</CODE></p>
<p class=book><CODE>30 if (status != 0)</CODE></p>
<p class=book><CODE>31 	err_abort (status, "Create thread");</CODE> </p>
<p class=book><CODE>32</CODE></p>
<p class=book><CODE>33 /*</CODE></p>
<p class=book><CODE>34 * Give the thread a chance to get started if it's going to run</CODE></p>
<p class=book><CODE>35 * in parallel, but not enough that the current thread is likely</CODE></p>
<p class=book><CODE>36 * to be timesliced. (This is a tricky balance, and the loop may</CODE></p>
<p class=book><CODE>37 * need to be adjusted on your system before you can see the bug.)</CODE></p>
<p class=book><CODE>38 */</CODE></p>
<p class=book><CODE>39 for (i = 0; i &lt; 10000000; i++);</CODE> </p>
<p class=book><CODE>40</CODE></p>
<p class=book><CODE>41 string_ptr = "After value";</CODE></p>
<p class=book><CODE>42 status = pthread_join (printer_id, NULL);</CODE></p>
<p class=book><CODE>43 if (status != 0)</CODE></p>
<p class=book><CODE>44 	err_abort (status, "Join thread");</CODE></p>
<p class=book><CODE>45 return 0;</CODE></p>
<p class=book><CODE>46 }</CODE></p>
<p class=book>The way to fix inertia.c is to set the "After value," the one you want the threads to see, before creating the thread. That's not so hard, is it? There may still be a "Before value," whether it is uninitialized storage or a value that was previously used for some other purpose, but the thread you create can't see it. By the memory visibility rules given in Section 3.4, the new thread sees all memory writes that occurred prior to the call into pthread_create. Always design your code so that threads aren't started until after all the resources they need have been created and initialized exactly the way you want the thread to see them.</p>
<p class=book>Never assume that a thread you create will wait for you.</p>
<p class=book>You can cause yourself as many problems by assuming a thread will run "soon" as by assuming it won't run "too soon." Creating a thread that relies on "temporary storage" in the creator thread is almost always a bad idea. I have seen code that creates a series of threads, passing a pointer to the same local structure to each, changing the structure member values each time. The problem is that you can't assume threads will start in any specific order. All of those threads may start after your last creation call, in which case they all get the last value of the data. Or the threads might start a little bit out of order, so that the first and second thread get the same data, but the others get what you intended them to get.</p>
<p class=book>Thread inertia is a special case of thread races. Although thread races are covered much more extensively in Section 8.1.2, thread inertia is a subtle effect, and many people do not recognize it as a race. So test your code thoroughly on a multiprocessor, if at all possible. Do this as early as possible during development, and continuously throughout development. Do this despite the fact that, especially without a perfect threaded debugger, testing on a multiprocessor will be more difficult than debugging on a uniprocessor. And, of course, you should carefully read the following section.</p>


<a name=t125></a><h3 class=book>
8.1.2 Never bet your mortgage on a thread race
</h3>
<p class=book>A race occurs when two or more threads try to get someplace or do something at the same time. Only one can win. Which thread wins is determined by a lot of factors, not all of which are under your control. The outcome may be affected by how many processors are on the system, how many other processes are running, how much network overhead the system is handling, and other things like that. That's a nondeterministic race. It probably won't come out the same if you run the same program twice in a row. You don't want to bet on races like that.<sup><a name=r9><a href="#n9" title="
My daughter had this figured out by the time she was three — when she wanted to race, she told me ahead of time whether my job was to win or lose. There's really no point to leaving these important things to chance!
">[9]</sup></A></p>
<p class=book>When you write threaded code,assume that at any arbitrary point, within any statement of your program,each thread may go to sleep for an unbounded period of time.</p>
<p class=book>Processors may execute your threads at differing rates, depending on processor load, interrupts, and so forth. Timeslicing on a processor may interrupt a thread at any point for an unspecified duration. During the time that a thread isn't running, any other thread may run and do anything that synchronization protocols in your code don't specifically prevent it from doing, which means that between any two instructions a thread may find an entirely different picture of memory, with an entirely different set of threads active. The way to protect a thread's view of the world from surprises is to rely only on explicit synchronization between threads.</p>
<p class=book>Most synchronization problems will probably show up pretty quickly if you're debugging on a multiprocessor. Threads with insufficient synchronization will compete for the honor of reaching memory last. It is a minor irony of thread races that the "loser" generally wins because the memory system will keep the last value written to an address. Sometimes, you won't notice a race at all. But sometimes you'll get a mystifying wrong result, and sometimes you'll get a segmentation fault.</p>
<p class=book>Races are usually difficult to diagnose. The problem often won't occur at all on a uniprocessor system because races require concurrent execution. The level of concurrency on a uniprocessor, even with timeslicing, is fairly low, and often an unsynchronized sequence of writes will complete before another thread gets a chance to read the inconsistent data. Even on a multiprocessor, races may be difficult to reproduce, and they often refuse to reveal themselves to a debugger. Races depend on the relative timing of thread execution — something a debugger is likely to change.</p>
<p class=book>Some races have more to do with memory visibility than with synchronization of multiple writes. Remember the basic rules of memory visibility (see Section 3.4): A thread can always see changes to memory that were performed by a thread previously running on the same processor. On a uniprocessor all threads run on the same processor, which makes it difficult to detect memory visibility problems during debugging. On a multiprocessor, you may see visibility races only when the threads are scheduled on different processors while executing specific vulnerable sections of code.</p>
<p class=book>No ordering exists between threads unless you cause ordering.</p>
<p class=book>Bill Gallmeister's corollary:</p>
<p class=book>"Threads will run in the most evil order possible."</p>
<p class=book>You don't want to find yourself debugging thread races. You may never see the same outcome twice. The symptoms will change when you try to debug the code— possibly by masquerading as an entirely different kind of problem, not just as the same problem in a different place. Even worse, the problem may never occur at all until a customer runs the code, and then it may fail every time, but only in the customer's immense, monolithic application, and only after it has been running</p>
<p class=book>for days. It will be running on a secured system with no network access, they will be unable to show you the proprietary code, and will be unable to reproduce the problem with a simple test program.</p>
<p class=book>"Scheduling" is not the same as "synchronization."</p>
<p class=book>It may appear at first that setting a thread to the SCHED_FIFO scheduling policy and maximum priority would allow you to avoid using expensive synchronization mechanisms by guaranteeing that no other thread can run until the thread blocks itself or lowers its priority. There are several problems with this, but the main problem is that it won't work on a multiprocessor. The SCHED_FIFO policy prevents preemption by another thread, but on a multiprocessor other threads can run without any form of preemption.</p>
<p class=book>Scheduling exists to tell the system how important a specific job (thread) is to your application so it can schedule the job you need the most. Synchronization exists to tell the system that no other thread can be allowed into the critical section until the calling thread is done.</p>
<p class=book>In real life, a deterministic race, where the winner is guaranteed from the beginning, isn't very exciting (except to a three year old). But a deterministic race represents a substantially safer bet, and that's the kind of race you want to design into your programs. A deterministic race, as you can guess, isn't much of a race at all. It is more like waiting in line — nice, organized, and predictable. Excitement is overrated, especially when it comes to debugging complicated threaded applications.</p>
<p class=book>The simplest form of race is when more than one thread tries to write shared state without proper synchronization, for example, when two threads increment a shared counter. The two threads may fetch the same value from memory, increment it independently, and store the same result into memory; the counter has been incremented by one rather than by two, and both threads have the same result value.</p>
<p class=book>A slightly more subtle race occurs when one thread is writing some set of shared data while another thread reads that data. If the reads occur in a different order, or if the reader catches up to the writer, then the reader may get inconsistent results. For example, one thread increments a shared array index and then writes data into the array element at that index. Another thread fetches the shared index before the writer has filled in the entire element and reads that element. The reader finds inconsistent data because the element hasn't been completely set up yet. It may take an unexpected code path because of something it sees there or it may follow a bad pointer.</p>
<p class=book>Always design and code assuming that threads are more asynchronous than you can imagine. Anyone who's written a lot of code knows that computers have little creatures that enjoy annoying you. Remember that when you code with threads there are lots of them loose at the same time. Take no chances, make no assumptions. Make sure any shared state is set up and visible before creating the thread that will use it; or create it using static mutexes or pthread_once. Use a</p>
<p class=book>mutex to ensure that threads can't read inconsistent data. If you must share stack data between threads, be sure all threads that use the data have terminated before returning from the function that allocated the storage.</p>
<p class=book>"Sequence races" may occur when you assume some ordering of events, but that ordering isn't coded into the application. Sequence races can occur even when you carefully apply synchronization control to ensure data consistency. You can only avoid this kind of race by ensuring that ordering isn't important, or by adding code that forces everything to happen in the order it needs to happen.</p>
<p class=book>For example, imagine that three threads share a counter variable. Each will store a private copy of the current value and increment the shared counter. If the three threads are performing the same function, and none of them cares which value of the counter they get, then it is enough to lock a mutex around the fetch and increment operation. The mutex guarantees that each thread gets a distinct value, and no values are skipped. There's no race because none of the threads cares who wins.</p>
<p class=book>But if it matters which value each thread receives, that simple code will not do the job. For example, you might imagine that threads are guaranteed to start in the order in which they are created, so that the first thread gets the value 1, the second gets the value 2, and so forth. Once in a while (probably while you're debugging), the threads will get the value you expect, and everything will work, and at other times, the threads will happen to run in a different order.</p>
<p class=book>There are several ways to solve this. For example, you could assign each of the threads the proper value to begin with, by incrementing the counter in the thread that creates them and passing the appropriate value to each thread in a data structure. The best solution, though, is to avoid the problem by designing the code so that startup order doesn't matter. The more symmetrical your threads are, and the fewer assumptions they make about their environment, the less chance that this kind of race will happen.</p>
<p class=book>Races aren't always way down there at the level of memory address references, though. They can be anywhere. The traditional ANSI C library, for example, allows a number of sequence races when you use certain functions in an application with multiple threads. The readdir function, for example, relies on static storage within the function to maintain context across a series of identical calls to readdir. If one thread calls readdir while another thread is in the middle of a sequence of its own calls to readdir, the static storage will be overwritten with a new context.</p>
<p class=book>"Sequence races" can occur even when all your code uses mutexes to protect shared data!</p>
<p class=book>This race occurs even if readdir is "thread aware" and locks a mutex to protect the static storage. It is not a synchronization race, it is a sequence race. Thread A might call readdir to scan directory /usr/bin, for example, which locks the mutex, returns the first entry, and then unlocks the mutex. Thread B might then call readdir to scan directory /usr/include, which also locks the mutex,</p>
<p class=book>returns the first entry, and then unlocks the mutex. Now thread A calls readdir again expecting the second entry in /usr/bin; but instead it gets the second entry in /usr/include. No interface has behaved improperly, but the end result is wrong. The interface to readdir simply is not appropriate for use by threads.</p>
<p class=book>That's why Pthreads specifies a set of new <i>reentrant</i> functions, including readdir_r, which has an additional argument that is used to maintain context across calls. The additional argument solves the sequence race by avoiding any need for shared data. The call to readdir_r in thread A returns the first entry from /usr/bin in thread A's buffer, and the call to readdir_r in thread B returns the first entry from /usr/include in thread B's buffer . . . and the second call in thread A returns the second entry from /usr/bin in thread A's buffer. Refer to pipe.c, in Section 4.1, for a program that uses readdir_r.</p>
<p class=book>Sequence races can also be found at higher levels of coding. File descriptors in a process, for example, are shared across all threads. If two threads attempt to getc from the same file, each character in the file can go to only one thread. Even though getc itself is thread-safe, the sequence of characters seen by each thread is not deterministic — it depends on the ordering of each thread's independent calls to getc. They may alternate, each getting every second character throughout the file. Or one may get 2 or 100 characters in a row and then the other might get 1 character before being preempted for some reason.</p>
<p class=book>There are a number of ways you can resolve the getc race. You can open the file under two separate file descriptors and assign one to each thread. In that way, each thread sees every character, in order. That solves the race by removing the dependency on ordering. Or you can lock the file across the entire sequence of gets operations in each thread, which solves the race by enforcing the desired order. The program putchar.c, back in Section 6.4.2, shows a similar situation.</p>
<p class=book>Usually a program that doesn't <i>care</i> about ordering will run more efficiently than a program that enforces some particular ordering, first, because enforcing the ordering will always introduce computational overhead that's not directly related to getting the job done. Remember Amdahl's law. "Unordered" programs are more efficient because the greatest power of threaded programming is that things can happen concurrently, and synchronization prevents concurrency. Running an application on a multiprocessor system doesn't help much if most processors spend their time waiting for one to finish something.</p>


<a name=t126></a><h3 class=book>
8.1.3 Cooperate to avoid deadlocks
</h3>
<p class=book>Like races, deadlocks are the result of synchronization problems in a program. While races are resource conflicts caused by insufficient synchronization, deadlocks are usually conflicts in the use of synchronization. A deadlock can happen when any two threads share resources. Essentially a deadlock occurs when thread A has resource 1 and can't continue until it has resource 2, while thread B has resource 2 and can't continue until it has resource 1.</p>
<p class=book>The most common type of deadlock in a Pthreads program is <i>mutex deadlock,</i> where both resources are mutexes. There is one really important advantage of a deadlock over a race: It is much easier to debug the problem. In a race, the threads do something incorrectly and move on. The problem shows up sometime later, usually as a side effect. But in a deadlock the threads are still there waiting, and always will be — if they could go anywhere, it wouldn't be a deadlock. So when you attach to the process with the debugger or look at a crash dump, you can see what resources are involved. With a little detective work you can often determine why it happened.</p>
<p class=book>The most likely cause is a resource ordering inconsistency. The study of deadlocks goes way back to the early days of operating system design. Anyone who's taken computer science courses has probably run into the classic <i>dining philosophers</i> problem. Some philosophers sit at a round table with plates of spaghetti; each alternately eats and discusses philosophy. Although no utensils are required to discuss philosophy, each philosopher requires two forks to eat. The table is set with a single fork between each pair. The philosophers need to synchronize their eating and discussion to prevent deadlock. The most obvious form of deadlock is when all philosophers simultaneously pick up one fork each and refuse to put it down.</p>
<p class=book>There's always a way to make sure that your philosophers can all eat, eventually. For example, a philosopher can take the fork to her right, and then look to her left. If the fork is available, she can take it and eat. If not, she should return the fork she's holding to the table and chat awhile. (That is the mutex backoff strategy discussed in Section 3.2.5.1.) Since the philosophers are all in a good mood and none has recently published papers severely critical of adjoining colleagues, those who get to eat will in reasonably short order return both of their forks to the table so that their colleagues on each side can proceed.</p>
<p class=book>A more reliable (and more sanitary) solution is to skip the spaghetti and serve a dish that can be eaten with one fork. Mutex deadlocks can't happen if each thread has only one mutex locked at a time. It is a good idea to avoid calling functions with a mutex locked. First, if that function (or something it calls) locks another mutex, you could end up with a deadlock. Second, it is a good idea to lock mutexes for as short a time as possible (remember, locking a mutex prevents another thread from "eating" — that is, executing—concurrently). Calling printf, though, isn't likely to cause a deadlock in your code, because you don't lock any ANSI C library mutexes, and the ANSI C library doesn't lock any of your mutexes. If the call is into your own code, or if you call a library that may call back into your code, be careful.</p>
<p class=book>If you need to lock more than one mutex at a time, avoid deadlocks by using a strict hierarchy or a backoff algorithm. The main disadvantage of mutex backoff is that the backoff loop can run a long time if there are lots of other threads locking the mutexes, even if they do so without any possibility of a deadlock. The backoff algorithm assumes that other threads may lock the first mutex after having locked one or more of the other mutexes. If all threads always lock mutexes in the order they're locked by the backoff loop, then you've got a fixed locking hierarchy and you don't need the backoff algorithm.</p>
<p class=book>When a program has hung because of a deadlock, you require two important capabilities of your threaded debugger. First, it allows you to run your program in a mode where mutex ownership is recorded, and may be displayed using debugger commands. Finding a thread that is blocked on some mutex while it owns other mutexes is a good indication that you may have a deadlock. Second, you would like to be able to examine the call stack of threads that own mutexes to determine why the mutexes have remained locked.</p>
<p class=book>The call stack may not always be sufficient, though. One common cause of a deadlock is that some thread has returned from a function without unlocking a mutex. In this case, you may need a more sophisticated tool to trace the synchronization behavior of the program. Such a tool would allow you to examine the data and determine, for example, that function bad_lock locked a mutex and failed to unlock that mutex.</p>


<a name=t127></a><h3 class=book>
8.1.4 Beware of priority inversion
</h3>
<p class=book>"Priority inversion" is a problem unique to applications (or libraries) that rely on realtime priority scheduling. Priority inversion involves at least three threads of differing priority. The differing priorities are important — priority inversion is a conflict between synchronization and scheduling requirements. Priority inversion allows a low-priority thread to indefinitely prevent a higher-priority thread from running. The result usually is not a deadlock (though it can be), but it is always a severe problem. See Section 5.5.4 for more about priority inversion.</p>
<p class=book>Most commonly, a priority inversion results from three threads of differing priority sharing resources. One example of a priority inversion is when a low-priority thread locks a mutex, and is preempted by a high-priority thread, which then blocks on the mutex currently locked by the low-priority thread. Normally, the low-priority thread would resume, allowing it to unlock the mutex, which would unblock the high-priority thread to continue. However, if a medium-priority thread was awakened (possibly by some action of the high-priority thread), it might prevent the lower-priority thread from running. The medium-priority thread (or other threads it awakens) may indefinitely prevent the low-priority thread from releasing the mutex, so a high-priority thread is blocked by the action of a lower-priority thread.</p>
<p class=book>If the medium-priority thread blocks, the low-priority thread will be allowed to resume and release the mutex, at which point operation resumes. Because of this, many priority inversion deadlocks resolve themselves after a short time. If all priority inversion problems in a program reliably resolve themselves within a short time, the priority inversion may become a performance issue rather than a correctness issue. In either case, priority inversion can be a severe problem.</p>
<p class=book>Here are a few ideas to avoid priority inversion:</p>
<p class=book>• Avoid realtime scheduling entirely. That clearly is not practical in many realtime applications, however.</p>
<p class=book>• Design your threads so that threads of differing priority do not need to use the same mutexes. This may be impractical, too; many ANSI C functions, for example, use mutexes.</p>
<p class=book>• Use priority ceiling mutexes (Section 5.5.5.1) or priority inheritance (Section 5.5.5.2). These are optional features of Pthreads and will not be available everywhere. Also, you cannot set the mutex priority protocol for mutexes you do not create, including those used by ANSI C functions.</p>
<p class=book>• Avoid calling functions that may lock mutexes you didn't create in any thread with elevated priority.</p>


<a name=t128></a><h3 class=book>
8.1.5 Never share condition variables between predicates
</h3>
<p class=book>Your code will usually be cleaner and more efficient if you avoid using a single condition variable to manage more than one predicate condition. You should not, for example, define a single "queue" condition variable that is used to awaken threads waiting for the queue to become empty and also threads waiting for an element to be added to the queue.</p>
<p class=book>But this isn't just a performance issue (or it would be in another section). If you use pthread_cond_signal to wake threads waiting on these shared condition variables, the program may hang with threads waiting on the condition variable and nobody left to wake them up.</p>
<p class=book>Why? Because you can only <i>signal</i> a condition variable when you know that a single thread needs to be awakened, and that any thread waiting on the condition variable may be chosen. When multiple predicates share a condition variable, you can never be sure that the awakened thread was waiting for the predicate you set. If it was not, then it will see a <i>spurious wakeup</i> and wait again. Your signal has been lost, because no thread waiting for your predicate had a chance to see that it had changed.</p>
<p class=book>It is not enough for a thread to resignal the condition variable when it gets a spurious wakeup, either. Threads may not wake up in the order they waited, especially when you use priority scheduling. "Resignaling" might result in an infinite loop with a few high-priority threads (all with the wrong predicate) alternately waking each other up.</p>
<p class=book>The best solution, when you really want to share a condition variable between predicates, is always to use pthread_cond_broadcast. But when you broadcast, all waiting threads wake up to reevaluate their predicates. You always know that one set or the other cannot proceed — so why make them all wake up to find out? If 1 thread is waiting for write access, for example, and 100 are waiting for read access, all 101 threads must wake up when the broadcast means that it is now OK to write, but only the one writer can proceed — the other 100 threads must wait again. The result of this imprecision is a lot of wasted context switches, and there are more useful ways to keep your computer busy.</p>


<a name=t129></a><h3 class=book>
8.1.6 Sharing stacks and related memory corrupters
</h3>
<p class=book>There's nothing wrong with sharing stack memory between threads. That is, it is legal and sometimes reasonable for a thread to allocate some variable on its own stack and communicate that address to one or more other threads. A correctly written program can share stack addresses with no risk at all; however (this may come as a surprise), not every program is written correctly, even when you want it to be correct. Sharing stack addresses can make small programming errors catastrophic, and these errors can be very difficult to isolate.</p>
<p class=book>Returning from the function that allocates shared stack memory,when other threads may still use that data,will result in undesirable behavior.</p>
<p class=book>If you share stack memory, you must ensure that it is never possible for the thread that owns the stack to "pop" that shared memory from the stack until all other threads have forever ceased to make use of the shared data. Should the owning thread return from a stack frame containing the data, for example, the owning thread may call another function and thereby reallocate the space occupied by the shared variable. One or both of the following possible outcomes will eventually be observed:</p>
<p class=book>1. Data written by another thread will be overwritten with saved register values, a return PC, or whatever. The shared data has been corrupted.</p>
<p class=book>2. Saved register values, return PC, or whatever will be overwritten by another thread modifying the shared data. The owning thread's call frame has been corrupted.</p>
<p class=book>Having carefully ensured that there is no possible way for the owning thread to pop the stack data while other threads are using the shared data, are you safe? Maybe not. We're stretching the point a little, but remember, we're talking about a programming error — maybe a silly thing like failing to initialize a pointer variable declared with auto storage class, for example. A pointer to the shared data must be stored somewhere to be useful—other threads have no other way to find the proper stack address. At some point, the pointer is likely to appear in various locations on the stack of every thread that uses the data. None of these pointers will necessarily be erased when the thread ceases to make use of the stack.</p>
<p class=book>Writes through uninitialized pointers are a common programming error, regardless of threads, so to some extent this is nothing new or different. However, in the presence of threads and shared stack data, each thread has an opportunity to corrupt data used by some other thread asynchronously. The symptoms of that corruption may not appear until some time later, which can pose a particularly difficult debugging task.</p>
<p class=book>If, in your program, sharing stack data seems convenient, then by all means take advantage of the capability. But if something unexpected happens during debugging, start by examining the code that shares stack data particularly carefully. If you routinely use an analysis tool that reports use of uninitialized variables (such as Third Degree on Digital UNIX), you may not need to worry about this class of problem — or many others.</p>



<a name=t130></a><h3 class=book>
8.2 Avoiding performance problems
</h3>
<blockquote class="epigraph">
<p class=book><i><b>"Well, in</b></i> <b>our</b> <i><b>country," said Alice, still panting a little, "you'd generally get to somewhere else — if you ran very fast for a long time as we've been doing."</b></i></p>
<p class=book><i><b>"A slow sort of country!" said the Queen. "Now,</b></i> <b>here,</b> <i><b>you see, it takes all the running</b></i> <b>you</b> <i><b>can do, to keep in the same place. If you want to get somewhere else, you must run at least twice as fast as that!"</b></i></p>
<blockquote class=book><i>— <i>Lewis Carroll, Through the Looking-Glass</i></i></blockquote>
</blockquote>

<p class=book>Sometimes, once a program works, it is "done." At least, until you want to make it do something else. In many cases, though, "working" isn't good enough. The program needs to meet performance goals. Sometimes the performance goals are clear: "must perform so many transactions in this period of time." Other times, the goals are looser: "must be very fast."</p>
<p class=book>This section gives pointers on determining how fast you're going, what's slowing you up, and how to tell (maybe) when you're going as fast as you can go. There are some very good tools to help you, and there will be a lot more as the industry adjusts to supporting eager and outspoken thread programmers. But there are no portable standards for threaded analysis tools. If your vendor supports threads, you'll probably find at least a thread-safe version of prof, which is a nearly universal UNIX tool. Each system will probably require different switches and environments to use it safely for threads, and the output will differ.</p>
<p class=book>Performance tuning requires more than just answering the traditional question, "How much time does the application spend in each function?" You have to analyze contention on mutexes, for example. Mutexes with high contention may need to be split into several mutexes controlling more specialized data (finer-grain concurrency), which can improve performance by increasing concurrency. If finer grain mutexes have low contention, combining them may improve performance by reducing locking overhead.</p>


<a name=t131></a><h3 class=book>
8.2.1 Beware of concurrent serialization
</h3>
<p class=book>The ideal parallel code is a set of tasks that is completely compute-bound. They never synchronize, they never block — they just "think." If you start with a program that calls three compute-bound functions in series, and change it to create three threads each running one of those functions, the program will run (nearly) three times faster. At least, it should do so if you're running on a multiprocessor with at least three CPUs that are, at that moment, allocated for your use.</p>
<p class=book>The ideal concurrent code is a set of tasks that is completely I/O-bound. They never synchronize, and do little computation — they just issue I/O requests and wait for them. If you start with a program that writes chunks of data to three separate files (ideally, on three separate disks, with separate controllers), and change it to create three threads, each writing one of those chunks of data, all three I/O operations can progress simultaneously.</p>
<p class=book>But what if you've gone to all that trouble to write a set of compute-bound parallel or I/O-bound concurrent threads and it turns out that you've just converted a straight-line serialized program into a multithreaded serialized program? The result will be a slower program that accomplishes the same result with substantially more overhead. Most likely, that is not what you intended. How could that have happened?</p>
<p class=book>Let's say that your compute-bound operations call malloc and free in their work. Those functions modify the static process state, so they need to perform some type of synchronization. Most likely, they lock a mutex. If your threads run in a loop calling malloc and free, such that a substantial amount of their total time may be spent within those functions, you may find that there's very little real parallelism. The threads will spend a lot of time blocked on the mutex while one thread or another allocates or frees memory.</p>
<p class=book>Similarly, the concurrent I/O threads may be using serialized resources. If the threads perform "concurrent" I/O using the same <i>stdio</i> <b>FILE</b> stream, for example, they will be locking mutexes to update the stream's shared buffer. Even if the threads are using separate files, if they are on the same disk there will be locking within the file system to synchronize the file cache and so forth. Even when using separate disks, true concurrency may be subject to limitations in the I/O bus or disk controller subsystems.</p>
<p class=book>The point of all this is that writing a program that uses threads doesn't magically grant parallelism or even concurrency to your application. When you're analyzing performance, be aware that your program can be affected by factors that aren't within your control. You may not even be able to see what's happening in the file system, but what you can't see <i>can</i> hurt you.</p>


<a name=t132></a><h3 class=book>
8.2.2 Use the right number of mutexes
</h3>

<p class=book>The first step in making a library thread-safe may be to create a "big mutex" that protects all entries into the library. If only one thread can execute within the library at a time, then most functions will be thread-safe. At least, no static data will be corrupted. If the library has no persistent state that needs to remain consistent across a series of calls, the big mutex may seem to be enough. Many libraries are left in this state. The standard X11 client library (Xlib) provides limited support for this big mutex approach to thread-safety, and has for years.</p>
<p class=book>But thread-safety isn't enough anymore — now you want the library to perform well with threads. In most cases, that will require redesigning the library so that multiple threads can use it at the same time. The big mutex serializes all operations in the library, so you are getting no concurrency or parallelization within the library. If use of that library is the primary function of your threads, the program would run faster with a single thread and no synchronization. That big mutex in Xlib, remember, keeps all other threads from using any Xlib function until the first thread has received its response from the server, and that might take quite a while.</p>
<p class=book>Map out your library functions, and determine what operations can reasonably run in parallel. A common strategy is to create a separate mutex for each data structure, and use those mutexes to serialize access to the shared data, rather than using the "big mutex" to serialize access to the library.</p>
<p class=book>With a profiler that supports threads, you can determine that you have too much mutex activity, by looking for hot spots within calls to pthread_mutex_ lock, pthread_mutex_unlock, and pthread_mutex_trylock. However, this data will not be conclusive, and it may be very difficult to determine whether the high activity is due to too much mutex contention or too much locking without contention. You need more specific information on mutex contention and that requires special tools. Some thread development systems provide detailed visual tracing information that shows synchronization costs. Others provide "metering" information on individual mutexes to tell how many times the mutex was locked, and how often threads found the mutex already locked.</p>


<a name=t133></a><h3 class=book>
8.2.2.1 Too many mutexes will not help
</h3>
<p class=book>Beware, too, of exchanging a "big" mutex for lots of "tiny" mutexes. You may make matters worse. Remember, it takes time to lock a mutex, and more time to unlock that mutex. Even if you increase parallelism by designing a locking hierarchy that has very little contention, your threads may spend so much time locking and unlocking all those mutexes that they get less real work done.</p>
<p class=book>Locking a mutex also affects the memory subsystem. In addition to the time you spend locking and unlocking, you may decrease the efficiency of the memory system by excessive locking. Locking a mutex, for example, might invalidate a block of cache on all processors. It might stall all bus activity within some range of physical addresses.</p>
<p class=book>So find out where you really need mutexes. For example, in the previous section I suggested creating a separate mutex for each data structure. Yet, if two data structures are usually used together, or if one thread will hardly ever need to use one data structure while another thread is using the second data structure, the extra mutex may decrease your overall performance.</p>



<a name=t134></a><h3 class=book>
8.2.3 Never fight over cache lines
</h3>
<p class=book>No modern computer reads data directly from main memory. Memory that is fast enough to keep up with the computer is too expensive for that to be practical. Instead, data is fetched by the memory management unit into a fast local cache array. When the computer writes data, that, too, goes into the local cache array. The modified data may also be written to main memory immediately or may be "flushed" to memory only when needed.</p>
<p class=book>So if one processor in a multiprocessor system needs to read a value that another processor has in its cache, there must be some "cache coherency" mechanism to ensure that it can find the correct data. More importantly, when one processor writes data to some location, all other processors that have older copies of that location in cache need to copy the new data, or record that the old data is invalid.</p>
<p class=book>Computer systems commonly cache data in relatively large blocks of 64 or 128 bytes. That can improve efficiency by optimizing the references to slow main memory. It also means that, when the same 64- or 128-byte block is cached by multiple processors, and one processor writes to any part of that block, all processors caching the block must throw away the entire block.</p>
<p class=book>This has serious implications for high-performance parallel computation. If two threads access different data within the same cache block, no thread will be able to take advantage of the (fast) cached copy on the processor it is using. Each read will require a new cache fill from main memory, slowing down the program.</p>
<p class=book>Cache behavior may vary widely even on different computer systems using the same microprocessor chip. It is not possible to write code that is guaranteed to be optimal on all possible systems. You can substantially improve your chances, however, by being very careful to align and separate any performance-critical data used by multiple threads.</p>
<p class=book>You can optimize your code for a particular computer system by determining the cache characteristics of that system, and designing your code so that no two threads will ever need to write to the same cache block within performance-critical parallel loops. About the best you can hope to do without optimizing for a particular system would be to ensure that each thread has a private, page-aligned, segment of data. It is highly unlikely that any system would use a cache block as large as a page, because a page includes far too much varied data to provide any performance advantage in the memory management unit.</p>




<a name=t135></a><h3 class=book>
9 POSIX threads mini-reference
</h3>

<p class=book>This chapter is a compact reference to the POSIX.1c standard.</p>


<a name=t136></a><h3 class=book>
9.1 POSIX1003.1c-1995 options
</h3>
<p class=book>Pthreads is intended to address a wide variety of audiences. High-performance computational programs can use it to support parallel decomposition of loops. Realtime programs can use it to support concurrent realtime I/O. Database and network servers can use it to easily support concurrent clients. Business or software development programs can use it to take advantage of parallel and concurrent operations on time-sharing systems.</p>
<p class=book>The Pthreads standard allows you to determine which optional capabilities are provided by the system, by defining a set of feature-test macros, which are shown in Table 9.1. Any implementation of Pthreads must inform you whether each option is supported, by three means:</p>
<p class=book>• By making a formal statement of support in the POSIX Conformance Document. You can use this information to help design your application to work on specific systems.</p>
<p class=book>• By defining compile-time symbolic constants in the &lt;unistd.h&gt; header file. You can test for these symbolic constants using #ifdef or #ifndef preprocessor conditionals to support a variety of Pthreads systems.</p>
<p class=book>• By returning a positive nonzero value when the sysconf function is called with the associated sysconf symbol. (This is not usually useful for the "feature-test" macros that specify whether options are present — if they are not, the associated interfaces usually are not supplied, and your code will not link, and may not even compile.)</p>
<p class=book>You might, for example, choose to avoid relying on priority scheduling because after reading the conformance documents you discovered that three out of the four systems you wish to support do not provide the feature. Or you might prefer to use priority inheritance for your mutexes on systems that provide the feature, but write the code so that it will not try to access the mutex <i>protocol</i> attribute on systems that do not provide that option.</p>
<TABLE>
<TR>
<TD align = "left" ><b>Symbolic constant,</b></TD>
<TD align = "left" ><b>Description</b></TD>
</TR>
<TR>
<TD align = "left" ><b>sysconf symbol name</b></TD>
<TD></TD>
</TR>
<TR>
<TD align = "left" >_POSIX_THREADS _SC_THREADS</TD>
<TD align = "left" >You can use threads (if your system doesn't define this, you're out of luck).</TD>
</TR>
<TR>
<TD align = "left" >_POSIX_THREAD_ATTR_STACKSIZE _SC_THREAD_ATTR_STACKSIZE</TD>
<TD align = "left" >You can control the size of a thread's stack.</TD>
</TR>
<TR>
<TD align = "left" >_POSIX_THREAD_ATTR_STACKADDR _SC_THREAD_ATTR_STACKADDR</TD>
<TD align = "left" >You can allocate and control a thread's stack.</TD>
</TR>
<TR>
<TD align = "left" >_POSIX_THREAD_PRIORITY_SCHEDULING _SC_THREAD_PRIORITY_SCHEDULING</TD>
<TD align = "left" >You can use realtime scheduling.</TD>
</TR>
<TR>
<TD align = "left" >_POSIX_THREAD_PRIO_INHERIT _SC_THREAD_PRIO_INHERIT</TD>
<TD align = "left" >You can create priority inheritance mutexes.</TD>
</TR>
<TR>
<TD align = "left" >_POSIX_THREAD_PRIO_PROTECT _SC_THREAD_PRIO_PROTECT</TD>
<TD align = "left" >You can create priority ceiling mutexes.</TD>
</TR>
<TR>
<TD align = "left" >_POSIX_THREAD_PROCESS_SHARED _SC_THREAD_PROCESS_SHARED</TD>
<TD align = "left" >You can create mutexes and condition variables that can be shared with another process.</TD>
</TR>
<TR>
<TD align = "left" >_POSIX_THREAD_SAFE_FUNCTIONS _SC_THREAD_SAFE_FUNCTIONS</TD>
<TD align = "left" >You can use the special "_r" library functions that provide thread-safe behavior.</TD>
</TR>
</TABLE>
<p class=book><b>TABLE 9.1</b> <i>POSIX 1003.1c-1995 options</i></p>


<a name=t137></a><h3 class=book>
9.2 POSIX1003.1c-1995 limits
</h3>
<p class=book>The Pthreads standard allows you to determine the run-time limits of the system that may affect your application, for example, how many threads you can create, by defining a set of macros, which are shown in Table 9.2. Any implementation of Pthreads must inform you of its limits, by three means:</p>
<p class=book>• By making a formal statement in the POSIX Conformance Document. You can use this information to help design your application to work on specific systems.</p>
<p class=book>• By defining compile-time symbolic constants in the &lt;limits.h&gt; header file. The symbolic constant may be omitted from &lt;limits.h&gt; when the limit is at least as large as the required minimum, but cannot be determined at compile time, for example, if it depends on available memory space. You can test for these symbolic constants using #ifdef or #ifndef preprocessor conditionals.</p>
<p class=book>• By returning a positive nonzero value when the sysconf function is called with the associated sysconf symbol.</p>
<p class=book>You might, for example, design your application to rely on no more than 64 threads, if the conformance documents showed that three out of the four systems</p>
<TABLE>
<TR>
<TD align = "left" ><b>Run-time invariant values,</b></TD>
<TD align = "left" > <b>Description</b></TD>
</TR>
<TR>
<TD align = "left" ><b>sysconf symbol name</b></TD>
<TD></TD>
</TR>
<TR>
<TD align = "left" >PTHREAD_DESTRUCTOR_ITERATIONS _SC_THREAD_DESTRUCTOR_ITERATIONS</TD>
<TD align = "left" >Maximum number of attempts to destroy a thread's thread-specific data on termination (must be at least 4).</TD>
</TR>
<TR>
<TD align = "left" >PTHREAD_KEYS_MAX _SC_THREAD_KEYS_MAX</TD>
<TD align = "left" >Maximum number of thread-specific data keys available per process (must be at least 128).</TD>
</TR>
<TR>
<TD align = "left" >PTHREAD_STACK_MIN _SC_THREAD_STACK_MIN</TD>
<TD align = "left" >Minimum supported stack size for a thread.</TD>
</TR>
<TR>
<TD align = "left" >PTHREAD_THREADS_MAX _SC_THREAD_THREADS_MAX</TD>
<TD align = "left" >Maximum number of threads supported per process (must be at least 64).</TD>
</TR>
<TR>
<TD align = "left"  colspan = "2" ><b>TABLE 9.2</b> <i>POSIX 1003.1 c-1995 limits</i></TD>
</TR>
</TABLE>
<p class=book>you wish to support do not support additional threads. Or you might prefer to write conditional code that relies on the value of the PTHREAD_THREADS_MAX symbolic constant (if defined) or call sysconf to determine the limit at run time.</p>


<a name=t138></a><h3 class=book>
9.3 POSIX1003.1c-1995 interfaces
</h3>

<p class=book>The interfaces are sorted by functional categories: threads, mutexes, and so forth. Within each category, the interfaces are listed in alphabetical order. Figure 9.1 describes the format of the entries.</p>
<p class=book>First, the <i>header</i> entry (1) shows the name of the interface. If the interface is an optional feature of Pthreads, then the name of the feature-test macro for that</p>
<img border=0 style='spacing 9px;' src="img_24.png">
<p class=book><b>FIGURE9.1</b> <i>Mini-reference format</i></p>
<br>
<p class=book>option is shown at the end of the line, in brackets. The interface pthread_ mutexattr_getpshared, for example, is an option under the _POSIX_THREAD_ PROCESS_SHARED feature.</p>
<p class=book>The <i>prototype</i> entry (2) shows the full C language prototype for the interface, describing how to call the function, with all argument types.</p>
<p class=book>The <i>description</i> entry (3) gives a brief synopsis of the interface. In this case, the purpose of the interface is to specify whether mutexes created using the attributes object can be shared between multiple processes.</p>
<p class=book>Functions with arguments that have symbolic values, like pshared in this example, will include a table (4) that describes each possible value. The default value of the argument (the state of a new thread, or the default value of an attribute in a new attributes object, in this case PTHREAD_PROCESS_PRIVATE) is indicated by showing the name in bold.</p>
<p class=book>The <i>references</i> entry (5) gives cross-references to the primary sections of this book that discuss the interface, or other closely related interfaces.</p>
<p class=book>The <i>headers</i> entry (6) shows the header files needed to compile code using the function. If more than one header is shown, you need all of them.</p>
<p class=book>The <i>errors</i> entry (7) describes each of the possible error numbers returned by the interface; Because Pthreads distinguishes between mandatory error detection ("if occurs" in POSIX terms) and optional error detection ("if detected" in POSIX terms), the errors that an interface must report (if they occur) are shown in bold (see Section 9.3.1 for details on Pthreads errors).</p>
<p class=book>The <i>hint</i> entry (8) gives a single, and inevitably oversimplified, philosophical comment regarding the interface. Some hints point out common errors in using the interface; others describe something about the designers' intended use of the interface, or some fundamental restriction of the interface. In pthread_mutexattr_ getpshared, for example, the hint points out that a mutex created to be "process shared" must be allocated in shared memory that's accessible by all participating processes.</p>


<a name=t139></a><h3 class=book>
9.3.1 Error detection and reporting
</h3>
<p class=book>The POSIX standard distinguishes carefully between two categories of error:</p>
<p class=book>1. Mandatory ("if occurs") errors involve circumstances beyond the control of the programmer. These errors must always be detected and reported by the system using a particular error code. If you cannot create a new thread because your process lacks sufficient virtual memory, then the implementation must always tell you. You can't possibly be expected to check whether there's enough memory before creating the thread—for one thing, you have no way to know how much memory would be required.</p>
<p class=book>2. Optional ("if detected") errors are problems that are usually your mistake. You might try to lock a mutex that hadn't been initialized, for example, or try to unlock a mutex that's locked by another thread. Some systems may</p>
<p class=book>not detect these errors, but they're still errors in your code, and you ought to be able to avoid them without help from the system.</p>
<p class=book>While it would be "nice" for the system to detect optional errors and return the appropriate error number, sometimes it takes a lot of time to check or is difficult to check reliably. It may be expensive, for example, for the system to determine the identity of the current thread. Systems may therefore not remember which thread locked a mutex, and would be unable to detect that the unlock was erroneous. It may not make sense to slow down the basic synchronization operations for correct programs just to make it a little easier to debug incorrect programs.</p>
<p class=book>Systems may provide debugging modes where some or all of the optional errors are detected. Digital UNIX, for example, provides "error check" mutexes and a "metered" execution mode, where the ownership of mutexes is always tracked and optional errors in locking and unlocking mutexes are reported. The UNLX98 specification includes "error check" mutexes (Section 10.1.2), so they will soon be available on most UNIX systems.</p>


<a name=t140></a><h3 class=book>
9.3.2 Use of void* type
</h3>
<p class=book>ANSI C requires that you be allowed to convert any pointer type to void* and back, with the result being identical to the original value. However, ANSI C does not require that all pointer types have the same binary representation. Thus, a long* that you convert to void* in order to pass into a thread's start routine must always be used as a long*, not as, for example, a char*. In addition, the result of converting between pointer and integer types is "implementation defined." Most systems supporting UNIX will allow you to cast an integer value to void* and back, and to mix pointer types — but be aware that the code may not work on all systems.</p>
<p class=book>Some other standards, notably the POSIX. lb realtime standard, have solved the same problem (the need for an argument or structure member that can take any type value) in different ways. The sigevent structure in POSIX.1b, for example, includes a member that contains a value to be passed into a signal-catching function, called sigev_value. Instead of defining sigev_value as a void*, however, and relying on the programmer to provide proper type casting, the sigev_ value member is a union sigval, containing overlayed int and void* members. This mechanism avoids the problem of converting between integer and pointer types, eliminating one of the conflicts with ANSI C guarantees.</p>


<a name=t141></a><h3 class=book>
9.3.3 Threads
</h3>
<p class=book>Threads provide <i>concurrency,</i> the ability to have more than one "stream of execution" within a process at the same time. Each thread has its own hardware registers and stack. All threads in a process share the full virtual address space, plus all file descriptors, signal actions, and other process resources.</p>
<p class=book><b>pthread_attr_destroy</b></p>
<p class=book>int pthread_attr_destroy (</p>
<p class=book>pthread_attr_t *attr);</p>
<p class=book>Destroy a thread attributes object. The object can no longer be used.</p>
<p class=book>References: 2, 5.2.3</p>
<p class=book>Headers: &lt;pthread.h&gt;</p>
<p class=book>Errors: [EINVAL]attr is invalid.</p>
<p class=book>Hint: Does not affect threads created using attr.</p>
<p class=book><b>pthread_attr_getdetachstate</b></p>
<p class=book>int pthread_attr_getdetachstate (</p>
<p class=book>const pthread_attr_t *attr, int *detachstate);</p>
<p class=book>Determine whether threads created with attr will run detached</p>
<p class=book><b>detachstate</b></p>
<p class=book><b>PTHREAD CREATE JOINABLE</b></p>
<p class=book>PTHREAD CREATE DETACHED</p>
<p class=book>Thread ID is valid, must be joined.</p>
<p class=book>Thread ID is invalid, cannot be joined, canceled, or modified.</p>
<p class=book>References: 2, 5.2.3</p>
<p class=book>Headers: &lt;pthread.h&gt;</p>
<p class=book>Errors: [EINVAL] attr is invalid.</p>
<p class=book>Hint: You can't join or cancel detached threads.</p>
<p class=book><b>pthread_attr_getstackaddr.....................................................[_POSIX_THREAD_ATTR_STACKADDR</b>]</p>
<p class=book>int pthread_attr_getstackaddr (</p>
<p class=book>const pthread_attr_t *attr,</p>
<p class=book>void **stackaddr);</p>
<p class=book>Determine the address of the stack on which threads created with attr will run.</p>
<p class=book>References: 2, 5.2.3</p>
<p class=book>Headers: &lt;pthread.h&gt;</p>
<p class=book>Errors: [EINVAL]attrisinvalid.</p>
<p class=book><b>[ENOSYS]</b> stacksize not supported. Hint: Create only one thread for each stack address!</p>
<p class=book><b>pthread_attr_getstacksize.......................................................[_POSIX_THREAD_ATTR_STACKSIZE</b>]</p>
<p class=book>int pthread_attr_getstacksize (</p>
<p class=book>const pthread_attr_t *attr, size_t *stacksize);</p>
<p class=book>Determine the size of the stack on which threads created with attr will run.</p>
<p class=book>References: 2, 5.2.3</p>
<p class=book>Headers: &lt;pthread.h&gt;</p>
<p class=book>Errors: [EINVAL]attrinvalid.</p>
<p class=book><b>[ENOSYS]</b> stacksize not supported. Hint: Use on newly created attributes object to find the default stack size.</p>
<p class=book><b>pthread_attr_init</b></p>
<p class=book>int pthread_attr_init (</p>
<p class=book>pthread_attr_t *attr);</p>
<p class=book>Initialize a thread attributes object with default attributes.</p>
<p class=book>References: 2, 5.2.3</p>
<p class=book>Headers: &lt;pthread.h&gt;</p>
<p class=book>Errors: <b>[ENOMEM]</b> insufficient memory for attr.</p>
<p class=book>Hint: Use to define thread types.</p>
<p class=book><b>| pthread_aftr_setdetachstate</b></p>
<p class=book>int pthread_attr_setdetachstate ( pthread_attr_t *attr, int detachstate);</p>
<p class=book>Specify whether threads created with attr will run <i>detached.</i></p>
<p class=book><b>detachstate</b></p>
<p class=book><b>PTHREAD CREATE JOINABLE</b></p>
<p class=book>PTHREAD CREATE DETACHED</p>
<p class=book>Thread ID is valid, must be joined.</p>
<p class=book>Thread ID is invalid, cannot be joined, canceled, or modified.</p>
<p class=book>References: 2, 5.2.3</p>
<p class=book>Headers: &lt;pthread.h&gt;</p>
<p class=book>Errors: [EINVAL]attrinvalid.</p>
<p class=book><b>[EINVAL]</b> detachstate invalid. Hint: You can't join or cancel detached threads.</p>
<p class=book><b>pthread_attr_setstackaddr.....................................................[_POSIX_THREAD_ATTR_STACKADDR]</b></p>
<p class=book>int pthread_attr_setstackaddr ( pthread_attr_t *attr, void *stackaddr);</p>
<p class=book>Threads created with attr will run on the stack starting at stackaddr. Must be at least <b>PTHREAD_STACK_MIN</b> bytes.</p>
<p class=book>References: 2, 5.2.3</p>
<p class=book>Headers: &lt;pthread.h&gt;</p>
<p class=book>Errors: <b>[EINVAL</b>]attrinvalid.</p>
<p class=book><b>[ENOSYS]</b> stackaddr not supported. Hint: Create only one thread for each stack address, and be careful of</p>
<p class=book>stack alignment.</p>
<p class=book><b>pthread_attr_setstacksize.......................................................[_POSIX_THREAD_ATTR_STACKSIZE]</b></p>
<p class=book>int pthread_attr_setstacksize ( pthread_attr_t *attr, size_t stacksize);</p>
<p class=book>Threads created with attr will run on a stack of at least stacksize bytes. Must be at least <b>PTHREAD_STACK_MIN</b> bytes.</p>
<p class=book>References: 2, 5.2.3</p>
<p class=book>&lt;pthread.h&gt;</p>
<p class=book><b>[EINVAL]</b> attr or stacksize invalid. <b>[EINVAL]</b> stacksize too small or too big. <b>[ENOSYS]</b> stacksize not supported.</p>
<p class=book>Find the default first (pthread_attr_getstacksize), then increase by multiplying. Use only if a thread needs more than the default.</p>
<p class=book>Headers: Errors:</p>
<p class=book>Hint:</p>
<p class=book><b>pthread_create</b></p>
<p class=book>int pthread_create (</p>
<p class=book>pthread_t *tid,</p>
<p class=book>const pthread_attr_t *attr,</p>
<p class=book>void *(*start) (void *),</p>
<p class=book>void *arg);</p>
<p class=book>Create a thread running the start function, essentially an asynchronous call to the function start with argument value arg. The attr argument specifies optional creation attributes, and the identification of the new thread is returned in tid.</p>
<p class=book>References: 2, 5.2.3</p>
<p class=book>Headers: &lt;pthread.h&gt;</p>
<p class=book>Errors: <b>[EINVAL]</b> attr invalid.</p>
<p class=book><b>[EAGAIN]</b> insufficient resources. Hint: All resources needed by thread must already be initialized.</p>
<p class=book><b>pthread_detach</b></p>
<p class=book>int pthread_detach (</p>
<p class=book>pthread_t thread);</p>
<p class=book>Detach the thread. Use this to detach the main thread or to "change your mind" after creating a joinable thread in which you are no longer interested.</p>
<p class=book>References: 2, 5.2.3 Headers: &lt;pthread.h&gt;</p>
<p class=book>Errors: [EINVAL] thread is not a joinable thread.</p>
<p class=book>[ESRCH] no thread could be found for ID thread. Hint: Detached threads cannot be joined or canceled; storage is freed</p>
<p class=book>immediately on termination.</p>
<p class=book><b>pthread_equal</b></p>
<p class=book>int pthread_equal (</p>
<p class=book>pthread_t tl,</p>
<p class=book>pthread_t t2);</p>
<p class=book>Return value 0 if t1 and t2 are equal, otherwise return nonzero.</p>
<p class=book>References: 2, 5.2.3 Headers: &lt;pthread.h&gt;</p>
<p class=book>Hint: Compare pthread_self against stored thread identifier.</p>
<p class=book><b>pthread_exit</b></p>
<p class=book>int pthread_exit (</p>
<p class=book>void *value_ptr);</p>
<p class=book>Terminate the calling thread, returning the value value_ptr to any joining thread.</p>
<p class=book>References: 2, 5.2.3 Headers: &lt;pthread.h&gt;</p>
<p class=book>Hint: value ptr is treated as a value, not the address of a value.</p>
<p class=book><b>pthread_join</b></p>
<p class=book>int pthread_join (</p>
<p class=book>pthread_t thread,</p>
<p class=book>void **value_ptr);</p>
<p class=book>Wait for thread to terminate, and return thread's exit value if value_ptr is not NULL. This also detaches thread on successful completion.</p>
<p class=book>References: 2, 5.2.3 Headers: &lt;pthread.h&gt;</p>
<p class=book>Errors: <b>[EINVAL]</b> thread is not a joinable thread.</p>
<p class=book><b>[ESRCH]</b> no thread could be found for ID thread.</p>
<p class=book>[EDEADLK] attempt to join with self. Hint: Detached threads cannot be joined or canceled.</p>
<p class=book><b>pthread_self</b></p>
<p class=book>pthread_t pthread_self (void);</p>
<p class=book>Return the calling thread's ID.</p>
<p class=book>References: 2, 5.2.3 Headers: &lt;pthread.h&gt;</p>
<p class=book>Hint: Use to set thread's scheduling parameters.</p>
<p class=book><b>sched_yield</b></p>
<p class=book>int sched_yield (void);</p>
<p class=book>Make the calling thread <i>ready,</i> after other <i>ready</i> threads of the same priority, and select a new thread to run. This can allow cooperating threads of the same priority to share processor resources more equitably, especially on a uniprocessor. This function is from POSIX.1b (realtime extensions), and is declared in &lt;sched.h&gt;. It reports errors by setting the return value to <b>-1</b> and storing an error code in errno.</p>
<p class=book>References: 2, 5.2.3 Headers: &lt;sched.h&gt;</p>
<p class=book>Errors: <b>[ENOSYS]</b> sched_yield not supported.</p>
<p class=book>Hint: Use before locking mutex to reduce chances of a timeslice while mu-</p>
<p class=book>tex is locked.</p>


<a name=t142></a><h3 class=book>
9.3.4 Mutexes
</h3>
<p class=book>Mutexes provide <i>synchronization,</i> the ability to control how threads share resources. You use mutexes to prevent multiple threads from modifying shared data at the same time, and to ensure that a thread can read consistent values for a set of resources (for example, memory) that may be modified by other threads.</p>
<p class=book><b>pthread_mutexattr_destroy</b></p>
<p class=book>int pthread_mutexattr_destroy (</p>
<p class=book>pthread_mutexattr_t *attr);</p>
<p class=book>Destroy a mutex attributes object. The object can no longer be used.</p>
<p class=book>References: 3.2, 5.2.1</p>
<p class=book>Headers: &lt;pthread.h&gt;</p>
<p class=book>Errors: [EINVAL]attrinvalid.</p>
<p class=book>Hint: Does not affect mutexes created using attr.</p>
<p class=book><b>pthread_mutexattr_getpshared..............................................[_POSIX_THREAD_PROCESS_SHARED]</b></p>
<p class=book>int pthread_mutexattr_getpshared (</p>
<p class=book>const pthread_mutexattr_t *attr,</p>
<p class=book>int *pshared);</p>
<p class=book>Determine whether mutexes created with attr can be shared by multiple processes.</p>
<p class=book><b>pshared</b></p>
<p class=book><b>PTHREAD_PROCESS_SHARED</b></p>
<p class=book><b>PTHREAD_PROCESS_PRIVATE</b></p>
<p class=book>May be shared if in shared memory.</p>
<p class=book>Cannot be shared.</p>
<p class=book>References: 3.2,5.2.1</p>
<p class=book>Headers: &lt;pthread.h&gt;</p>
<p class=book>Errors: [EINVAL]attrinvalid.</p>
<p class=book>Hint: <i>pshared</i> mutexes must be allocated in shared memory.</p>
<p class=book><b>pthread_mutexattr_init</b></p>
<p class=book>int pthread_mutexattr_init (</p>
<p class=book>pthread_mutexattr_t *attr);</p>
<p class=book>Initialize a mutex attributes object with default attributes.</p>
<p class=book>References: 3.2,5.2.1</p>
<p class=book>Headers: &lt;pthread.h&gt;</p>
<p class=book>Errors: <b>[ENOMEM]</b> insufficient memory for attr.</p>
<p class=book>Hint: Use to define mutex types.</p>
<p class=book><b>pthread_mutexattr_setpshared...............................................[_POSIX_THREAD_PROCESS</b>_sHARED ]</p>
<p class=book>int pthread_mutexattr_setpshared (</p>
<p class=book>pthread_mutexattr_t *attr,</p>
<p class=book>int pshared);</p>
<p class=book>Mutexes created with attr can be shared between processes if the pthread_mutex_t variable is allocated in memory shared by the processes.</p>
<p class=book><b>pshared</b></p>
<p class=book><b>PTHREAD_PROCESS_SHARED</b></p>
<p class=book>May be shared if in shared memory.</p>
<p class=book><b>PTHREAD_PROCESS_PRIVATE</b></p>
<p class=book>Cannot be shared.</p>
<p class=book>References: 3.2,5.2.1</p>
<p class=book>Headers: &lt;pthread.h&gt;</p>
<p class=book>Errors: [EINVAL] attr or detachstate invalid.</p>
<p class=book>Hint: <i>pshared</i> mutexes must be allocated in shared memory.</p>
<p class=book><b>pthread_mutex_destroy</b></p>
<p class=book>int pthread_mutex_destroy (</p>
<p class=book>pthread_mutex_t *mutex);</p>
<p class=book>Destroy a mutex that you no longer need.</p>
<p class=book>References: 3.2,5.2.1</p>
<p class=book>Headers: &lt;pthread.h&gt;</p>
<p class=book>Errors: [EBUSY] mutex is in use.</p>
<p class=book>[EINVAL] mutex is invalid. Hint: Safest after unlocking mutex, when no other threads will lock.</p>
<p class=book><b>pthread_mutex_init</b></p>
<p class=book>int pthread_mutex_init ( pthread_mutex_t const pthread_mutexattr_t</p>
<p class=book>*mutex, *attr);</p>
<p class=book>Initialize a mutex. The attr argument specifies optional creation attributes.</p>
<p class=book>References:</p>
<p class=book>Headers:</p>
<p class=book>Errors:</p>
<p class=book>Hint:</p>
<p class=book>3.2, 5.2.1 &lt;pthread.h&gt;</p>
<p class=book><b>[EAGAIN]</b> insufficient resources (other than memory).</p>
<p class=book><b>[ENOMEM]</b> insufficient memory.</p>
<p class=book><b>[EPERM]</b> no privilege to perform operation.</p>
<p class=book>[EBUSY] mutex is already initialized.</p>
<p class=book>[EINVAL] attr is invalid.</p>
<p class=book>Use static initialization instead, if possible.</p>
<p class=book><b>pthread_mutex_lock</b></p>
<p class=book>int pthread_mutex_lock (</p>
<p class=book>pthread_mutex_t *mutex);</p>
<p class=book>Lock a mutex. If the mutex is currently locked, the calling thread is blocked until mutex is unlocked. On return, the thread owns the mutex until it calls pthread_ mutex_unlock.</p>
<p class=book>References: 3.2, 5.2.1 Headers: &lt;pthread.h&gt;</p>
<p class=book>Errors: <b>[EINVAL]</b> thread priority exceeds mutex priority ceiling.</p>
<p class=book>[EINVAL] mutex is invalid.</p>
<p class=book>[EDEADLK] calling thread already owns mutex. Hint: Always unlock within the same thread.</p>
<p class=book><b>pthread_mutex_trylock</b></p>
<p class=book>int pthread_mutex_trylock (</p>
<p class=book>pthread_mutex_t *mutex);</p>
<p class=book>Lock a mutex. If the mutex is currently locked, returns immediately with EBUSY. Otherwise, calling thread becomes owner until it unlocks.</p>
<p class=book>References: <b>3</b>.2,5.2.1 Headers: &lt;pthread.h&gt;</p>
<p class=book>Errors: <b>[EINVAL]</b> thread priority exceeds mutex priority ceiling.</p>
<p class=book><b>[EBUSY]</b> mutex is already locked.</p>
<p class=book>[EINVAL] mutex is invalid.</p>
<p class=book>[EDEADLK] calling thread already owns mutex. Hint: Always unlock within the same thread.</p>
<p class=book><b>pthread_mutex_unlock</b></p>
<p class=book>int pthread_mutex_unlock (</p>
<p class=book>pthread_mutex_t *mutex);</p>
<p class=book>Unlock a mutex. The mutex becomes unowned. If any threads are waiting for the mutex, one is awakened (scheduling policy SCHED_FIFO and SCHED_RR policy waiters are chosen in priority order, then any others are chosen in unspecified order).</p>
<p class=book>References: 3.2, 5.2.1</p>
<p class=book>Headers: &lt;pthread.h&gt;</p>
<p class=book>Errors: [EINVAL]mutex is invalid.</p>
<p class=book>[EPERM] calling thread does not own mutex. Hint: Always unlock within the same thread.</p>


<a name=t143></a><h3 class=book>
9.3.5 Condition variables
</h3>
<p class=book>Condition variables provide <i>communication,</i> the ability to wait for some shared resource to reach some desired state, or to signal that it has reached some state in which another thread may be interested. Each condition variable is closely associated with a mutex that protects the state of the resource.</p>
<p class=book><b>pthread_condattr_destroy</b></p>
<p class=book>int pthread_condattr_destroy (</p>
<p class=book>pthread_condattr_t *attr);</p>
<p class=book>Destroy a condition variable attributes object. The object can no longer be used.</p>
<p class=book>References: 3.3, 5.2.2</p>
<p class=book>Headers: &lt;pthread.h&gt;</p>
<p class=book>Errors: [EINVAL] attr invalid.</p>
<p class=book>Hint: Does not affect condition variables created using attr.</p>
<p class=book><b>| pthread_condattr_getpshared...............................................[_pos</b></p>
<p class=book>IX THREAD PROCESS SHARED]</p>
<p class=book>int pthread_condattr_getpshared ( const pthread_condattr_t int</p>
<p class=book>*attr, *pshared);</p>
<p class=book>Determine whether condition variables created with attr can be shared by multiple processes.</p>
<p class=book><b>pshared</b></p>
<p class=book>PTHREAD_PROCESS_SHARED May be shared if in shared</p>
<p class=book>memory.</p>
<p class=book><b>PTHREAD_PROCESS_PRIVATE</b></p>
<p class=book>Cannot be shared.</p>
<p class=book>References: 3.3, 5.2.2</p>
<p class=book>Headers: &lt;pthread.h&gt;</p>
<p class=book>Errors: <b>[EINVAL</b>]attrinvalid.</p>
<p class=book>Hint: <i>pshared</i> condition variables must be allocated in shared memory</p>
<p class=book>and used with <i>pshared</i> mutexes.</p>
<p class=book><b>pthread_condattr_init</b></p>
<p class=book>int pthread_condattr_init (</p>
<p class=book>pthread_condattr_t *attr);</p>
<p class=book>Initialize a condition variable attributes object with default attributes.</p>
<p class=book>References: 3.3, 5.2.2</p>
<p class=book>Headers: &lt;pthread.h&gt;</p>
<p class=book>Errors: <b>[ENOMEM]</b> insufficient memory for attr.</p>
<p class=book>Hint: Use to define condition variable types.</p>
<p class=book><b>| pthread_condattr_setpshared................................................[_POSIX_THREAD_PRocEss</b>_sHARED]</p>
<p class=book>int pthread_condattr_setpshared (</p>
<p class=book>pthread_condattr_t *attr,</p>
<p class=book>int pshared);</p>
<p class=book>Condition variables created with attr can be shared between processes if the pthread_cond_t variable is allocated in memory shared by the processes.</p>
<p class=book><b>pshared</b></p>
<p class=book>PTHREAD_PROCESS_SHARED</p>
<p class=book><b>PTHREAD_PROCESS_PRIVATE</b></p>
<p class=book>May be shared if in shared memory.</p>
<p class=book>Cannot be shared.</p>
<p class=book>References: 3.3, 5.2.2 Headers: &lt;pthread.h&gt;</p>
<p class=book>Errors: [EINVAL] attr or detachstate invalid.</p>
<p class=book>Hint: <i>pshared</i> condition variables must be allocated in shared memory</p>
<p class=book>and used with <i>pshared</i> mutexes.</p>
<p class=book><b>pthread_cond_destroy</b></p>
<p class=book>int pthread_cond_destroy (</p>
<p class=book>pthread_cond_t *cond);</p>
<p class=book>Destroy condition variable cond that you no longer need.</p>
<p class=book>References: 3.3, 5.2.2</p>
<p class=book>Headers: &lt;pthread.h&gt;</p>
<p class=book>Errors: [EBUSY]condisinuse.</p>
<p class=book>[EINVAL] cond is invalid. Hint: Safest after wakeup from cond, when no other threads will wait.</p>
<p class=book><b>| pthread_cond_init</b></p>
<p class=book>int pthread cond init</p>
<p class=book><b>(</b></p>
<p class=book>pthread_cond_t</p>
<p class=book>const pthread_condattr_t</p>
<p class=book>*cond, *attr);</p>
<p class=book>Initialize a condition variable cond. The attr argument specifies optional creation</p>
<p class=book>attributes.</p>
<p class=book>References:</p>
<p class=book>Headers:</p>
<p class=book>Errors:</p>
<p class=book>Hint:</p>
<p class=book>3.3, 5.2.2 &lt;pthread.h&gt;</p>
<p class=book><b>[EAGAIN]</b> insufficient resources (other than memory).</p>
<p class=book><b>[ ENOMEM]</b> insufficient memory.</p>
<p class=book>[ EBUSY ] cond is already initialized.</p>
<p class=book>[EINVAL] attr is invalid.</p>
<p class=book>Use static initialization instead, if possible.</p>
<p class=book><b>pthread_cond_broadcast</b></p>
<p class=book>int pthread_cond_broadcast (</p>
<p class=book>pthread_cond_t *cond);</p>
<p class=book>Broadcast condition variable cond, waking all current waiters.</p>
<p class=book>References: 3.3, 5.2.2</p>
<p class=book>Headers: &lt;pthread.h&gt;</p>
<p class=book>Errors: [EINVAL]condisinvalid.</p>
<p class=book>Hint: Use when more than one waiter may respond to predicate change</p>
<p class=book>or if any waiting thread may not be able to respond.</p>
<p class=book><b>pthread_cond_signal</b></p>
<p class=book>int pthread_cond_signal (</p>
<p class=book>pthread_cond_t *cond);</p>
<p class=book>Signal condition variable cond, waking one waiting thread. If SCHED_FIFO or SCHED_RR policy threads are waiting, the highest-priority waiter is awakened. Otherwise, an unspecified waiter is awakened.</p>
<p class=book>References: 3.3, 5.2.2</p>
<p class=book>Headers: &lt;pthread.h&gt;</p>
<p class=book>Errors: [EINVAL]condisinvalid.</p>
<p class=book>Hint: Use when any waiter can respond, and only one need respond. (All</p>
<p class=book>waiters are equal.)</p>
<p class=book><b>pthread_cond_timedwait</b></p>
<p class=book>int pthread cond timedwait</p>
<p class=book>pthread_cond_t pthread_mutex_t const struct timespec</p>
<p class=book>*cond, *mutex, *abstime);</p>
<p class=book>Wait on condition variable cond, until awakened by a signal or broadcast, or until the absolute time abstime is reached.</p>
<p class=book>References:</p>
<p class=book>Headers:</p>
<p class=book>Errors:</p>
<p class=book>Hint:</p>
<p class=book>3.3, 5.2.2 &lt;pthread.h&gt;</p>
<p class=book><b>[ETIMEDOUT]</b> time specified by abstime has passed.</p>
<p class=book>[EINVAL] cond, mutex, or abstime is invalid.</p>
<p class=book>[EINVAL] different mutexes for concurrent waits.</p>
<p class=book>[EINVAL] mutex is not owned by calling thread.</p>
<p class=book>Mutex is always unlocked (before wait) and relocked (after wait)</p>
<p class=book>inside pthread_cond_timedwait, even if the wait fails, times out, or</p>
<p class=book>is canceled.</p>
<p class=book><b>pthread_cond_wait</b></p>
<p class=book>int pthread_cond_wait ( pthread_cond_t pthread_mutex_t</p>
<p class=book>*cond, *mutex);</p>
<p class=book>Wait on condition variable cond, until awakened by a signal or broadcast.</p>
<p class=book>References: 3.3, 5.2.2 Headers: &lt;pthread.h&gt;</p>
<p class=book>Errors: [EINVAL] cond or mutex is invalid.</p>
<p class=book>[EINVAL] different mutexes for concurrent waits. [EINVAL] mutex is not owned by calling thread.</p>
<p class=book>Hint: Mutex is always unlocked (before wait) and relocked (after wait) in-</p>
<p class=book>side pthread_cond_wait, even if the wait fails or is canceled.</p>


<a name=t144></a><h3 class=book>
9.3.6 Cancellation
</h3>
<p class=book>Cancellation provides a way to request that a thread terminate "gracefully" when you no longer need it to complete its normal execution. Each thread can control how and whether cancellation affects it, and can repair the shared state as it terminates due to cancellation.</p>
<p class=book><b>pthread_cancel</b></p>
<p class=book>int pthread_cancel (</p>
<p class=book>pthread_t thread);</p>
<p class=book>Requests that thread be canceled.</p>
<p class=book>References: 5.3 Headers: &lt;pthread.h&gt;</p>
<p class=book>Errors: [ESRCH] no thread found corresponding to thread.</p>
<p class=book>Hint: Cancellation is asynchronous. Use pthread_join to wait for termi-</p>
<p class=book>nation of thread if necessary.</p>
<p class=book><b>pthread_cleanup_pop</b></p>
<p class=book>void pthread_cleanup_pop (int execute);</p>
<p class=book>Pop the most recently pushed cleanup handler. Invoke the cleanup handler if execute is nonzero.</p>
<p class=book>References: 5.3 Headers: &lt;pthread.h&gt;</p>
<p class=book>Hint: Specify execute as nonzero to avoid duplication of common cleanup</p>
<p class=book>code.</p>
<p class=book><b>pthread_cleanup_push</b></p>
<p class=book>void pthread_cleanup_push (</p>
<p class=book>void (*routine)(void *),</p>
<p class=book>void *arg);</p>
<p class=book>Push a new cleanup handler onto the thread's stack of cleanup handlers. Invoke the cleanup handler if execute is nonzero. Each cleanup handler pushed onto the stack is popped and invoked with the argument arg when the thread exits by calling pthread_exit, when the thread acts on a cancellation request, or when the thread calls pthread_cleanup_pop with a nonzero execute argument.</p>
<p class=book>References: 5.3 Headers: &lt;pthread.h&gt;</p>
<p class=book>Hint: pthread_cleanup_push and pthread_cleanup_pop must be paired</p>
<p class=book>in the same lexical scope.</p>
<p class=book><b>pthread_setcancelstate</b></p>
<p class=book>int pthread_setcancelstate (</p>
<p class=book>int state,</p>
<p class=book>int *oldstate);</p>
<p class=book>Atomically set the calling thread's cancelability state to state and return the previous cancelability state at the location referenced by oldstate.</p>
<p class=book><b>state, oldstate</b></p>
<p class=book><b>PTHREAD_CANCEL_ENABLE</b></p>
<p class=book>Cancellation is enabled.</p>
<p class=book>PTHREAD_CANCEL_DISABLE</p>
<p class=book>Cancellatlon is disabled.</p>
<p class=book>References: 5.3</p>
<p class=book>Headers: &lt;pthread.h&gt;</p>
<p class=book>Errors: [EINVAL]stateisinvalid.</p>
<p class=book>Hint: Use to disable cancellation around "atomic" code that includes can-</p>
<p class=book>cellation points.</p>
<p class=book><b>pthread_setcanceltype</b></p>
<p class=book>int pthread_setcanceltype (</p>
<p class=book>int type,</p>
<p class=book>int *oldtype);</p>
<p class=book>Atomically set the calling thread's cancelability type to type and return the previous cancelability type at the location referenced by oldtype.</p>
<p class=book><b>type, oldtype</b></p>
<p class=book><b>PTHREAD_CANCEL_DEFERRED</b></p>
<p class=book>Only deferred cancellation is allowed.</p>
<p class=book>PTHREAD_CANCEL_ASYNCHRONOUS Asynchronous cancellation is</p>
<p class=book>allowed.</p>
<p class=book>References: 5.3</p>
<p class=book>Headers: &lt;pthread.h&gt;</p>
<p class=book>Errors: [EINVAL] type is invalid.</p>
<p class=book>Hint: Use with caution — most code is not safe for use with asynchronous</p>
<p class=book>cancelability type.</p>
<p class=book><b>pthread_testcancel</b></p>
<p class=book>void pthread_testcancel (void);</p>
<p class=book>Creates a deferred cancellation point in the calling thread. The call has no effect if the current cancelability state is PTHREAD_CANCEL_DISABLE.</p>
<p class=book>References: 5.3 Headers: &lt;pthread.h&gt;</p>
<p class=book>Hint: Cancellation is asynchronous. Use pthread_join to wait for termi-</p>
<p class=book>nation of thread if necessary.</p>


<a name=t145></a><h3 class=book>
9.3.7 Thread-specific data
</h3>
<p class=book>Thread-specific data provides a way to declare variables that have a common "name" in all threads, but a unique value in each thread. You should consider using thread-speciflc data in a threaded program in many cases where a non-threaded program would use "static" data. When the static data maintains context across a series of calls to some function, for example, the context should generally be thread-specific. (If not, the static data must be protected by a mutex.)</p>
<p class=book><b>pthread_getspecific</b></p>
<p class=book>void *pthread_getspecific (</p>
<p class=book>pthread_key_t key);</p>
<p class=book>Return the current value of key in the calling thread. If no value has been set for key in the thread, NULL is returned.</p>
<p class=book>References: 5.4, 7.2, 7.3.<b>1</b> Headers: &lt;pthread.h&gt;</p>
<p class=book>Errors: The effect of calling pthread_getspecific with an invalid key is un-</p>
<p class=book>defined. No errors are detected.</p>
<p class=book>Hint: Calling pthread_getspecific in a destructor function will return</p>
<p class=book>NULL. Use destructor's argument instead.</p>
<p class=book><b>pthread_key_create</b></p>
<p class=book>int pthread_key_create (</p>
<p class=book>pthread_key_t *key,</p>
<p class=book>void (*destructor)(void *));</p>
<p class=book>Create a thread-specific data key visible to all threads. All existing and new threads have value NULL for key until set using pthread_setspecific. When any thread with a non-NULL value for key terminates, destructor is called with key's current value for that thread.</p>
<p class=book>References: 5.4,7.2,7.3.1 Headers: &lt;pthread.h&gt;</p>
<p class=book>Errors: <b>[EAGAIN]</b> insufficientresourcesorPTHREAD_KEYS_MAxexceeded.</p>
<p class=book><b>[ENOMEM]</b> insufficient memory to create the key. Hint: Each key (pthread_key_t variable) must be created only once; use</p>
<p class=book>a mutex or pthread_once.</p>
<p class=book><b>pthread_key_delete</b></p>
<p class=book>int pthread_key_delete (</p>
<p class=book>pthread_key_t key);</p>
<p class=book>Delete a thread-specific data key. This does not change the value of the thread-specific data key for any thread and does not run the key's destructor in any thread, so it should be used with great caution.</p>
<p class=book>References: 5.4</p>
<p class=book>Headers: &lt;pthread.h&gt;</p>
<p class=book>Errors: [EINVAL]keyisinvalid.</p>
<p class=book>Hint: Use only when you know all threads have NULL value.</p>
<p class=book><b>pthread_setspecific</b></p>
<p class=book>int pthread_setspecific (</p>
<p class=book>pthread_key_t key, const void *value);</p>
<p class=book>Associate a thread-specific value within the calling thread for the specified key.</p>
<p class=book>References: 5.4, 7.2, 7.3.1</p>
<p class=book>Headers: &lt;pthread.h&gt;</p>
<p class=book>Errors: <b>[ENOMEM</b>]insufficient memory.</p>
<p class=book>[EINVAL] key is invalid. Hint: If you set a value of NULL, the key's destructor will not be called at</p>
<p class=book>thread termination.</p>


<a name=t146></a><h3 class=book>
9.3.8 Realtime scheduling
</h3>
<p class=book>Realtime scheduling provides a predictable response time to important events within the process. Note that "predictable" does not always mean "fast," and in many cases realtime scheduling may impose overhead that results in slower execution. Realtime scheduling is also subject to synchronization problems such as priority inversion (Sections 5.5.4 and 8.1.4), although Pthreads provides optional facilities to address some of these problems.</p>
<p class=book><b>pthread_attr_getinheritsched....................................... [_POSIX_THREAD_PRIORITY_SCHEDULING]</b></p>
<p class=book>int pthread_attr_getinheritsched (</p>
<p class=book>const pthread_attr_t *attr,</p>
<p class=book>int *inheritsched);</p>
<p class=book>Determine whether threads created with attr will run using the scheduling policy and parameters of the creator or those specified in the attributes object. The default inheritsched is implementation-defined.</p>
<p class=book><b>inheritsched</b></p>
<p class=book><b>PTHREAD_INHERIT_SCHED</b></p>
<p class=book>Use creator's scheduling policy and parameters.</p>
<p class=book><b>PTHREAD_EXPLICIT_SCHED</b></p>
<p class=book>Use scheduling policy and parameters in attributes object.</p>
<p class=book>References: 5.2.3, 5.5 Headers: &lt;pthread.h&gt;</p>
<p class=book>Errors: <b>[ENOSYS]</b> priority scheduling is not supported.</p>
<p class=book>[EINVAL] attr invalid.</p>
<p class=book><b>pthread_attr_getschedparam......................................[_POSIX_THREAD_PRIORITY_SCHEDLLING]</b></p>
<p class=book>int pthread_attr_getschedparam (</p>
<p class=book>const pthread_attr_t *attr, struct sched_param *param);</p>
<p class=book>Determine the scheduling parameters used by threads created with attr. The default param is implementation defined.</p>
<p class=book>References: 5.2.3, 5.5 Headers: &lt;pthread.h&gt;</p>
<p class=book>Errors: <b>[ENOSYS]</b> priority schedulingis not supported.</p>
<p class=book>[EINVAL] attr invalid.</p>
<p class=book><b>pfhread_attr_getschedpolicy....................................... [_POSIX_THREAD_PRIORITY_SCHEDULING]</b></p>
<p class=book>int pthread_attr_getschedpolicy (</p>
<p class=book>const pthread_attr_t *attr, int *policy);</p>
<p class=book>Determine the scheduling policy used by threads created with attr. The default policy is implementation defined.</p>
<p class=book>SCHED_FIFO</p>
<p class=book>SCHED_RR</p>
<p class=book>SCHED_OTHER</p>
<p class=book><b>policy</b></p>
<p class=book>Run thread until it blocks; preempt lower-priority threads when ready.</p>
<p class=book>Like SCHED_FIFO, but subject to periodic timeslicing.</p>
<p class=book>Implementation defined (may be SCHED_FIFO, SCHED_RR, or something else).</p>
<p class=book>References: 5.2.3, 5.5 Headers: &lt;pthread.h&gt;</p>
<p class=book>Errors: <b>[ENOSYS]</b> priority scheduling is not supported.</p>
<p class=book>[EINVAL] attr invalid.</p>
<p class=book><b>pthread_attr_getscope.................................................[_POSIX_THREAD_PRIORITY_SCHEDULLING]</b></p>
<p class=book>int pthread_attr_getscope (</p>
<p class=book>const pthread_attr_t *attr,</p>
<p class=book>int *contentionscope);</p>
<p class=book>Determine the contention scope used by threads created with attr. The default is implementation defined.</p>
<p class=book><b>contentionscope</b></p>
<p class=book>PTHREAD_SCOPE_PROCESS</p>
<p class=book>Thread contends with other threads in the process for processor resources.</p>
<p class=book>PTHREAD SCOPE SYSTEM</p>
<p class=book>Thread contends with threads in all processes for processor resources.</p>
<p class=book>References: 5.2.3, 5.5 Headers: &lt;pthread.h&gt;</p>
<p class=book>Errors: <b>[ENOSYS]</b> priority scheduling is not supported.</p>
<p class=book>[EINVAL] attr invalid. Hint: Implementation must support one or both of these, but need not</p>
<p class=book>support both.</p>
<p class=book><b>pthread_attr_setinheritsched.......................................[_POSIX_THREAD_PRIORITY_SCHEDULING ]</b></p>
<p class=book>int pthread_attr_setinheritsched ( pthread_attr_t *attr, int inheritsched);</p>
<p class=book>Specify whether threads created with attr will run using the scheduling policy and parameters of the creator or those specified in the attributes object. When you change the scheduling policy or parameters in a thread attributes object, you must change the <i>inheritsched</i> attribute from PTHREAD_INHERIT_SCHED to PTHREAD_ EXPLICIT_SCHED. The default is implementation-defined.</p>
<p class=book><b>inheritsched</b></p>
<p class=book><b>PTHREAD_INHERIT_SCHED</b></p>
<p class=book>Use creator's scheduling policy and parameters.</p>
<p class=book><b>PTHREAD_EXPLICIT_SCHED</b></p>
<p class=book>Use scheduling policy and parameters in attributes object.</p>
<p class=book>References: 5.2.3, 5.5 Headers: &lt;pthread.h&gt;</p>
<p class=book>Errors: <b>[ENOSYS]</b> priority scheduling is not supported.</p>
<p class=book>[EINVAL] attr or inheritsched invalid.</p>
<p class=book><b>pthread_attr_setschedparam......................................[_POSIX_THREAD_PRIORITY_SCHEDULING]</b></p>
<p class=book>int pthread_attr_setschedparam (</p>
<p class=book>pthread_attr_t *attr,</p>
<p class=book>const struct sched_param *param);</p>
<p class=book>Specify the scheduling parameters used by threads created with attr. The default param is implementation defined.</p>
<p class=book>References: 5.2.3, 5.5 Headers: &lt;pthread.h&gt;</p>
<p class=book>Errors: <b>[ENOSYS]</b> priority scheduling is not supported.</p>
<p class=book>[EINVAL] attr or param invalid. [ENOTSUP] param set to supported value.</p>
<p class=book><b>pthread_attr_setschedpolicy....................................... [_POSIX_THREAD_PRIORITY_SCHEDULING]</b></p>
<p class=book>int pthread_attr_setschedpolicy ( pthread_attr_t *attr, int policy);</p>
<p class=book>Specify the scheduling policy used by threads created with attr. The default policy is implementation defined.</p>
<p class=book>SCHED_FIFO</p>
<p class=book>SCHED_RR</p>
<p class=book>SCHED_OTHER</p>
<p class=book><b>policy</b></p>
<p class=book>Run thread until it blocks; preempt lower-priority threads when ready.</p>
<p class=book>Like SCHED_FIFO, but sub-ject to periodic timeslicing.</p>
<p class=book>Implementation defined(may be SCHED_FIFO, SCHED_RR, or something else).</p>
<p class=book>References: 5.2.3, 5.5 Headers: &lt;pthread.h&gt;</p>
<p class=book>Errors: <b>[ENOSYS]</b> priority scheduling is not supported</p>
<p class=book>[EINVAL] attr or policy invalid. [ENOTSUP] param set to supported value.</p>
<p class=book><b>pthread_attr_setscope</b>.................................................. [_<b>POSIX_THREAD_PRIORITY_SCHEDULING</b>]</p>
<p class=book>int pthread_attr_setscope (</p>
<p class=book>pthread_attr_t *attr,</p>
<p class=book>int contentionscope);</p>
<p class=book>Specify the contention scope used by threads created with attr. The default is implementation defined.</p>
<p class=book><b>contentionscope</b></p>
<p class=book>PTHREAD SCOPE PROCESS</p>
<p class=book><b>Thread contends with other threads in the process for processor resources.</b></p>
<p class=book>PTHREAD SCOPE SYSTEM</p>
<p class=book><b>Thread contends with threads in all processes for processor resources.</b></p>
<p class=book>References:</p>
<p class=book>Headers:</p>
<p class=book>Errors:</p>
<p class=book>Hint:</p>
<p class=book>5.2.3, 5.5 &lt;pthread.h&gt;</p>
<p class=book><b>[ENOSYS]</b> priority scheduling is not supported. [EINVAL] attr or contentionscope invalid. [ENOTSUP] contentionscope set to supported value. Implementation must support one or both of these, but need not support both.</p>
<p class=book><b>pthread_getschedparam............................................. [_POSIX_THREAD_PRIORITY_SCHEDULING]</b></p>
<p class=book>int pthread_getschedparam (</p>
<p class=book>pthread_t thread,</p>
<p class=book>int *policy</p>
<p class=book>struct sched_param *param);</p>
<p class=book>Determine the schedulingpolicy and parameters (param) currently used by thread.</p>
<p class=book>policy</p>
<p class=book>Run thread until it blocks; preempt lower-priority threads when ready.</p>
<p class=book>SCHED_FIFO</p>
<p class=book>SCHED_RR SCHED_OTHER</p>
<p class=book>Like SCHED_FIFO, but subject to periodic timeslicing.</p>
<p class=book>Implementation defined (may be SCHED_FIFO, SCHED_RR, or something else).</p>
<p class=book>References: 5.2.3, 5.5 Headers: &lt;pthread.h&gt;</p>
<p class=book>Errors: <b>[ENOSYS]</b> priority scheduling is not supported.</p>
<p class=book>[ESRCH] thread does not refer to an existing thread. Hint: Try to avoid dynamically modifying thread scheduling policy and</p>
<p class=book>parameters, if possible.</p>
<p class=book><b>| prhread_mutex_getprioceiling...................................................[_POSIX_THREAD_PRIO_PROTECT</b>]</p>
<p class=book>int pthread_mutex_getprioceiling (</p>
<p class=book>const pthread_mutex_t *mutex,</p>
<p class=book>int *prioceiling);</p>
<p class=book>Determine the priority ceiling at which threads will run while owning mutex.</p>
<p class=book>References: 3.2,5.2.1,5.5.5 Headers: &lt;pthread.h&gt;</p>
<p class=book>Errors: <b>[ENOSYS]</b> priority scheduling is not supported.</p>
<p class=book>[EINVAL] mutex invalid. Hint: <i>Protect</i> protocol is inappropriate unless the creator of the mutex</p>
<p class=book>also creates and controls all threads that might lock the mutex.</p>
<p class=book><b>pthread_mutex_setprioceiling....................................................[_POSIX_THREAD_PRIO_PROTECT</b> ]</p>
<p class=book>int pthread_mutex_getprioceiling ( pthread_mutex_t *mutex, int prioceiling,</p>
<p class=book>int *old_ceiling);</p>
<p class=book>Specify the priority ceiling at which threads will run while owning mutex. Returns previous priority ceiling for mutex.</p>
<p class=book>References: 3.2,5.2.1,5.5.5 Headers: &lt;pthread.h&gt;</p>
<p class=book>Errors: <b>[ENOSYS]</b> priority scheduling is not supported.</p>
<p class=book>[EINVAL] mutex invalid, or prioceiling out of range.</p>
<p class=book>[EPERM] no privilege to set prioceiling. Hint: <i>Protect</i> protocol is inappropriate unless the creator of the mutex</p>
<p class=book>also creates and controls all threads that might lock the mutex.</p>
<p class=book><b>pthread_mutexattr_getprioceiling.............................................[_POSIX_THREAD_PRIO_PROTECT</b> ]</p>
<p class=book>int pthread_mutexattr_getprioceiling (</p>
<p class=book>const pthread_mutexattr_t *attr,</p>
<p class=book>int *prioceiling);</p>
<p class=book>Determine the priority ceiling at which threads will run while owning a mutex created with attr.</p>
<p class=book>References: 3.2, 5.2.1, 5.5.5 Headers: &lt;pthread.h&gt;</p>
<p class=book>Errors: <b>[ENOSYS]</b> priority scheduling is not supported.</p>
<p class=book>[EINVAL] attr invalid. Hint: <i>Protect</i> protocol is inappropriate unless the creator of the mutex</p>
<p class=book>also creates and controls all threads that might lock the mutex.</p>
<p class=book><b>pthread_mutexattr_getprotocol... [_POSIX_THREAD_PRIO_INHERIT_POSIX_THREAD_PRIO_PROTECT]</b></p>
<p class=book>int pthread_mutexattr_getprotocol (</p>
<p class=book>const pthread_mutexattr_t *attr,</p>
<p class=book>int *protocol);</p>
<p class=book>Determine whether mutexes created with attr have priority ceiling protocol <i>protect),</i> priority inheritance protocol <i>(inherit),</i> or no priority protocol (none).</p>
<p class=book><b>protocol</b></p>
<p class=book><b>PTHREAD_PRIO_NONE</b> No priority inheritance</p>
<p class=book>protocol.</p>
<p class=book>PTHREAD_PRIO_INHERIT While owning mutex, thread</p>
<p class=book>inherits highest priority of any thread waiting for the mutex.</p>
<p class=book>PTHREAD_PRIO_PROTECT While owning mutex, thread</p>
<p class=book>inherits mutex priority ceiling.</p>
<p class=book>References: 3.2,5.2.1,5.5.5 Headers: &lt;pthread.h&gt;</p>
<p class=book>Errors: <b>[ENOSYS]</b> priority scheduling is not supported.</p>
<p class=book>[EINVAL] attr invalid. Hint: <i>Inherit</i> protocol is expensive, and <i>protect</i> protocol is inappropriate</p>
<p class=book>unless the creator of the mutex also creates and controls all threads</p>
<p class=book>that might lock the mutex.</p>
<p class=book><b>pthread_mutexattr_setprioceiling...............................................[_POSIX_THREAD_PRIO_PROTECT</b> ]</p>
<p class=book>int pthread_mutexattr_setprioceiling ( pthread_mutexattr_t *attr,</p>
<p class=book>int prioceiling);</p>
<p class=book>Specify the priority ceiling at which threads will run while owning a mutex created with attr. The value of prioceiling must be a valid priority parameter for the</p>
<p class=book>SCHED_FIFO policy.</p>
<p class=book>References: 3.2,5.2.1,5.5.5 Headers: &lt;pthread.h&gt;</p>
<p class=book>Errors: <b>[ENOSYS]</b> priority scheduling is not supported.</p>
<p class=book>[EINVAL] attr or prioceiling invalid.</p>
<p class=book>[EPERM] no permission to set prioceiling. Hint: <i>Protect</i> protocol is inappropriate unless the creator of the mutex</p>
<p class=book>also creates and controls all threads that might lock the mutex.</p>
<p class=book><b>pthread_mutexattr_setprotocol</b> .... [<b>_POSIX_THREAD_PRIO_INHERIT_POSIX_THREAD_PRIO_PROTECT</b>]</p>
<p class=book>int pthread_mutexattr_setprotocol (</p>
<p class=book>pthread_mutexattr_t *attr,</p>
<p class=book>int protocol);</p>
<p class=book>Specify whether mutexes created with attr have priority ceiling protocol <i>protect),</i> priority inheritance protocol <i>(inherit),</i> or no priority protocol <i>(none).</i></p>
<p class=book><b>protocol</b></p>
<p class=book><b>PTHREAD_PRIO_NONE</b> No priority inheritance</p>
<p class=book>protocol.</p>
<p class=book>PTHREAD_PRIO_INHERIT While owning mutex, thread</p>
<p class=book>inherits highest priority of any thread waiting for the mutex.</p>
<p class=book>PTHREAD_PRIO_PROTECT While owning mutex, thread</p>
<p class=book>inherits mutex priority ceiling.</p>
<p class=book>References: 3.2,5.2.1,5.5.5 Headers: &lt;pthread.h&gt;</p>
<p class=book>Errors: <b>[ENOSYS]</b> priority scheduling is not supported.</p>
<p class=book>[EINVAL] attr or protocol invalid.</p>
<p class=book><b>[ENOTSUP]</b> protocol value is not supported. Hint: <i>Inherit</i> protocol is expensive, and <i>protect</i> protocol is inappropriate</p>
<p class=book>unless the creator of the mutex also creates and controls all threads</p>
<p class=book>that might lock the mutex.</p>
<p class=book><b>pthread_setschedparam..............................................[_POSIX_THREAD_PRIORITY_SCHEDULING]</b></p>
<p class=book>int pthread_setschedparam (</p>
<p class=book>pthread_t thread,</p>
<p class=book>int policy</p>
<p class=book>const struct sched_param *param);</p>
<p class=book>Specify the scheduling policy and parameters (param) to be used by thread.</p>
<p class=book><b>policy</b></p>
<p class=book><b>SCHED_FIFO</b></p>
<p class=book><b>SCHED_RR</b></p>
<p class=book>Run thread until it blocks; preempt lower-priority threads when ready.</p>
<p class=book>Like SCHED_FIFO, but subject to periodic timeslicing.</p>
<p class=book><b>SCHED_OTHER</b></p>
<p class=book>Implementation defined (may be SCHED_FIFO, SCHED_RR, or something else).</p>
<p class=book>References:</p>
<p class=book>Headers:</p>
<p class=book>Errors:</p>
<p class=book>Hint:</p>
<p class=book>5.5</p>
<p class=book>&lt;pthread.h&gt;</p>
<p class=book><b>[ENOSYS]</b> priority scheduling is not supported.</p>
<p class=book>[ESRCH] thread does not refer to an existing thread.</p>
<p class=book>[EINVAL] policy or param is invalid.</p>
<p class=book>[ENOTSUP] policy or param is unsupported value.</p>
<p class=book>[EPERM] no permission to set policy or param.</p>
<p class=book>Try to avoid dynamically modifying thread scheduling policy and</p>
<p class=book>parameters, if possible.</p>
<p class=book><b>sched_get_priority_max..............................................................[_POSIX_PRIORITY_SCHEDULING]</b></p>
<p class=book>int sched_get_priority_max (</p>
<p class=book>int policy);</p>
<p class=book>Return the maximum integer priority allowed for the specified scheduling policy.</p>
<p class=book>policy</p>
<p class=book>Run thread until it blocks; preempt lower-priority threads when ready.</p>
<p class=book>Like <b>SCHED_FIFO,</b> but subject to periodic timeslicing.</p>
<p class=book>Implementation defined (may be SCHED_FIFO, SCHED_RR, or something else).</p>
<p class=book>References: <b>5.5.2</b> Headers: &lt;sched.h&gt;</p>
<p class=book>Errors: [<b>ENOSYS</b>] priority scheduling is not supported.</p>
<p class=book><b>[EINVAL]</b> policy is invalid. Hint: Priority min and max are integer values—you can compute relative</p>
<p class=book>values, for example, half and quarter points in range.</p>
<p class=book>SCHED_FIFO</p>
<p class=book><b>SCHED_RR</b></p>
<p class=book>SCHED_OTHER</p>
<p class=book><b>[_POSIX_PRIORITY_SCHEDULING]</b></p>
<p class=book><b>sched_get_priority_min.........................................................</b></p>
<p class=book>int sched_get_priority_min (</p>
<p class=book>int policy);</p>
<p class=book>Return the minimum integer priority allowed for the specified scheduling policy.</p>
<p class=book>References: <b>5.5.2</b> Headers: &lt;sched.h&gt;</p>
<p class=book>Errors: [ENOSYS] priority scheduling is not supported.</p>
<p class=book>[EINVAL] policy is invalid. Hint: Priority min and max are integer values — you can compute relative</p>
<p class=book>values, for example, half and quarter points in range.</p>
<TABLE>
<TR>
<TD align = "left"  colspan = "3" ><b>policy</b></TD>
</TR>
<TR>
<TD align = "left" >SCHED_</TD>
<TD align = "left" >_FIFO</TD>
<TD align = "left" >Run thread until it blocks;</TD>
</TR>
<TR>
<TD></TD>
<TD></TD>
<TD align = "left" >preempt lower-priority</TD>
</TR>
<TR>
<TD></TD>
<TD></TD>
<TD align = "left" >threads when ready.</TD>
</TR>
<TR>
<TD align = "left" >SCHED_</TD>
<TD align = "left" >_RR</TD>
<TD align = "left" >Like SCHED_FIFO, but sub-</TD>
</TR>
<TR>
<TD></TD>
<TD></TD>
<TD align = "left" >ject to periodic timeslicing.</TD>
</TR>
<TR>
<TD align = "left" >SCHED_</TD>
<TD align = "left" >OTHER</TD>
<TD align = "left" >Implementation defined (may</TD>
</TR>
<TR>
<TD></TD>
<TD></TD>
<TD align = "left" >be SCHED_FIFO, SCHED_RR,</TD>
</TR>
<TR>
<TD></TD>
<TD></TD>
<TD align = "left" >or something else).</TD>
</TR>
</TABLE>


<a name=t147></a><h3 class=book>
9.3.9 Fork handlers
</h3>
<p class=book>Pthreads provides some new functions to help the new threaded environment to coexist with the traditional process-based UNIX environment. Creation of a child process by copying the full address space, for example, causes problems for threaded applications because the fork call is asynchronous with respect to other threads in the process.</p>
<p class=book><b>pthread_atfork</b></p>
<p class=book>int pthread_atfork (</p>
<p class=book>void (*prepare)(void),</p>
<p class=book>void (*parent)(void),</p>
<p class=book>void (*child)(void));</p>
<p class=book>Define "fork handlers" that are run when the process creates a child process. Allows protection of synchronization objects and shared data in the child process (which is otherwise difficult to control).</p>
<p class=book>References: 6.1.1</p>
<p class=book>Headers: &lt;unistd.h&gt;*<sup><a name=r10><a href="#n10" title="
 Digital UNIX and Solaris both (incorrectly) place the definition in &lt;pthread.h&gt;. The UNIX 98 brand will require that they be fixed.
">[10]</sup></A></p>
<p class=book>Errors: [ENOMEM] insufficient space to record the handlers.</p>
<p class=book>Hint: All resources needed by child must be protected.</p>


<a name=t148></a><h3 class=book>
<b>9.3.10</b> <i><b>Stdio</b></i>
</h3>
<p class=book>Pthreads provides some new functions, and new versions of old functions, to access ANSI C <i>stdio</i> features safely from a threaded process. For safety reasons, the old forms of single-character access to <i>stdio</i> buffers have been altered to lock the file stream, which can decrease performance. You can change old code to instead lock the file stream manually and, within that locked region, use new character access operations that do not lock the file stream.</p>
<p class=book><b>flockfile</b></p>
<p class=book>void flockfile (</p>
<p class=book>FILE *file);</p>
<p class=book>Increase the lock count for a <i>stdio</i> file stream to gain exclusive access to the file stream. If the file stream is currently locked by another thread, the calling thread is blocked until the lock count for the file stream becomes zero. If the calling thread already owns the file stream lock, the lock count is incremented — an identical number of calls to funlockfile is required to release the file stream lock.</p>
<br>
<p class=book>Although most stdio functions, such as printf and fgets, are thread-safe, you may sometimes find that it is important that a sequence of printf calls, for example, from one thread cannot be separated by calls made from another thread. Also, a few <i><b>stdio</b></i> functions are not thread-safe and can only be used while the file stream is locked by the caller.</p>
<p class=book>References: 6.4.1 Headers: &lt;stdio.h&gt;</p>
<p class=book>Hint: Use to protect a sequence of <i><b>stdio</b></i> operations.</p>
<p class=book><b>ftrylockfile</b></p>
<p class=book>int ftrylockfile (</p>
<p class=book>FILE *file);</p>
<p class=book>If the file stream is currently locked by another thread, return a nonzero value. Otherwise, increase the lock count for the file stream, and return the value zero.</p>
<p class=book>References: 6.4.1 Headers: &lt;stdio.h&gt;</p>
<p class=book>Hint: Use to protect a sequence <i>of stdio</i> operations.</p>
<p class=book><b>funlockfile</b></p>
<p class=book>void funlockfile (</p>
<p class=book>FILE *file);</p>
<p class=book>Decrease the lock count for a <i><b>stdio</b></i> file stream that was previously locked by a corresponding call to funlockfile. If the lock count becomes 0, release the lock so that another thread can lock it.</p>
<p class=book>References: 6.4.1 Headers: &lt;stdio.h&gt;</p>
<p class=book>Hint: Use to protect a sequence of <i><b>stdio</b></i> operations.</p>
<p class=book><b>getc_unlocked</b></p>
<p class=book>int getc_unlocked (</p>
<p class=book>FILE *file);</p>
<p class=book>Return a single character from the <i><b>stdio</b></i> stream file, without locking the file stream. This operation must only be used while the file stream has been locked by calling flockfile, or when you know that no other thread may access the file stream concurrently. Returns EOF for read errors or end-of-file condition.</p>
<p class=book>References: 6.4.2 Headers: &lt;stdio.h&gt;</p>
<p class=book>Hint: Replace old calls to getc to retain fastest access.</p>
<p class=book><b>getchar_unlocked</b></p>
<p class=book>int getc_unlocked (void);</p>
<p class=book>Return a single character from the <i>stdio</i> stream stdin without locking the file stream. This operation must only be used while the file stream has been locked by calling flockfile, or when you know that no other thread may access the file stream concurrently. Returns EOF for read errors or end-of-file condition.</p>
<p class=book>References: 6.4.2 Headers: &lt;stdio.h&gt;</p>
<p class=book>Hint: Replace old calls to getchar to retain fastest access.</p>
<p class=book><b>putc_unlocked</b></p>
<p class=book>int putc_unlocked (</p>
<p class=book>int c,</p>
<p class=book>FILE *file);</p>
<p class=book>Write a single character c (interpreted as an unsigned char) to the <i>stdio</i> stream file without locking the file stream. This operation must only be used while the file stream has been locked by calling flockfile, or when you know that no other thread may access the file stream concurrently. Returns the character or the value EOF if an error occurred.</p>
<p class=book>References: 6.4.2 Headers: &lt;stdio.h&gt;</p>
<p class=book>Hint: Replace old calls to putc to retain fastest access.</p>
<p class=book><b>putchar_unlocked</b></p>
<p class=book>int putchar_unlocked (</p>
<p class=book>int c);</p>
<p class=book>Write a single character c (interpreted as an unsigned char) to the <i>stdio</i> stream stdout without locking the file stream. This operation must only be used while the file stream has been locked by calling flockfile, or when you know that no other thread may access the file stream concurrently. Returns the character or the value EOF if an error occurred.</p>
<p class=book>References: 6.4.2 Headers: &lt;stdio.h&gt;</p>
<p class=book>Hint: Replace old calls to putchar to retain fastest access.</p>


<a name=t149></a><h3 class=book>
9.3.11 Thread-safe functions
</h3>
<p class=book>Thread-safe functions provide improved access to traditional features of ANSI C and POSIX that cannot be effectively made thread-safe without interface changes. These routines are designated by the "_r" suffix added to the traditional function name they replace, for example, getlogin_r for getlogin.</p>
<p class=book><b>getlogin_r</b></p>
<p class=book>int getlogin_r (</p>
<p class=book>char *name,</p>
<p class=book>size_t namesize);</p>
<p class=book>Write the user name associated with the current process into the buffer pointed to by name. The buffer is namesize bytes long, and should have space for the name and a terminating null character. The maximum size of the login name is LOGIN_</p>
<p class=book>NAME_MAX.</p>
<p class=book>References: 6.5.1 Headers: &lt;unistd.h&gt;</p>
<p class=book><b>readdir_r</b></p>
<p class=book>int readdir_r (</p>
<p class=book>DIR *dirp,</p>
<p class=book>struct dirent *entry, struct dirent **result);</p>
<p class=book>Return a pointer (result) to the directory entry at the current position in the directory stream to which dirp refers. Whereas readdir retains the current position using a static variable, readdir_r uses the entry parameter, supplied by the caller.</p>
<p class=book>References: 6.5.2</p>
<p class=book>Headers: &lt;sys/types.h&gt;, &lt;dirent.h&gt;</p>
<p class=book>Errors: <b>[EBADF</b>] dirp is not an open directory stream.</p>
<p class=book><b>strtok_r</b></p>
<p class=book>char *strtok_r (</p>
<p class=book>char *s,</p>
<p class=book>const char *sep,</p>
<p class=book>char **lasts);</p>
<p class=book>Return a pointer to the next token in the strings. Whereas strtok retains the current position within a string using a static variable, strtok_r uses the lasts parameter, supplied by the caller.</p>
<p class=book>References: 6.5.3 Headers: &lt;string.h&gt;</p>
<p class=book><b>asctime_r</b></p>
<p class=book>char *asctime_r (</p>
<p class=book>const struct tm*tm,</p>
<p class=book>char *buf);</p>
<p class=book>Convert the "broken-down" time in the structure pointed to by tm into a string, which is stored in the buffer pointed to by buf. The buffer pointed to by buf must</p>
<p class=book>contain at least 26 bytes. The function returns a pointer to the buffer on success, or NULL on failure.</p>
<p class=book>References: 6.5.4 Headers: &lt;time.h&gt;</p>
<p class=book><b>ctime_r</b></p>
<p class=book>char *ctime_r (</p>
<p class=book>const time_t *clock, char *buf);</p>
<p class=book>Convert the calendar time pointed to by clock into a string representing the local time, which is stored in the buffer pointed to by buf. The buffer pointed to by buf must contain at least 26 bytes. The function returns a pointer to the buffer on success, or NULL on failure.</p>
<p class=book>References: 6.5.4 Headers: &lt;time.h&gt;</p>
<p class=book><b>gmtime_r</b></p>
<p class=book>struct tm *gmtime_r (</p>
<p class=book>const time_t *clock, struct tm *result);</p>
<p class=book>Convert the calendar time pointed to by clock into a "broken-down time" expressed as Coordinated Universal Time (UTC), which is stored in the structure pointed to by result. The function returns a pointer to the structure on success, or NULL on failure.</p>
<p class=book>References: 6.5.4 Headers: &lt;time.h&gt;</p>
<p class=book><b>localtime_r</b></p>
<p class=book>struct tm *localtime_r (</p>
<p class=book>const time_t *clock, struct tm *result);</p>
<p class=book>Convert the calendar time pointed to by clock into a "broken-down time" expressed as local time, which is stored in the structure pointed to by result. The function returns a pointer to the structure on success, or NULL on failure.</p>
<p class=book>References: 6.5.4 Headers: &lt;time.h&gt;</p>
<p class=book><b>rand_r</b></p>
<p class=book>int rand_r (</p>
<p class=book>unsigned int *seed);</p>
<p class=book>Return the next value in a sequence of pseudorandom integers in the range of <b>0</b> to RAND_MAX. Whereas rand uses a static variable to maintain the context between a series of calls, rand_r uses the value pointed to by seed, which is supplied by the caller.</p>
<p class=book>References: 6.5.5 Headers: &lt;stdlib.h&gt;</p>
<p class=book><b>getgrgid_r</b></p>
<p class=book>int getgrgid_r (</p>
<p class=book>gid_t gid,</p>
<p class=book>struct group *group,</p>
<p class=book>char *buffer,</p>
<p class=book>size_t bufsize,</p>
<p class=book>struct group **result);</p>
<p class=book>Locate an entry from the group database with a group id matching the gid argument. The group entry is stored in the memory pointed to by buffer, which contains bufsize bytes, and a pointer to the entry is stored at the address pointed to by result. The maximum buffer size required can be determined by calling sysconf with the _SC_GETGR_R_SIZE_MAX parameter.</p>
<p class=book>References: 6.5.6</p>
<p class=book>Headers: &lt;sys/types.h&gt;,&lt;grp.h&gt;</p>
<p class=book>Errors: [ERANGE] the specified buffer is too small.</p>
<p class=book><b>| getgrnam</b></p>
<p class=book><b>r</b></p>
<p class=book>int getgrnam_r (</p>
<p class=book>const char *name,</p>
<p class=book>struct group *group,</p>
<p class=book>char *buffer,</p>
<p class=book>size_t bufsize,</p>
<p class=book>struct group **result);</p>
<p class=book>Locate an entry from the group database with a group name matching the name argument. The group entry is stored in the memory pointed to by buffer, which contains bufsize bytes, and a pointer to the entry is stored at the address pointed to by result. The maximum buffer size required can be determined by calling sysconf with the _SC_GETGR_R<b>_SIZE</b>_MAX parameter.</p>
<p class=book>References: 6.5.6 Headers: &lt;sys/types.h&gt;, &lt;grp.h&gt;</p>
<p class=book>Errors: [ERANGE] the specified buffer is too small.</p>
<p class=book><b>getpwuid_r</b></p>
<p class=book>int getpwuid_r (</p>
<p class=book>uid_t uid,</p>
<p class=book>struct passwd *pwd,</p>
<p class=book>char *buffer,</p>
<p class=book>size_t bufsize,</p>
<p class=book>struct passwd **result);</p>
<p class=book>Locate an entry from the user database with a user id matching the uid argument. The user entry is stored in the memory pointed to by buffer, which contains bufsize bytes, and a pointer to the entry is stored at the address pointed to by result. The maximum buffer size required can be determined by calling sysconf with the _SC_GETPW_R_SIZE_MAX parameter.</p>
<p class=book>References: 6.5.6</p>
<p class=book>Headers: &lt;sys/types.h&gt;, &lt;pwd.h&gt;</p>
<p class=book>Errors: [ERANGE ] the specified buffer is too small.</p>
<p class=book><b>getpwnam_r</b></p>
<p class=book>int getpwnam_r (</p>
<p class=book>const char *name,</p>
<p class=book>struct passwd *pwd,</p>
<p class=book>char *buffer,</p>
<p class=book>size_t bufsize,</p>
<p class=book>struct passwd **result);</p>
<p class=book>Locate an entry from the user database with a user name matching the name argument. The user entry is stored in the memory pointed to by buffer, which contains bufsize bytes, and a pointer to the entry is stored at the address pointed to by result. The maximum buffer size required can be determined by calling sysconf with the _SC_GETPW_R_SIZE_MAX parameter.</p>
<p class=book>References: 6.5.6</p>
<p class=book>Headers: &lt;sys/types.h&gt;, &lt;pwd.h&gt;</p>
<p class=book>Errors: [ERANGE] the specified buffer is too small.</p>


<a name=t150></a><h3 class=book>
9.3.12 Signals
</h3>
<p class=book>Pthreads provides functions that extend the POSIX signal model to support multithreaded processes. All threads in a process share the same signal actions. Each thread has its own pending and blocked signal masks. The process also has a pending signal mask so that asynchronous signals can pend against the process when all threads have the signal blocked. In a multithreaded process, the behavior of sigprocmask is undefined.</p>
<p class=book><b>pthread_kill</b></p>
<p class=book>int pthread_kill (</p>
<p class=book>pthread_t thread,</p>
<p class=book>int sig) ;</p>
<p class=book>Request that the signal sig be delivered to thread. If sig is 0, no signal is sent, but error checking is performed. If the action of the signal is to terminate, stop, or continue, then the entire process is affected.</p>
<p class=book>References: 6.6.3 Headers: &lt;signal.h&gt;</p>
<p class=book>Errors: <b>[ESRCH]</b> no thread corresponding to thread.</p>
<p class=book>[EINVAL] sig is an invalid signal number. Hint: To terminate a thread, use cancellation.</p>
<p class=book><b>pthread_sigmask</b></p>
<p class=book>int pthread_sigmask (</p>
<p class=book>int how,</p>
<p class=book>const sigset_t *set,</p>
<p class=book>sigset_t *oset);</p>
<p class=book>Control the masking of signals within the calling thread.</p>
<p class=book><b>how</b></p>
<p class=book>References: 6.6.2 Headers: &lt;signal.h&gt;</p>
<p class=book>Errors: [EINVAL] how is not one of the defined values.</p>
<p class=book>Hint: You cannot prevent delivery of asynchronous signals to the process</p>
<p class=book>unless the signal is blocked in all threads.</p>
<p class=book><b>sigtimedwait</b></p>
<p class=book>int sigtimedwait (</p>
<p class=book>const sigset_t *set,</p>
<p class=book>siginfo_t *info,</p>
<p class=book>const struct timespec *timeout);</p>
<p class=book>If a signal in set is pending, atomically clear it from the set of pending signals and return the signal number in the si_signo member of <i>info.</i> The cause of the signal</p>
<TABLE>
<TR>
<TD align = "left"  colspan = "3" ><b>how</b></TD>
</TR>
<TR>
<TD align = "left" ><b>SIG_</b></TD>
<TD align = "left" ><b>BLOCK</b></TD>
<TD align = "left" >Resulting set is the union of the</TD>
</TR>
<TR>
<TD></TD>
<TD></TD>
<TD align = "left" >current set and the argument set.</TD>
</TR>
<TR>
<TD align = "left" ><b>SIG_</b></TD>
<TD align = "left" ><b>UNBLOCK</b></TD>
<TD align = "left" >Resulting set is the intersection of</TD>
</TR>
<TR>
<TD></TD>
<TD></TD>
<TD align = "left" >the current set and the argument</TD>
</TR>
<TR>
<TD></TD>
<TD></TD>
<TD align = "left" >set.</TD>
</TR>
<TR>
<TD align = "left" ><b>SIG_</b></TD>
<TD align = "left" ><b>_SETMASK</b></TD>
<TD align = "left" >Resulting set is the set pointed to</TD>
</TR>
<TR>
<TD></TD>
<TD></TD>
<TD align = "left" >by the argument set.</TD>
</TR>
</TABLE>
<p class=book>shall be stored in the si_code member. If any value is queued to the selected signal, return the first queued value in the si_value member. If no signal in set is pending, suspend the calling thread until one or more become pending. If the time interval specified by timeout passes, sigtimedwait will return with the error EAGAIN. This function returns the signal number—on error, it returns -1 and sets errno to the appropriate error code.</p>
<p class=book>References: 6.6.4 Headers: &lt;signal.h&gt;</p>
<p class=book>Errors: [EINVAL] set contains an invalid signal number.</p>
<p class=book><b>[EAGAIN]</b> the timeout interval passed.</p>
<p class=book><b>[ENOSYS]</b> realtime signals are not supported. Hint: Use only for asynchronous signal delivery. All signals in set must</p>
<p class=book>be masked in the calling thread, and should usually be masked in</p>
<p class=book>all threads.</p>
<p class=book><b>sigwait</b></p>
<p class=book>int sigwait (</p>
<p class=book>const sigset_t *set, int *sig);</p>
<p class=book>If a signal in set is pending, atomically clear it from the set of pending signals and return the signal number in the location referenced by sig. If no signal in set is pending, suspend the calling thread until one or more become pending.</p>
<p class=book>References: 6.6.4 Headers: &lt;signal.h&gt;</p>
<p class=book>Errors: [EINVAL] set contains an invalid signal number.</p>
<p class=book>Hint: Use only for asynchronous signal delivery. All signals in set must</p>
<p class=book>be masked in the calling thread, and should usually be masked in</p>
<p class=book>all threads.</p>
<p class=book><b>sigwaitinfo</b></p>
<p class=book>int sigwaitinfo (</p>
<p class=book>const sigset_t *set, siginfo_t *info);</p>
<p class=book>If a signal in set is pending, atomically clear it from the set of pending signals and return the signal number in the si_signo member of <i><b>info.</b></i> The cause of the signal shall be stored in the si_code member. If any value is queued to the selected signal, return the first queued value in the si_value member. If no signal in set is pending, suspend the calling thread until one or more become pending. This function returns the signal number—on error, it returns -1 and sets errno to the appropriate error code.</p>
<p class=book>References: 6.6.4 Headers: &lt;signal.h&gt;</p>
<p class=book>Errors: [EINVAL] set contains an invalid signal number.</p>
<p class=book><b>[ENOSYS]</b> realtime signals are not supported. Hint: Use only for asynchronous signal delivery. All signals in set must</p>
<p class=book>be masked in the calling thread, and should usually be masked in</p>
<p class=book>all threads.</p>


<a name=t151></a><h3 class=book>
9.3.13 Semaphores
</h3>
<p class=book>Semaphores come from POSIX.1b (POSIX 1003.1b-1993) rather than from Pthreads. They follow the older UNIX convention for reporting errors. That is, on failure they return a value of <b>-1</b> and store the appropriate error number into errno. All of the semaphore functions require the header file &lt;semaphore.h&gt;.</p>
<p class=book><b>sem_destroy....................................................................................................[_POSIX_SEMAPHORES</b>]</p>
<p class=book>int sem_destroy (</p>
<p class=book>sem_t *sem);</p>
<p class=book>Destroy an unnamed semaphore.</p>
<p class=book>References: 6.6.6 Headers: &lt;semaphore.h&gt;</p>
<p class=book>Errors: <b>[EINVAL]</b> value exceeds SEM_VALUE_MAX.</p>
<p class=book><b>[ENOSYS]</b> semaphores are not supported.</p>
<p class=book>[ EBUSY ] threads (or processes) are currently blocked on sem.</p>
<p class=book><b>sem_init............................................................................................................[_POSIX_</b>SEMAPHORES]</p>
<p class=book>int sem_init (</p>
<p class=book>sem_t *sem,</p>
<p class=book>int pshared,</p>
<p class=book>unsigned int value);</p>
<p class=book>Initialize an unnamed semaphore. The initial value of the semaphore counter is value. If the pshared argument has a nonzero value, the semaphore can be shared between processes. With a zero value, it can be shared only between threads in the same process.</p>
<p class=book>References: 6.6.6 Headers: &lt;semaphore.h&gt;</p>
<p class=book>Errors: <b>[EINVAL]</b> sem is not a valid semaphore.</p>
<p class=book><b>[ENOSPC]</b> a required resource has been exhausted.</p>
<p class=book><b>[ENOSYS]</b> semaphores are not supported.</p>
<p class=book><b>[EPERM]</b> the process lacks appropriate privilege. Hint: Use a value of 1 for a lock, a value of 0 for waiting.</p>
<p class=book><b>sem_trywait.....................................................................................................[_POSIX_SEMAPHORES</b> ]</p>
<p class=book>int sem_trywait (</p>
<p class=book>sem_t *sem);</p>
<p class=book>Try to wait on a semaphore (or "try to lock" the semaphore). If the semaphore value is greater than zero, decrease the value by one. If the semaphore value is 0, then return immediately with the error EAGAIN.</p>
<p class=book>References: 6.6.6 Headers: &lt;semaphore.h&gt;</p>
<p class=book>Errors: <b>[EAGAIN]</b> the semaphore was already locked.</p>
<p class=book><b>[EINVAL]</b> sem is not a valid semaphore.</p>
<p class=book>[EINTR] the function was interrupted by a signal.</p>
<p class=book><b>[ENOSYS]</b> semaphores are not supported.</p>
<p class=book>[EDEADLK] a deadlock condition was detected. Hint: When the semaphore's initial value was 1, this is a lock operation;</p>
<p class=book>when the initial value was 0, this is a wait operation.</p>
<p class=book><b>sem_post..........................................................................................................</b>[_<b>POSIX_SEMAPHORES</b> ]</p>
<p class=book>int sem_post (</p>
<p class=book>sem_t *sem);</p>
<p class=book>Post a wakeup to a semaphore. If there are waiting threads (or processes), one is awakened. Otherwise the semaphore value is incremented by one.</p>
<p class=book>References: 6.6.6 Headers: &lt;semaphore.h&gt;</p>
<p class=book>Errors: <b>[EINVAL]</b> sem is not a valid semaphore.</p>
<p class=book><b>[ENOSYS]</b> semaphores are not supported. Hint: May be used from within a signal-handling function.</p>
<p class=book><b>sem_wait..........................................................................................................[_POSIX_SEMAPHORES ]</b></p>
<p class=book>int sem_wait (</p>
<p class=book>sem_t *sem);</p>
<p class=book>Wait on a semaphore (or lock the semaphore). If the semaphore value is greater than zero, decrease the value by one. If the semaphore value is 0, then the calling thread (or process) is blocked until it can successfully decrease the value or until interrupted by a signal.</p>
<p class=book>References: 6.6.6 Headers: &lt;semaphore.h&gt;</p>
<p class=book>Errors: <b>[EINVAL]</b> sem is not a valid semaphore.</p>
<p class=book><b>[EINTR]</b> the function was interrupted by a signal.</p>
<p class=book><b>[ENOSYS]</b> semaphores are not supported.</p>
<p class=book>[EDEADLK] a deadlock condition was detected. Hint: When the semaphore's initial value was 1, this is a lock operation;</p>
<p class=book>when the initial value was 0, this is a wait operation.</p>




<a name=t152></a><h3 class=book>
10 Future standardization
</h3>

<p class=book>Three primary standardization efforts affect Pthreads programmers. X/Open's XSH5 is a new interface specification that includes POSIX.1b, Pthreads, and a set of additional thread functions (part of the Aspen fast-track submission). The POSIX.1j draft standard proposes to add barriers, read/write locks, spinlocks, and improved support for "relative time" waits on condition variables. The POSIX.14 draft standard (a "POSIX Standard Profile") gives direction for managing the various options of Pthreads in a multiprocessor environment.</p>


<a name=t153></a><h3 class=book>
10.1 X/OpenXSH5(UNIX98)
</h3>

<p class=book><b>Mutex type attribute:</b></p>
<p class=book>int pthread_mutexattr_gettype (</p>
<p class=book>const pthread_mutexattr_t *attr, int *type); int pthread_mutexattr_settype (</p>
<p class=book>pthread_mutexattr_t *attr, int type);</p>
<p class=book><b>Read/write locks:</b></p>
<p class=book>int pthread_rwlock_init (pthread_rwlock_t *rwlock,</p>
<p class=book>const pthread_rwlockattr_t *attr); int pthread_rwlock_destroy (pthread_rwlock_t *rwlock); pthread_rwlock_t rwlock = PTHREAD_RWLOCK_INITIALIZER; int pthread_rwlock_rdlock (pthread_rwlock_t *rwlock); int pthread_rwlock_tryrdlock (</p>
<p class=book>pthread_rwlock_t *rwlock); int pthread_rwlock_unlock (pthread_rwlock_t *rwlock); int pthread_rwlock_wrlock (pthread_rwlock_t *rwlock); int pthread_rwlock_trywrlock (</p>
<p class=book>pthread_rwlock_t *rwlock); int pthread_rwlockattr_init (</p>
<p class=book>pthread_rwlockattr_t *attr); int pthread_rwlockattr_destroy (</p>
<p class=book>pthread_rwlockattr_t *attr); int pthread_rwlockattr_getpshared (</p>
<p class=book>const pthread_rwlockattr_t *attr, int *pshared); int pthread_rwlockattr_setpshared (</p>
<p class=book>pthread_rwlockattr_t *attr, int pshared);</p>
<p class=book><b>Parallel I/O:</b></p>
<p class=book>size_t pread (int fildes,</p>
<p class=book>void *buf, size_t nbyte, off_t offset); size_t pwrite (int fildes,</p>
<p class=book>const void *buf, size_t nbyte, off_t offset);</p>
<p class=book><b>Miscellaneous:</b></p>
<p class=book>int pthread_attr_getguardsize (</p>
<p class=book>const pthread_attr_t *attr, size_t *guardsize); int pthread_attr_setguardsize (</p>
<p class=book>pthread_attr_t *attr, size_t guardsize); int pthread_getconcurrency (); int pthread_setconcurrency (int new_level);</p>
<p class=book>X/Open, which is part of The Open Group, owns the UNIX trademark and develops UNIX industry portability specifications and brands. The X/Open brands include XPG3, XPG4, UNLX93, and UNLX95. UNLX95 is also known as "SPEC1170" or the "Single UNIX Specification."</p>
<p class=book>X/Open recently published the <i>X/Open CAE Specification, System Interfaces and Headers, Issue 5</i> (also known as XSH5), which is part of the new UNLX98 brand. XSH5 requires conformance to the POSIX.1-1996 standard, which includes the POSIX.1b and POSIX.1c amendments. The XSH5 specification also adds a set of extensions to POSIX. This section discusses the XSH5 extensions that specifically affect threaded programs. You can recognize a system conforming to XSH5 by a definition for the <b>_XOPEN_VERSION</b> symbol, in &lt;unistd.h&gt;, to the value 500 or higher.</p>
<p class=book>The most valuable contribution of UNLX98 to the threaded programming industry, however, is possibly the development of a standardized, portable testing system. A number of complicated issues arise when developing an implementation of Pthreads, and some subtle aspects of the standard are ambiguous. Such an industry-wide testing system will require all vendors implementing UNLX98 branded systems to agree on interpretations of Pthreads.</p>


<a name=t154></a><h3 class=book>
10.1.1 POSIX options for XSH5
</h3>
<p class=book>Some of the features that are options in the Pthreads standard are required by XSH5. If your code relies on these Pthreads options, it will work on any system conforming to XSH5:</p>
<p class=book>• <b>_POSIX_THREADS:</b> Threads are supported.</p>
<p class=book>• <b>_POSIX_THREAD_ATTR_STACKADDR:</b> The stackaddr attribute is supported.</p>
<p class=book>• <b>_POSIX_THREAD_ATTR_STACKSIZE:</b> The <i>stacksize</i> attribute is supported.</p>
<p class=book>• <b>_POSIX_THREAD_PROCESS_SHARED:</b> Mutexes, condition variables, and XSH5 read/write locks can be shared between processes.</p>
<p class=book>• _POSIX_THREAD_SAFE_FUNCTIONS: The Pthreads thread-safe functions are supported.</p>
<p class=book>Several additional Pthreads options are "bundled" into the XSH5 realtime threads option group. If your system conforms to XSH5 and supports the _XOPEN_ REALTIME_THREADS option, then these Pthreads options are also supported:</p>
<p class=book>• _POSIX_THREAD_PRIORITY_SCHEDULING: Realtime priority scheduling is supported.</p>
<p class=book>• _POSIX_THREAD_PRIO_PROTECT: Priority ceiling mutexes are supported.</p>
<p class=book>• _POSIX_THREAD_PRIO_INHERIT: Priority inheritance mutexes are supported.</p>


<a name=t155></a><h3 class=book>
10.1.2 Mutex type
</h3>
<p class=book>The DCE threads package provided an extension that allowed the programmer to specify the "kind" of mutex to be created. DCE threads supplied <i>fast, recursive,</i> and <i>nonrecursive</i> mutex kinds. The XSH5 specification changes the attribute name from "kind" to "type," renames fast to <i>default,</i> renames <i>nonrecursive</i> to <i>errorcheck,</i> and adds a new type, <i>normal</i> (Table 10.1).</p>
<p class=book>A <i>normal</i> mutex is not allowed to detect deadlock errors — that is, a thread will hang if it tries to lock a <i>normal</i> mutex that it already owns. The <i>default</i> mutex type, like the DCE fast mutex,<sup><a name=r11><a href="#n11" title="
 DCE threads implemented fast mutexes much like the definition of XSH5 normal mutexes, with no error checking. This was not, however, specification of intent.
">[11]</sup></A> provides implementation-defined error checking. That is, <i>default</i> may be mapped to one of the other standard types or may be something entirely different.</p>
<TABLE>
<TR>
<TD align = "left" ><b>Mutex type</b></TD>
<TD align = "left" > <b>Definition</b></TD>
</TR>
<TR>
<TD align = "left" >PTHREAD_MUTEX_NORMAL</TD>
<TD align = "left" >Basic mutex with no specific error checking built in. Does not report a deadlock error.</TD>
</TR>
<TR>
<TD align = "left" >PTHREAD__MUTEX__RECURSIVE</TD>
<TD align = "left" >Allows any thread to lock the mutex "recursively" — it must unlock an equal number of times to release the mutex.</TD>
</TR>
<TR>
<TD align = "left" >PTHREAD_MUTEX_ERRORCHECK</TD>
<TD align = "left" >Detects and reports simple usage errors — an attempt to unlock a mutex that's not locked by the calling thread (or that isn't locked at all), or an attempt to relock a mutex the thread already owns.</TD>
</TR>
<TR>
<TD align = "left" >PTHREAD__MUTEX__DEFAULT</TD>
<TD align = "left" >The default mutex type, with very loose semantics to allow unfettered innovation and experimentation. May be mapped to any of the other three defined types, or may be something else entirely.</TD>
</TR>
</TABLE>
<p class=book><b>TABLE 10.1</b> <i>XSH5 mutex types</i></p>
<br>
<p class=book>As an application developer, you can use any of the mutex types almost interchangeably as long as your code does not depend on the implementation to detect (or fail to detect) any particular errors. Never write code that counts on an implementation <i>Jailing</i> to detect any error. Do not lock a mutex in one thread and unlock it in another thread, for example, even if you are sure that the error won't be reported — use a semaphore instead, which has no "ownership" semantics.</p>
<p class=book>All mutexes, regardless of type, are created using pthread_mutex_init, destroyed using pthread_mutex_destroy, and manipulated using pthread_mutex_ lock, pthread_mutex_unlock, and pthread_mutex_trylock.</p>
<p class=book><i>Normal</i> mutexes will usually be the fastest implementation possible for the machine, but will provide the least error checking.</p>
<p class=book><i>Recursive</i> mutexes are primarily useful for converting old code where it is difficult to establish clear boundaries of synchronization, for example, when you must call a function with a mutex locked and the function you call — or some function it calls — may need to lock the same mutex. I have never seen a situation where recursive mutexes were <i>required</i> to solve a problem, but I have seen many cases where the alternate (and usually "better") solutions were impractical. Such situations frequently lead developers to create recursive mutexes, and it makes more sense to have a single implementation available to everyone. (But your code will usually be easier to follow, and perform better, if you avoid recursive mutexes.)</p>
<p class=book><i>Errorcheck</i> mutexes were devised as a debugging tool, although less intrusive debugging tools (where available) can be more powerful. To use errorcheck mutexes you must recompile code to turn the debugging feature on and off. It is far more useful to have an external option to force all mutexes to record debugging data. You may want to use errorcheck mutexes in final "production" code, of course, to detect serious problems early, but be aware that errorcheck mutexes will almost always be much slower than normal mutexes due to the extra state and checking.</p>
<p class=book><i>Default</i> mutexes allow each implementation to provide the mutex semantics the vendor feels will be most useful to the target audience. It may be useful to make <i>errorcheck</i> mutexes the default, for example, to improve the threaded debugging environment of a system. Or the vendor may choose to make <i>normal</i> mutexes the default to give most programs the benefit of any extra speed.</p>
<p class=book><b>| pthread_mutexaftr_gettype</b></p>
<p class=book>int pthread_mutexattr_gettype (</p>
<p class=book>const pthread_mutexattr_t *attr,</p>
<p class=book>int *type);</p>
<p class=book>Specify the type of mutexes created with attr.</p>
<p class=book>type</p>
<p class=book>Unspecified type.</p>
<p class=book>Basic mutex, with no error</p>
<p class=book>checking.</p>
<p class=book>PTHREAD_MUTEX_RECURSIVE Thread can relock a mutex it</p>
<p class=book>owns.</p>
<p class=book>PTHREAD_MUTEX_ERRORCHECK Checks for usage errors.</p>
<p class=book>References: 3.2,5.2.1,10.1.2</p>
<p class=book>Errors: [EINVAL] type invalid.</p>
<p class=book>[EINVAL] attr invalid.</p>
<p class=book>Hint: <i>Normal</i> mutexes will usually be fastest; <i>errorcheck</i> mutexes are use-</p>
<p class=book>ful for debugging; <i>recursive</i> mutexes can be useful for making old interfaces thread-safe.</p>
<p class=book><b>PTHREAD_MUTEX_DEFAULT</b></p>
<p class=book>PTHREAD_MUTEX_NORMAL</p>
<p class=book><b>pthread_mutexattr_settype</b></p>
<p class=book>int pthread_mutexattr_settype (</p>
<p class=book>pthread_mutexattr_t int</p>
<p class=book>*attr, type);</p>
<p class=book>Determine the type of mutexes created with attr.</p>
<p class=book>type</p>
<p class=book><b>PTHREAD_MUTEX_DEFAULT</b> Unspecified type.</p>
<p class=book>PTHREAD_MUTEX_NORMAL</p>
<p class=book>Basic mutex, with no error checking.</p>
<p class=book>PTHREAD_MUTEX_RECURSIVE Thread can relock a mutex it</p>
<p class=book>owns.</p>
<p class=book>PTHREAD_MUTEX_ERRORCHECK Checks for usage errors.</p>
<p class=book>References: 3.2,5.2.1,10.1.2</p>
<p class=book>Errors: <b>[EINVAL]</b> type invalid.</p>
<p class=book>[EINVAL] attr invalid.</p>
<p class=book>Hint: <i>Normal</i> mutexes will usually be fastest; <i>errorcheck</i> mutexes are use-</p>
<p class=book>ful for debugging; <i>recursive</i> mutexes can be useful for making old interfaces thread-safe.</p>


<a name=t156></a><h3 class=book>
10.1.3 Set concurrency level
</h3>
<p class=book>When you use Pthreads implementations that schedule user threads onto some smaller set of kernel entities (see Section 5.6.3), it may be possible to have <i>ready</i> user threads while all kernel entities allocated to the process are busy.</p>
<p class=book>Some implementations, for example, "lock" a kernel entity to a user thread that blocks in the kernel, until the blocking condition, for example an I/O request, is completed. The system will create some reasonable number of kernel execution entities for the process, but eventually the pool of kernel entities may become exhausted. The process may be left with threads capable of performing useful work for the application, but no way to schedule them.</p>
<p class=book>The pthread_setconcurrency function addresses this limitation by allowing the application to ask for more kernel entities. If the application designer realizes that 10 out of 15 threads may at any time become blocked in the kernel, and it is important for those other 5 threads to be able to continue processing, then the application may request that the kernel supply 15 kernel entities. If it is important that at least 1 of those 5 continue, but not that all continue, then the application could request the more conservative number of 11 kernel entities. Or if it is OK for all threads to block once in a while, but not often, and you know that only rarely will more than 6 threads block at any time, the application could request 7 kernel entities.</p>
<p class=book>The pthread_setconcurrency function is a hint, and implementations may ignore it or modify the advice. You may use it freely on any system that conforms to the UNLX98 brand, but many systems will do nothing more than set a value that is returned by pthread_getconcurrency. On Digital UNIX, for example, there is no need to set a fixed concurrency level, because the kernel mode and user mode schedulers cooperate to ensure that ready user threads cannot be prevented from running by other threads blocked in the kernel.</p>
<p class=book><b>pthread_getconcurrency</b></p>
<p class=book>int pthread_getconcurrency ();</p>
<p class=book>Returns the value set by a previous pthread_setconcurrency call. If there have been no previous calls to pthread_setconcurrency, returns 0 to indicate that the implementation is maintaining the concurrency level automatically.</p>
<p class=book>References: 5.6.3, 10.1.3 Errors: none.</p>
<p class=book>Hint: Concurrency level is a hint. It may be ignored by any implementa-</p>
<p class=book>tion, and <i>will</i> be ignored by an implementation that does not need it to ensure concurrency.</p>
<p class=book><b>pthread_setconcurrency</b></p>
<p class=book>int pthread_getconcurrency (int new_level);</p>
<p class=book>Allows the application to inform the threads implementation of its desired minimum concurrency level. The actual level of concurrency resulting from this call is unspecified.</p>
<p class=book>References: 5.6.3, 10.1.3</p>
<p class=book>Errors: [EINVAL] new_level is negative.</p>
<p class=book><b>[EAGAIN]</b> new_level exceeds a system resource.</p>
<p class=book>Hint: Concurrency level is a hint. It may be ignored by any implementa-</p>
<p class=book>tion, and <i>will</i> be ignored by an implementation that does not need it to ensure concurrency.</p>


<a name=t157></a><h3 class=book>
10.1.4 Stack guard size
</h3>
<p class=book>Guard size comes from DCE threads. Most thread implementations add to the thread's stack a "guard" region, a page or more of protected memory. This protected page is a safety zone, to prevent a stack overflow in one thread from corrupting another thread's stack. There are two good reasons for wanting to control a thread's guard size:</p>
<p class=book>1. It allows an application or library that allocates large data arrays on the stack to increase the default guard size. For example, if a thread allocates two pages at once, a single guard page provides little protection against stack overflows — the thread can corrupt adjoining memory without touching the protected page.</p>
<p class=book>2. When creating a large number of threads, it may be that the extra page for each stack can become a severe burden. In addition to the extra page, the kernel's memory manager has to keep track of the differing protection on adjoining pages, which may strain system resources. Therefore, you may sometimes need to ask the system to "trust you" and avoid allocating any guard pages at all for your threads. You can do this by requesting a guard size of 0 bytes.</p>
<p class=book><b>pthread_attr_getguardsize</b></p>
<p class=book>int pthread_attr_getguardsize (</p>
<p class=book>const pthread_attr_t *attr, size_t *guardsize);</p>
<p class=book>Determine the size of the guard region for the stack on which threads created with attr will run.</p>
<p class=book>References: 2, 5.2.3</p>
<p class=book>Errors: [EINVAL] attr invalid.</p>
<p class=book>Hint: Specify 0 to fit lots of stacks in an address space, or increase default</p>
<p class=book>guardsize for threads that allocate large buffers on the stack.</p>
<p class=book><b>pthread_attr_setguardsize</b></p>
<p class=book>int pthread_attr_setguardsize (</p>
<p class=book>pthread_attr_t *attr,</p>
<p class=book>size_t guardsize);</p>
<p class=book>Threads created with attr will run on a stack with guardsize bytes protected against stack overflow. The implementation may round guardsize up to the next multiple of PAGESIZE. Specifying a value of 0 for guardsize will cause threads created using the attributes object to run without stack overflow protection.</p>
<p class=book>References: 2, 5.2<b>.3</b></p>
<p class=book>Errors: [EINVAL] guardsize or attr invalid.</p>
<p class=book>Hint: Specify 0 to fit lots of stacks in an address space, or increase default</p>
<p class=book>guardsize for threads that allocate large buffers on the stack.</p>


<a name=t158></a><h3 class=book>
10.1.5 Parallel I/O
</h3>
<p class=book>Many high-performance systems, such as database engines, use threads, at least in part, to gain performance through parallel I/O. Unfortunately, Pthreads doesn't directly support parallel I/O. That is, two threads can independently issue I/O operations for files, or even for the same file, but the POSIX file I/O model places some restrictions on the level of parallelism.</p>
<p class=book>One bottleneck is that the current file position is an attribute of the file descriptor. To read or write data from or to a specific position within a file, a thread must call lseek to seek to the proper byte offset in the file, and then read or write. If more than one thread does this at the same time, the first thread might seek, and then the second thread seek to a different place before the first thread can issue the read or write operation.</p>
<p class=book>The X/Open pread and pwrite functions offer a solution, by making the seek and read or write combination atomic. Threads can issue pread or pwrite operations in parallel, and, in principle, the system can process those I/O requests completely in parallel without locking the file descriptor.</p>
<p class=book><b>pread</b></p>
<p class=book>size_t pread (</p>
<p class=book>int fildes,</p>
<p class=book>void *buf,</p>
<p class=book>size_t nbyte,</p>
<p class=book>off_t offset);</p>
<p class=book>Read nbyte bytes from offset offset in the file opened on file descriptor fildes, placing the result into buf. The file descriptor's current offset is not affected, allowing multiple pread and/or pwrite operations to proceed in parallel.</p>
<p class=book>References: none</p>
<p class=book>Errors: <b>[EINVAL</b>]offsetisnegative.</p>
<p class=book><b>[EOVERFLOW]</b> attempt to read beyond maximum.</p>
<p class=book><b>[ENXIO]</b> request outside capabilities of device.</p>
<p class=book><b>[ESPiPE]</b> file is pipe. Hint: Allows high-performance parallel I/O.</p>
<p class=book><b>pwrite</b></p>
<p class=book>size_t pwrite (</p>
<p class=book>int fildes,</p>
<p class=book>const void *buf,</p>
<p class=book>size_t nbyte,</p>
<p class=book>off_t offset);</p>
<p class=book>Write nbyte bytes to offset offset in the file opened on file descriptor fildes, from buf. The file descriptor's current offset is not affected, allowing multiplepread and/ or pwrite operations to proceed in parallel.</p>
<p class=book>References: none</p>
<p class=book>Errors: <b>[EINVAL]</b> offset is negative.</p>
<p class=book><b>[ESPIPE]</b> file is pipe. Hint: Allows high-performance parallel I/O.</p>


<a name=t159></a><h3 class=book>
10.1.6 Cancellation points
</h3>
<p class=book>Most UNIX systems support a substantial number of interfaces that do not come from POSIX. The select and poll interfaces, for example, should be deferred cancellation points. Pthreads did not require these functions to be cancellation points, however, because they do not exist within POSIX. 1.</p>
<p class=book>The select and poll functions, however, along with many others, exist in X/Open. The XSH5 standard includes an expanded list of cancellation points covering X/Open interfaces.</p>
<p class=book>Additional functions that must be cancellation points in XSH5:</p>
<p class=book>getmsg pread sigpause</p>
<p class=book>getpmsg putmsg usleep</p>
<p class=book>lockf putpmsg wait3</p>
<p class=book>msgrcv pwrite waitid</p>
<p class=book>msgsnd readv writev</p>
<p class=book>poll select</p>
<p class=book>Additional functions that may be cancellation points in XSH5:</p>
<p class=book><b>Condition variable wait clock:</b></p>
<p class=book>int pthread_condattr_getclock (</p>
<p class=book>const pthread_condattr_t *attr,</p>
<p class=book>clockid_t *clock_id); int pthread_condattr_setclock (</p>
<p class=book>pthread_condattr_t *attr,</p>
<p class=book>clockid_t clock_id);</p>
<p class=book><b>Barriers:</b></p>
<p class=book>int barrier_attr_init (barrier_attr_t *attr); int barrier_attr_destroy (barrier_attr_t *attr); int barrier_attr_getpshared (</p>
<p class=book>const barrier_attr_t *attr, int *pshared); int barrier_attr_setpshared (</p>
<p class=book>barrier_attr_t *attr, int pshared); int barrier_init (barrier_t *barrier,</p>
<p class=book>const barrier_attr_t *attr, int count); int barrier_destroy (barrier_t *barrier); int barrier_wait (barrier_t *barrier);</p>
<p class=book>catclose</p>
<p class=book>catgets</p>
<p class=book>catopen</p>
<p class=book>closelog</p>
<p class=book>dbm_close</p>
<p class=book>dbm_delete</p>
<p class=book>dbm_fetch</p>
<p class=book>dbm_nextkey</p>
<p class=book>dbm_open</p>
<p class=book>dbm_store</p>
<p class=book>dlclose</p>
<p class=book>dlopen</p>
<p class=book>endgrent</p>
<p class=book>endpwent</p>
<p class=book>endutxent</p>
<p class=book>fgetwc</p>
<p class=book>fgetws</p>
<p class=book>fputwc</p>
<p class=book>fputws</p>
<p class=book>fseeko</p>
<p class=book>fsetpos</p>
<p class=book>ftello</p>
<p class=book>ftw</p>
<p class=book>fwprintf</p>
<p class=book>fwscanf</p>
<p class=book>getgrent</p>
<p class=book>getpwent</p>
<p class=book>getutxent</p>
<p class=book>getutxid</p>
<p class=book>getutxline</p>
<p class=book>getw</p>
<p class=book>getwc</p>
<p class=book>getwchar</p>
<p class=book>iconv_close</p>
<p class=book>iconv_open</p>
<p class=book>ioctl</p>
<p class=book>mkstemp</p>
<p class=book>nftw</p>
<p class=book>openlog</p>
<p class=book>pclose</p>
<p class=book>popen</p>
<p class=book>pututxline</p>
<p class=book>putw</p>
<p class=book>putwc</p>
<p class=book>putwchar</p>
<p class=book>readdir_r</p>
<p class=book>seekdir</p>
<p class=book>semop</p>
<p class=book>setgrent</p>
<p class=book>setpwent</p>
<p class=book>setutxent</p>
<p class=book>syslog</p>
<p class=book>ungetwc</p>
<p class=book>vfprintf</p>
<p class=book>vfwprintf</p>
<p class=book>vprintf</p>
<p class=book>vwprintf</p>
<p class=book>wprintf</p>
<p class=book>wscanf</p>
<p class=book>10.2 POSIX 1003.1j</p>
<p class=book><b>Reader/writer locks:</b></p>
<p class=book>int rwlock_attr_init (rwlock_attr_t *attr); int rwlock_attr_destroy (rwlock_attr_t *attr); int rwlock_attr_getpshared (</p>
<p class=book>const rwlock_attr_t *attr, int *pshared); int rwlock_attr_setpshared (</p>
<p class=book>rwlock_attr_t *attr, int pshared); int rwlock_init (</p>
<p class=book>rwlock_t *lock, const rwlock_attr_t *attr); int rwlock_destroy (rwlock_t *lock); int rwlock_rlock (rwlock_t *lock); int rwlock_timedrlock (rwlock_t *lock,</p>
<p class=book>const struct timespec *timeout); int rwlock_tryrlock (rwlock_t *lock); int rwlock_wlock (rwlock_t *lock); int rwlock_timedwlock (rwlock_t *lock,</p>
<p class=book>const struct timespec *timeout); int rwlock_trywlock (rwlock_t *lock); int rwlock_unlock (rwlock_t *lock);</p>
<p class=book><b>Spinlocks:</b></p>
<p class=book>int spin_init (spinlock_t *lock);</p>
<p class=book>int spin_destroy (spinlock_t *lock);</p>
<p class=book>int spin_lock (spinlock_t *lock);</p>
<p class=book>int spin_trylock (spinlock_t *lock);</p>
<p class=book>int spin_unlock (spinlock_t *lock);</p>
<p class=book>int pthread_spin_init (pthread_spinlock_t *lock);</p>
<p class=book>int pthread_spin_destroy (pthread_spinlock_t *lock);</p>
<p class=book>int pthread_spin_lock (pthread_spinlock_t *lock);</p>
<p class=book>int pthread_spin_trylock (pthread_spinlock_t *lock);</p>
<p class=book>int pthread_spin_unlock (pthread_spinlock_t *lock);</p>
<p class=book><b>Thread abort:</b></p>
<p class=book>int pthread_abort (pthread_t thread);</p>
<p class=book>The same POSIX working group that developed POSIX. lb and Pthreads has developed a new set of extensions for realtime and threaded programming. Most of the extensions relevant to threads (and to this book) are the result of proposals developed by the POSIX 1003.14 profile group, which specialized in "tuning" the existing POSIX standards for multiprocessor systems.</p>
<p class=book>POSIX. lj adds some thread synchronization mechanisms that have been common in a wide range of multiprocessor and thread programming, but that had been omitted from the original Pthreads standard. Barriers and spinlocks are primarily useful for flne-grained parallelism, for example, in systems that automatically</p>
<p class=book>generate parallel code from program loops. Read/write locks are useful in shared data algorithms where many threads are allowed to read simultaneously, but only one thread can be allowed to update data.</p>


<a name=t160></a><h3 class=book>
10.2.1 Barriers
</h3>
<p class=book>"Barriers" are a form of synchronization most commonly used in parallel decomposition of loops. They're almost never used except in code designed to run only on multiprocessor systems. A barrier is a "meeting place" for a group of associated threads, where each will wait until all have reached the barrier. When the last one waits on the barrier, all the participating threads are released.</p>
<p class=book>See Section 7.1.1 for details of barrier behavior and for an example showing how to implement a barrier using standard Pthreads synchronization. (Note that the behavior of this example is not precisely the same as that proposed by POSIX.1j.)</p>


<a name=t161></a><h3 class=book>
10.2.2 Read/write locks
</h3>
<p class=book>A read/write lock (also sometimes known as "reader/writer lock") allows one thread to exclusively lock some shared data to write or modify that data, but also allows multiple threads to simultaneously lock the data for read access. UNIX98 specifies "read/write locks" very similar to POSIX.1j reader/writer locks. Although X/Open intends that the two specifications will be functionally identical, the names are different to avoid conflict should the POSIX standard change before approval.</p>
<p class=book>If your code relies on a data structure that is frequently referenced, but only occasionally updated, you should consider using a read/write lock rather than a mutex to access that data. Most threads will be able to read the data without waiting; they'll need to block only when some thread is in the process of modifying the data. (Similarly, a thread that desires to write the data will be blocked if any threads are reading the data.)</p>
<p class=book>See Section 7.1.2 for details of read/write lock behavior and for an example showing how to implement a read/write lock using standard Pthreads synchronization. (Note that the behavior of this example is not precisely the same as that proposed by POSIX.1j.)</p>
<p class=book><b>*</b>The POSIX working group is considering the possibility of adapting the XSH5 read/write lock definition and abandoning the original POSIX.1j names, but the decision hasn't yet been made<b>.</b></p>


<a name=t162></a><h3 class=book>
10.2.3 Spinlocks
</h3>
<p class=book>Spinlocks are much like mutexes. There's been a lot of discussion about whether it even makes sense to standardize on a spinlock interface — since POSIX specifies only a source level API, there's very little POSIX.1j says about them that distinguishes them from mutexes. The essential idea is that a spinlock is the most primitive and fastest synchronization mechanism available on a given hardware architecture. On some systems, that may be a single "test and set" instruction — on others, it may be a substantial sequence of "load locked, test, store conditional, memory barrier" instructions.</p>
<p class=book>The critical distinction is that a thread trying to lock a spinlock does not <i>necessarily</i> block when the spinlock is already held by another thread. The intent is that the thread will "spin," retrying the lock rapidly until it succeeds in locking the spinlock. (This is one of the "iffy" spots — on a uniprocessor it had better block, or it'll do nothing but spin out the rest of its timeslice . . . or spin to eternity if it isn't timesliced.)</p>
<p class=book>Spinlocks are great for fine-grained parallelism, when the code is intended to run only on a multiprocessor, carefully tuned to hold the spinlock for only a few instructions, and getting ultimate performance is more important than sharing the system resources cordially with other processes. To be effective, a spinlock must never be locked for as long as it takes to "context switch" from one thread to another. If it does take as long or longer, you'll get better overall performance by blocking and allowing some other thread to do useful work.</p>
<p class=book>POSIX.1j contains two sets of spinlock functions: one set with a spin_ prefix, which allows spinlock synchronization between processes; and the other set with a pthread_ prefix, allowing spinlock synchronization between threads within a process. This, you will notice, is very different from the model used for mutexes, condition variables, and read/write locks, where the same functions were used and the <i>pshared</i> attribute specifies whether the resulting synchronization object can be shared between processes.</p>
<p class=book>The rationale for this is that spinlocks are intended to be very fast, and should not be subject to any possible overhead as a result of needing to decide, at run time, how to behave. It is, in fact, unlikely that the implementation of spin_lock and pthread_spin_lock will differ on most systems, but the standard allows them to be different.</p>


<a name=t163></a><h3 class=book>
10.2.4 Condition variable wait clock
</h3>
<p class=book>Pthreads condition variables support only "absolute time" timeouts. That is, the thread specifies that it is willing to wait until "Jan 1 00:00:00 GMT 2001," rather than being able to specify that it wants to wait for "1 hour, 10 minutes." The reason for this is that a condition variable wait is subject to wakeups for various reasons that are beyond your control or not easy to control. When you wake early from a "1 hour, 10 minute" wait it is difficult to determine how much of that</p>
<p class=book>time is left. But when you wake early from the absolute wait, your target time is still "Jan 1 00:00:00 GMT 2001." (The reasons for early wakeup are discussed in Section 3.3.2.)</p>
<p class=book>Despite all this excellent reasoning, "relative time" waits are useful. One important advantage is that absolute system time is subject to external changes. It might be modified to correct for an inaccurate clock chip, or brought up-to-date with a network time server, or adjusted for any number of other reasons. Both relative time waits and absolute time waits remain correct across that adjustment, but a relative time wait expressed as if it were an absolute time wait cannot. That is, when you want to wait for " 1 hour, 10 minutes," but the best you can do is add that interval to the current clock and wait <i>until</i> that clock time, the system can't adjust the absolute timeout for you when the system time is changed.</p>
<p class=book>POSIX.1j addresses this issue as part of a substantial and pervasive "cleanup" of POSIX time services. The standard (building on top of POSIX. lb, which introduced the realtime clock functions, and the CLOCK_REALTIME clock) introduces a new system clock called CLOCK_MONOTONIC<b>.</b> This new clock isn't a "relative timer" in the traditional sense, but it is never decreased, and it is never modified by date or time changes on the system. It increases at a constant rate. A "relative time" wait is nothing more than taking the current absolute value of the CLOCK_MONOTONIC clock, adding some fixed offset (4200 seconds for a wait of 1 hour and 10 minutes), and waiting until that value of the clock is reached.</p>
<p class=book>This is accomplished by adding the condition variable attribute <i>clock.</i> You set the clock attribute in a thread attributes object using pthread_condattr_setclock and request the current value by calling pthread_condattr_getclock. The default value is CLOCK_MONOTONIC, on the assumption that most condition waits are intervals.</p>
<p class=book>While this assumption may be incorrect, and it may seem to be an incompatible change from Pthreads (and it is, in a way), this was swept under the rug due to the fact that the timed condition wait function suffered from a problem that POSIX.1j found to be extremely common through the existing body of POSIX standards. "Time" in general was only very loosely defined. A timed condition wait, for example, does not say precisely what the timeout argument means. Only that "an error is returned if the absolute time specified by <i>abstime</i> passes (that is, system time equals or exceeds <i>abstime)."</i> The intent is clear — but there are no specific implementation or usage directives. One might reasonably assume that one should acquire the current time using clock_gettime (CLOCK_REALTIME, snow), as suggested in the associated rationale. However, POSIX "rationale" is little more than historical commentary, and is not part of the formal standard. Furthermore, clock_gettime is a part of the optional _POSIX_TIMERS subset of POSIX.1b, and therefore may not exist on many systems supporting threads.</p>
<p class=book>POSIX.1j is attempting to "rationalize" all of these loose ends, at least for systems that implement the eventual POSIX.1j standard. Of course, the CLOCK_MONOTONIC feature is under an option of its own, and additionally relies on the _POSIX_TIMERS</p>
<p class=book>option, so it isn't a cure-all. In the absence of these options, there is no <i>clock</i> attribute, and no way to be sure of relative timeout behavior — or even completely portable behavior.</p>


<a name=t164></a><h3 class=book>
10.2.5 Thread abort
</h3>
<p class=book>The pthread_abort function is essentially fail-safe cancellation. It is used only when you want to be sure the thread will terminate immediately. The dangerous aspect of pthread_abort is that the thread does not run cleanup handlers or have any other opportunity to clean up after itself. That is, if the target thread has a mutex locked, the thread will terminate with the mutex still locked. Because you cannot unlock the mutex from another thread, the application must be prepared to abandon that mutex entirely. Further, it means that any other threads that might be waiting for the abandoned mutex will continue to wait for the mutex forever unless they are also terminated by calling pthread_abort.</p>
<p class=book>In general, real applications cannot recover from aborting a thread, and you should never, ever, use pthread_abort. However, for a certain class of applications this capability is required. Imagine, for example, a realtime embedded control system that cannot shut down and must run reliably across any transient failure in some algorithm. Should a thread encounter a rare boundary condition bug, and hang, the application must recover.</p>
<p class=book>In such a system, all wait operations use timeouts, because realtime response is critical. Should one thread detect that something hasn't happened in a reasonable time, for example, a navigational thread hasn't received sensor input, it will notify an "error manager." If the error manager cannot determine why the thread monitoring the sensor hasn't responded, it will try to recover. It may attempt to cancel the sensor thread to achieve a safe shutdown, but if the sensor thread fails to respond to the cancel in a reasonable time, the application must continue anyway. The error manager would then abort the sensor thread, analyze and correct any data structures it might have corrupted, create and advertise new mutexes if necessary, and create a new sensor thread.</p>



<a name=t165></a><h3 class=book>
10.3 POSIX 1003.14
</h3>
<p class=book>POSIX.14 is a different sort of standard, a "POSIX Standard profile." Unlike Pthreads and POSIX.1j, POSIX. 14 does not add any new capabilities to the POSIX family. Instead, it attempts to provide some order to the maze of options that faces implementors and users of POSIX.</p>
<p class=book>The POSIX.14 specifies which POSIX optional behavior should be considered "required" for multiprocessor hardware systems. It also raises some of the minimum values defined for various POSIX limits. The POSIX.14 working group also</p>
<p class=book>devised recommendations for additional POSIX interfaces based on the substantial multiprocessing and threading experience of the members. Many of the interfaces developed by POSIX. L4 have been included in the POSIX.1j draft standard.</p>
<p class=book>Once POSIX.14 becomes a standard, in theory, producers of POSIX implementations will be able to claim conformance to POSIX.14. And those who wish to develop multithreaded applications may find it convenient to look for POSIX. 14 conformance rather than simply Pthreads conformance. (It remains to be seen whether vendors or users will actually do this, since experience with POSIX Standard Profiles is currently slight.)</p>
<p class=book>The POSIX.14 working group also tried to address important issues such as these:</p>
<p class=book>• Providing a way for threaded code to determine the number of active processors.</p>
<p class=book>• Providing a way for threads to be "bound" onto physical processors.</p>
<p class=book>• Providing a "processor management" command to control which processors are used by the system.</p>
<p class=book>Although these capabilities are universally available in all multiprocessor systems of which the working group was aware, they were dropped from the standard because of many unresolved issues, including these:</p>
<p class=book>• What good does it do to know how many processors there are, if you cannot tell how many your code may use at any time? Remember, the information can change while you are asking for it. What is really needed is a function asking the question "Would the current process benefit from creation of another thread?" We don't know how to answer that question, or how to provide enough information on all reasonable architectures that the application can answer it.</p>
<p class=book>• How can we bind a thread to a processor across a wide range of multiprocessor architecture? On a nonuniform memory access system, for example, representing the processors as a uniform array of integer identifiers would be misleading and useless —- binding one thread to processor 0 and another closely cooperative thread to processor 1 might put them across a relatively slow communications port rather than on two processors sharing a bank of memory.</p>
<p class=book>Eventually, some standards organization (possibly POSIX) will need to address these issues and develop portable interfaces. The folks who attempt this feat may find that they need to limit the scope of the standard to a field narrower than "systems on which people may wish to use threads."</p>



<a name=t166></a><h3 class=book>
Bibliography
</h3>
<p class=book><b>[Anderson, 1991]</b> Thomas E. Anderson, Brian N. Bershad, Edward D. Lazowska, and Henry M. Levy, "Scheduler Activations: Effective Kernel Support for the User-Level Management of Parallelism," <i>Proceedings of the Thirteenth ACM Symposium on Operating Systems Principles,</i> October 1991. Research paper describing the addition of an efficient "two-level scheduler" mechanism for operating systems. This is where all modern two-level scheduler systems started—everyone's read it, everyone references it, and everyone's been inspired by it.</p>
<p class=book><b>[Birrell, 1989]</b> Andrew D. Birrell, <i>An Introduction to Programming with Threads,</i> SRC Research Report 35, Digital Systems Research Center, 130 Lytton Ave., Palo Alto, CA 94301, January 1989. Available on Internet from http:// <a  l:href = "http://www.research.digital.com/src/publications/src-rr.html">www</A>.<a  l:href = "http://www.research.digital.com/src/publications/src-rr.html">research</A>.<a  l:href = "http://www.research.digital.com/src/publications/src-rr.html">digital</A>.<a  l:href = "http://www.research.digital.com/src/publications/src-rr.html">com/SRC/publications/src-rr</A>.<a  l:href = "http://www.research.digital.com/src/publications/src-rr.html">html</A></p>
<p class=book>An introduction to the concepts of threaded programming. Although specifically oriented toward Modula-2+ and SRC's Taos multithreaded operating system, many essential concepts remain easily recognizable in Pthreads.</p>
<p class=book><b>[Boykin, 1993]</b> Joseph Boykin, David Kirschen, Alan Langerman, and J Susan LoVerso, <i>Programming under Mach,</i> Addison-Wesley, Reading, MA, ISBN 0-201-52739-1, 1993.</p>
<p class=book><b>[Custer, 1993]</b> Helen Custer, <i>Inside Windows NT,</i> Microsoft Press, ISBN 1-55615-481-X, 1993.</p>
<p class=book><b>[Digital, 1996]</b> Digital Equipment Corporation, <i>Guide to DECthreads,</i> Digital Equipment Corporation, part number AA-Q2DPC-TK, 1996.</p>
<p class=book>Reference manual for Digital's DECthreads implementation of the Pthreads standard. An appendix (which will be removed after the Digital UNIX 4.0 and OpenVMS 7.0 versions) provides reference information on the obsolete cma and DCE threads (POSIX 1003.4a draft 4) interfaces.</p>
<p class=book><b>[Dijkstra, 1965]</b> E. W. Dijkstra, "Solution of a Problem in Concurrent Programming Control," <i>Communications of the ACM,</i> Vol. 8 (9), September 1965, pp. 569-570.</p>
<p class=book><b>[Dijkstra, 1968a]</b> E. W. Dijkstra, "Cooperating Sequential Processes," <i>Programming Languages,</i> edited by F. Genuys, Academic Press, New York, 1968, pp. 43-112.</p>
<p class=book><b>[Dijkstra, 1968b]</b> E. W. Dijkstra, 'The Structure of the THE'—Multiprogramming System," <i>Communications oftheACM,</i> Vol. 11 (5), 1968, pp. 341-346.</p>
<p class=book><b>[Gallmeister, 1995]</b> BiLl O. Gallmeister, <i>POSIX.4: Programming for the Real World,</i> O'Reilly, Sebastopol, CA, ISBN 1-56592-074-0, 1995.</p>
<p class=book>POSIX 1003.1b-1993 realtime programming (based on a near-final draft of the standard).</p>
<p class=book><b>[Hoare, 1974]</b> C.A.R. Hoare, "Monitors: An Operating System Structuring Concept," <i>Communications of the ACM,</i> Vol. 17 (10), 1974, pp. 549-557.</p>
<p class=book><b>[IEEE, 1996]</b> <i>9945-1:1996 (ISO/IEC) [IEEE/ANSI Std 1003.1 1996Edition]Information Technology—Portable Operating System Interface (POSIX)—Part 1: System Applwation: Program Interface (API) [C Language] (ANSI),</i> IEEE Stan-dardsPress. ISBN 1-55937-573-6, 1996.</p>
<p class=book>The POSIX C Language interfaces, including realtime and threads.</p>
<p class=book><b>[Jones, 1991]</b> Michael B. Jones, "Bringing the C Libraries With Us into a Multi-Threaded Future," <i>Winter 1991 Usenix Conference Proceedings,</i> Dallas, TX, January 1991, pp. 81-91.</p>
<p class=book><b>[Kleiman, 1996]</b> Steve KIeiman, Devang Shah, and Bart Smaalders, <i>Programming with Threads,</i> Prentice Hall, Englewood Cliffs, NJ, ISBN 0-13-172389-8, 1996.</p>
<p class=book>This book shares some characteristics with the book you are holding. Both, for example, involve authors who were directly involved in the POSIX standard working group, and were also principal architects of their respective companies' thread implementations.</p>
<p class=book><b>[Lea, 1997]</b> Doug Lea, <i>Concurrent Programming in Java™,</i> Addison-Wesley, Reading, MA, ISBN 0-201-69581-2, 1997.</p>
<p class=book>A different view of threads, from the perspective of the Java™ language, which provides unique constructs for thread synchronization within the language.</p>
<p class=book><b>[Lewis, 1995]</b> Bil Lewis and Daniel J. Berg, <i>Threads Primer,</i> SunSoft Press, ISBN 0-13-443698-9, 1995.</p>
<p class=book>A good introduction to threaded programming for the novice. The first edition primarily deals with Solaris "UI threads," with some information on POSIX threads.</p>
<p class=book><b>[Lockhart, 1994]</b> Harold W. Lockhart, Jr., <i>OSFDCE, Guide toDevelopingDistrib-utedApplications,</i> McGraw-Hill, NewYork, ISBN0-07-911481-4, 1994.</p>
<p class=book>A chapter on DCE threads describes how to use threads in building DCE applications.</p>
<p class=book><b>[McJones, 1989]</b> Paul F. McJones and Garret F. Swart, "Evolving the UNIX System Interface to Support Multithreaded Programs," SRC Research Report 21, Digital Systems Research Center, 130 Lytton Ave., Palo Alto, CA 94301, September 1989. Available on Internet from <a  l:href = "http://www.research.digital.com/">http:</A>//<a  l:href = "http://www.research.digital.com/">www</A>.<a  l:href = "http://www.research.digital.com/">research</A>.<a  l:href = "http://www.research.digital.com/">digital</A>.<a  l:href = "http://www.research.digital.com/">com/</A> SRC / publications / src -rr. html</p>
<p class=book>Report on adaptation of UNIX system for multithreaded programming.</p>
<p class=book><b>[Schimmel, 1994]</b> CurtSchimmel, <i>UNIX Systems for Modern Architectures,</i> Addison-Wesley, Reading, MA, ISBN 0-201-63338-8, 1994.</p>
<p class=book>Substantial detail on the implementation of multiprocessors and shared memory systems. If Section 3.4 in the book you're holding doesn't satisfy your thirst for knowledge, this is where you should go.</p>


<a name=t167></a><h3 class=book>
Thread resources on the Internet
</h3>
<blockquote class="epigraph">
<p class=book>In the midst of the word he was trying to say,</p>
<p class=book>In the midst of his laughter and glee,</p>
<p class=book>He had softly and suddenly vanished away—</p>
<p class=book>For the Snark was a Boojum, you see.</p>
<p class=book>THE END</p>
<blockquote class=book><i>— <i>Lewis Carroll, The Hunting of the Snark</i></i></blockquote>
</blockquote>

<p class=book>This list provides a few starting points for information. Of course, the web changes all the time, so no list committed to paper will ever be completely correct. That's life in the information age.</p>


<a name=t168></a><h3 class=book>
Newsgroups
</h3>
<p class=book><b>comp.programming.threads</b></p>
<p class=book>General, unmoderated discussion of anything related to threads. This group is frequented by a number of people highly knowledgeable about threads in general, and about various specific implementations of Pthreads. It's a nice, friendly place to ask about problems you're having, or things you would like to do. Please, don't ask about screensavers! And, if you want to ask about a problem, always remember to tell us what type of hardware and operating system you're using and include the version.</p>
<p class=book><b>comp.unix.osf.osfl</b></p>
<p class=book>The primary discussion group for the Digital UNIX operating system. There are, of course, historical reasons for the nonintuitive name. This is a reasonable place to ask questions about using threads on Digital UNIX. If the question (or problem) doesn't seem to be specific to Digital UNIX, comp.programming.threads may be more appropriate, because it presents your question to a larger audience of thread experts, and makes the answer available to a larger audience of thread users.</p>
<p class=book><b>comp.unix.solaris</b></p>
<p class=book>The primary discussion group for the Solaris operating system. This is a reasonable place to ask questions about using threads on Solaris. If the question (or problem) doesn't seem to be specific to Solaris, comp.programming.threads may</p>
<p class=book>be more appropriate, because it presents your question to a larger audience of thread experts, and makes the answer available to a larger audience of thread users.</p>


<a name=t169></a><h3 class=book>
Web sites
</h3>
<p class=book><i>http:<b>//</b>altavista<b>.</b>digital<b>.</b>com/</i></p>
<p class=book>Altavista is a multithreaded web search engine developed by Digital Equipment Corporation. It is also an excellent search engine that you can use to find out about nearly anything. Always a good place to start.</p>
<p class=book><i>http:<b>//</b>www<b>.</b>aw<b>.</b>com/cp/butenhof/posix<b>.</b>html</i></p>
<p class=book>The Addison-Wesley web page containing information about this book, including the source for all the example programs.</p>
<p class=book><i>http://www.best.com/-bos/threads-faq/</i></p>
<p class=book>This page is a list of frequently asked questions (FAQ) from the comp.programming.threads newsgroup. Please read this before you read comp.programming. threads, in order to avoid asking a wide range of questions that have been asked a million times before. The information in this page is also posted to the newsgroup at regular intervals.</p>
<p class=book><i>http://liinwww.ira.uka.de/bibliography/Os/threads.html</i></p>
<p class=book>A searchable bibliography of terms related to threading, maintained by the University of Oslo in Norway.</p>
<p class=book><i>http://www.digital.com/</i></p>
<p class=book>Digital Equipment Corporation web site. This site includes a lot of information on the Digital UNIX and OpenVMS operating systems, including information on threads and multiprocessor systems.</p>
<p class=book><i>http:<b>//</b>www<b>.</b>sun<b>.</b>com/</i></p>
<p class=book>Sun Microsystems, Inc., web site. This site includes, as you might guess, a lot of information on the Solaris operating system. You can also find information about the Java language, which provides an interesting variant of thread support by making thread synchronization an explicit attribute of a class method.</p>
<p class=book><i>http:<b>//</b>www<b>.</b>sgi<b>.</b>com/</i></p>
<p class=book>Silicon Graphics, Inc., web site. Information on SGI systems and the IRIX operating system.</p>
<p class=book><i>http://www.netcom.com/-brownell/pthreads++.html</i></p>
<p class=book>Information on an attempt to "define a standardized approach to the use of threading in the C++ language."</p>



<a name=t170></a><h3 class=book>

</h3>
<br>


<h3 class=book>
Notes
</h3>
<a name="n1"></a>
<h3 class=book>
1
</h3>
<p class=book>A barrier is a simple synchronization mechanism that blocks each thread until a certain number has reached the barrier; then all threads are unblocked. Barriers can be used, for example, to keep any thread from executing a parallel region of code until all threads are ready to execute the region. Section 7.1.1 describes barriers in more detail, and demonstrates the construction of a simple barrier package.</p>
 <small>(<a href=#r1>обратно</a>)</small>
<a name="n2"></a>
<h3 class=book>
2
</h3>
<p class=book>UNIX systems support "nonblocking I/O," but this is not the same thing as asynchronous I/O. Nonblocking I/O allows the program to defer issuing an I/O operation until it can complete without blocking, but asynchronous I/O can proceed while the program does something else.</p>
 <small>(<a href=#r2>обратно</a>)</small>
<a name="n3"></a>
<h3 class=book>
3
</h3>
<p class=book>Contact the IEEE at l-800-678-IEEE. <i>9945-l:1996InfonnatiDnTechnology-PortabteOpera-ting System Interface (POSIX)—Part 1: System Application: Program Interface (API) [C Language], ISBN 1-55937-573-6, order number SH94352</i>.</p>
 <small>(<a href=#r3>обратно</a>)</small>
<a name="n4"></a>
<h3 class=book>
4
</h3>
<p class=book>That is, unfortunately, not what the standard says. This is one of the problems with formal standards — they say what they say, not what they were intended to say. Somehow, an error crept ln, and the sentence specifying that "the implementation clears the thread-specific data value before calling the destructor" was deleted. Nobody noticed, and the standard was approved with the error. So the standard says (by omission) that if you want to write a portable application using thread-speciflc data, that will not hang on thread termination, you must call pthread_setspecific within your destructor function to change the value to NULL. This would be silly, and any serious implementation of Pthreads will violate the standard in this respect. Of course, the standard will be fixed, probably by the 1003. ln amendment (assorted corrections to 1003. 1c-1995). but that will take a while.</p>
 <small>(<a href=#r4>обратно</a>)</small>
<a name="n5"></a>
<h3 class=book>
5
</h3>
<p class=book>The DCE threads user-mode scheduler can usually be ported to new operating systems in a few days, involving primarily new assembly language for the register context switching routines. We use the motto "Some Assembly Required."</p>
 <small>(<a href=#r5>обратно</a>)</small>
<a name="n6"></a>
<h3 class=book>
6
</h3>
<p class=book>The algorithm (and most of the code) for susp.c was developed by a coworker of mine, Brian Silver. The code shown here is a simplified version for demonstration purposes.</p>
 <small>(<a href=#r6>обратно</a>)</small>
<a name="n7"></a>
<h3 class=book>
7
</h3>
<p class=book>I always like to define magic numbers using hexadecimal constants that can be pronounced as English words. For barriers, I invented my own restaurant called the "DB cafe," or, in C syntax, Oxdbcafe. Many interesting (or at least mildly amusing) English words can be spelled using only the letters <i><b>a</b></i> through <i><b>f</b></i><b>.</b> There are even more possibilities if you allow the digit 1 to stand in for the letter 1. and the digit 0 to stand in for the letter o. (Whether you like the results will depend a lot on the typeface in which you commonly read your code.)</p>
 <small>(<a href=#r7>обратно</a>)</small>
<a name="n8"></a>
<h3 class=book>
8
</h3>
<p class=book>For historical reasons, the function is called cma_debug. Should you find yourself stuck with DCE threads code, try calling it, and enter the help command for a list of additional commands.</p>
 <small>(<a href=#r8>обратно</a>)</small>
<a name="n9"></a>
<h3 class=book>
9
</h3>
<p class=book>My daughter had this figured out by the time she was three — when she wanted to race, she told me ahead of time whether my job was to win or lose. There's really no point to leaving these important things to chance!</p>
 <small>(<a href=#r9>обратно</a>)</small>
<a name="n10"></a>
<h3 class=book>
10
</h3>
<p class=book> Digital UNIX and Solaris both (incorrectly) place the definition in &lt;pthread.h&gt;. The UNIX 98 brand will require that they be fixed.</p>
 <small>(<a href=#r10>обратно</a>)</small>
<a name="n11"></a>
<h3 class=book>
11
</h3>
<p class=book> DCE threads implemented <i>fast</i> mutexes much like the definition of XSH5 <i>normal</i> mutexes, with no error checking. This was not, however, specification of intent.</p>
 <small>(<a href=#r11>обратно</a>)</small>
<br><h3>Оглавление</h3><li><a href=#t1>
Addison-Wesley Professional Computing Series
</a><li><a href=#t2>
Quote acknowledgments:
</a><li><a href=#t3>
Preface
</a><li> &nbsp; <a href=#t4>
Intended audience
</a><li> &nbsp; <a href=#t5>
About the author
</a><li> &nbsp; <a href=#t6>
Acknowledgments
</a><li><a href=#t7>
1 Introduction
</a><li> &nbsp; <a href=#t8>
1.1 The "bailing programmers"
</a><li> &nbsp; <a href=#t9>
1.2 Definitions and terminology
</a><li> &nbsp;  &nbsp; <a href=#t10>
1.2.1 Asynchronous
</a><li> &nbsp;  &nbsp; <a href=#t11>
1.2.2 Concurrency
</a><li> &nbsp;  &nbsp; <a href=#t12>
1.2.3 Uniprocessor and multiprocessor
</a><li> &nbsp;  &nbsp; <a href=#t13>
1.2.4 Parallelism
</a><li> &nbsp;  &nbsp; <a href=#t14>
1.2.5 Thread safety and reentrancy
</a><li> &nbsp;  &nbsp; <a href=#t15>
1.2.6 Concurrency control functions
</a><li> &nbsp; <a href=#t16>
1.3 Asynchronous programming is intuitive ...
</a><li> &nbsp;  &nbsp; <a href=#t17>
1.3.1 ... because UNIX is asynchronous
</a><li> &nbsp;  &nbsp; <a href=#t18>
1.3.2 ... because the world is asynchronous
</a><li> &nbsp; <a href=#t19>
1.4 About the examples in this book
</a><li> &nbsp; <a href=#t20>
1.5 Asynchronous programming, by example
</a><li> &nbsp;  &nbsp; <a href=#t21>
1.5.1 The baseline, synchronous version
</a><li> &nbsp;  &nbsp; <a href=#t22>
1.5.2 A version using multiple processes
</a><li> &nbsp;  &nbsp; <a href=#t23>
1.5.3 A version using multiple threads
</a><li> &nbsp;  &nbsp; <a href=#t24>
1.5.4 Summary
</a><li> &nbsp; <a href=#t25>
1.6 Benefits of threading
</a><li> &nbsp;  &nbsp; <a href=#t26>
1.6.1 Parallelism
</a><li> &nbsp;  &nbsp; <a href=#t27>
1.6.2 Concurrency
</a><li> &nbsp;  &nbsp; <a href=#t28>
1.6.3 Programming model
</a><li> &nbsp; <a href=#t29>
1.7 Costs of threading
</a><li> &nbsp;  &nbsp; <a href=#t30>
1.7.1 Computing overhead
</a><li> &nbsp;  &nbsp; <a href=#t31>
1.7.2 Programming discipline
</a><li> &nbsp;  &nbsp; <a href=#t32>
1.7.3 Harder to debug
</a><li> &nbsp; <a href=#t33>
1.8 To thread or not to thread?
</a><li> &nbsp; <a href=#t34>
1.9 POSIX thread concepts
</a><li> &nbsp;  &nbsp; <a href=#t35>
1.9.1 Architectural overview
</a><li> &nbsp;  &nbsp; <a href=#t36>
1.9.2 Types and interfaces
</a><li> &nbsp;  &nbsp; <a href=#t37>
1.9.3 Checking for errors
</a><li><a href=#t38>
2 Threads
</a><li> &nbsp; <a href=#t39>
2.1 Creating and using threads
</a><li> &nbsp; <a href=#t40>
2.2 The life of a thread
</a><li> &nbsp;  &nbsp; <a href=#t41>
2.2.1 Creation
</a><li> &nbsp;  &nbsp; <a href=#t42>
2.2.2 Startup
</a><li> &nbsp;  &nbsp; <a href=#t43>
2.2.3 Running and blocking
</a><li> &nbsp;  &nbsp; <a href=#t44>
2.2.4 Termination
</a><li> &nbsp;  &nbsp; <a href=#t45>
2.2.5 Recycling
</a><li><a href=#t46>
3 Synchronization
</a><li> &nbsp; <a href=#t47>
3.1 Invariants, critical sections,and predicates
</a><li> &nbsp; <a href=#t48>
3.2 Mutexes
</a><li> &nbsp;  &nbsp; <a href=#t49>
3.2.1 Creating and destroying a mutex
</a><li> &nbsp;  &nbsp; <a href=#t50>
3.2.2 Locking and unlocking a mutex
</a><li> &nbsp;  &nbsp;  &nbsp; <a href=#t51>
3.2.2.1 Nonblocking mutex locks
</a><li> &nbsp;  &nbsp; <a href=#t52>
3.2.3 Using mutexes for atomicity
</a><li> &nbsp;  &nbsp; <a href=#t53>
3.2.4 Sizing a mutex to fit the job
</a><li> &nbsp;  &nbsp; <a href=#t54>
3.2.5 Using more than one mutex
</a><li> &nbsp;  &nbsp;  &nbsp; <a href=#t55>
3.2.5.1 Lock hierarchy
</a><li> &nbsp;  &nbsp;  &nbsp; <a href=#t56>
3.2.5.2 Lock chaining
</a><li> &nbsp; <a href=#t57>
3.3 Condition variables
</a><li> &nbsp;  &nbsp; <a href=#t58>
3.3.1 Creating and destroying a condition variable
</a><li> &nbsp;  &nbsp; <a href=#t59>
3.3.2 Waiting on a condition variable
</a><li> &nbsp;  &nbsp; <a href=#t60>
3.3.3 Waking condition variable waiters
</a><li> &nbsp;  &nbsp; <a href=#t61>
3.3.4 One final alarm program
</a><li> &nbsp; <a href=#t62>
3.4 Memory visibility between threads
</a><li><a href=#t63>
4 A few ways to use threads
</a><li> &nbsp; <a href=#t64>
4.1 Pipeline
</a><li> &nbsp; <a href=#t65>
4.2 Work crew
</a><li> &nbsp; <a href=#t66>
4.3 Client/Server
</a><li><a href=#t67>
5 Advanced threaded programming
</a><li> &nbsp; <a href=#t68>
5.1 One-time initialization
</a><li> &nbsp; <a href=#t69>
5.2 Attributes objects
</a><li> &nbsp;  &nbsp; <a href=#t70>
5.2.1 Mutex attributes
</a><li> &nbsp;  &nbsp; <a href=#t71>
5.2.2 Condition variable attributes
</a><li> &nbsp;  &nbsp; <a href=#t72>
5.2.3 Thread attributes
</a><li> &nbsp; <a href=#t73>
5.3 Cancellation
</a><li> &nbsp;  &nbsp; <a href=#t74>
5.3.1 Deferred cancelability
</a><li> &nbsp;  &nbsp; <a href=#t75>
5.3.2 Asynchronous cancelability
</a><li> &nbsp;  &nbsp; <a href=#t76>
5.3.3 Cleaning up
</a><li> &nbsp; <a href=#t77>
5.4 Thread-specific data
</a><li> &nbsp;  &nbsp; <a href=#t78>
5.4.1 Creating thread-specific data
</a><li> &nbsp;  &nbsp; <a href=#t79>
5.4.2 Using thread-specific data
</a><li> &nbsp;  &nbsp; <a href=#t80>
5.4.3 Using destructor functions
</a><li> &nbsp; <a href=#t81>
5.5 Realtime scheduling
</a><li> &nbsp;  &nbsp; <a href=#t82>
5.5.1 POSIX realtime options
</a><li> &nbsp;  &nbsp; <a href=#t83>
5.5.2 Scheduling policies and priorities
</a><li> &nbsp;  &nbsp; <a href=#t84>
5.5.3 Contention scope and allocation domain
</a><li> &nbsp;  &nbsp; <a href=#t85>
5.5.4 Problems  with realtime scheduling
</a><li> &nbsp;  &nbsp; <a href=#t86>
5.5.5 Priority-aware mutexes
</a><li> &nbsp;  &nbsp;  &nbsp; <a href=#t87>
5.5.5.1 Priority ceiling mutexes
</a><li> &nbsp;  &nbsp;  &nbsp; <a href=#t88>
5.5.5.2 Priority inheritance mutexes
</a><li> &nbsp; <a href=#t89>
5.6 Threads and kernel entities
</a><li> &nbsp;  &nbsp; <a href=#t90>
5.6.1 Many-to-one (user level)
</a><li> &nbsp;  &nbsp; <a href=#t91>
5.6.2 One-to-one (kernel level)
</a><li> &nbsp;  &nbsp; <a href=#t92>
5.6.3 Many-to-few (two level)
</a><li><a href=#t93>
6 POSIX adjusts to threads
</a><li> &nbsp; <a href=#t94>
6.1 fork
</a><li> &nbsp;  &nbsp; <a href=#t95>
6.1.1 Fork handlers
</a><li> &nbsp; <a href=#t96>
6.2 exec
</a><li> &nbsp; <a href=#t97>
6.3 Process exit
</a><li> &nbsp; <a href=#t98>
6.4 Stdio
</a><li> &nbsp;  &nbsp; <a href=#t99>
6.4.1 flockfile and funlockfile
</a><li> &nbsp;  &nbsp; <a href=#t100>
6.4.2 getchar unlocked and putchar unlocked
</a><li> &nbsp; <a href=#t101>
6.5 Thread-safe functions
</a><li> &nbsp;  &nbsp; <a href=#t102>
6.5.1 User and terminal identification
</a><li> &nbsp;  &nbsp; <a href=#t103>
6.5.2 Directory searching
</a><li> &nbsp;  &nbsp; <a href=#t104>
6.5.3 String token
</a><li> &nbsp;  &nbsp; <a href=#t105>
6.5.4 Time representation
</a><li> &nbsp;  &nbsp; <a href=#t106>
6.5.5 Random number generation
</a><li> &nbsp;  &nbsp; <a href=#t107>
6.5.6 Group and user database
</a><li> &nbsp; <a href=#t108>
6.6 Signals
</a><li> &nbsp;  &nbsp; <a href=#t109>
6.6.2 Signal masks
</a><li> &nbsp;  &nbsp; <a href=#t110>
6.6.3 pthread_kill
</a><li> &nbsp;  &nbsp; <a href=#t111>
6.6.4 sigwait and sigwaitinfo
</a><li> &nbsp;  &nbsp; <a href=#t112>
6.6.5 SIGEV_THREAD
</a><li> &nbsp;  &nbsp; <a href=#t113>
6.6.6 Semaphores: synchronizing with a signal-catching function
</a><li><a href=#t114>
7 "Real code"
</a><li> &nbsp; <a href=#t115>
7.1 Extended synchronization
</a><li> &nbsp;  &nbsp; <a href=#t116>
7.1.1 Barriers
</a><li> &nbsp;  &nbsp; <a href=#t117>
7.1.2 Read/write locks
</a><li> &nbsp; <a href=#t118>
7.2 Work queue manager
</a><li> &nbsp; <a href=#t119>
7.3 But what about existing libraries?
</a><li> &nbsp;  &nbsp; <a href=#t120>
7.3.1 Modifying libraries to be thread-safe
</a><li> &nbsp;  &nbsp; <a href=#t121>
7.3.2 Living with legacy libraries
</a><li><a href=#t122>
8 Hints to avoid debugging
</a><li> &nbsp; <a href=#t123>
8.1 Avoiding incorrect code
</a><li> &nbsp;  &nbsp; <a href=#t124>
8.1.1 Avoid relying on "thread inertia"
</a><li> &nbsp;  &nbsp; <a href=#t125>
8.1.2 Never bet your mortgage on a thread race
</a><li> &nbsp;  &nbsp; <a href=#t126>
8.1.3 Cooperate to avoid deadlocks
</a><li> &nbsp;  &nbsp; <a href=#t127>
8.1.4 Beware of priority inversion
</a><li> &nbsp;  &nbsp; <a href=#t128>
8.1.5 Never share condition variables between predicates
</a><li> &nbsp;  &nbsp; <a href=#t129>
8.1.6 Sharing stacks and related memory corrupters
</a><li> &nbsp; <a href=#t130>
8.2 Avoiding performance problems
</a><li> &nbsp;  &nbsp; <a href=#t131>
8.2.1 Beware of concurrent serialization
</a><li> &nbsp;  &nbsp; <a href=#t132>
8.2.2 Use the right number of mutexes
</a><li> &nbsp;  &nbsp;  &nbsp; <a href=#t133>
8.2.2.1 Too many mutexes will not help
</a><li> &nbsp;  &nbsp; <a href=#t134>
8.2.3 Never fight over cache lines
</a><li><a href=#t135>
9 POSIX threads mini-reference
</a><li> &nbsp; <a href=#t136>
9.1 POSIX1003.1c-1995 options
</a><li> &nbsp; <a href=#t137>
9.2 POSIX1003.1c-1995 limits
</a><li> &nbsp; <a href=#t138>
9.3 POSIX1003.1c-1995 interfaces
</a><li> &nbsp;  &nbsp; <a href=#t139>
9.3.1 Error detection and reporting
</a><li> &nbsp;  &nbsp; <a href=#t140>
9.3.2 Use of void* type
</a><li> &nbsp;  &nbsp; <a href=#t141>
9.3.3 Threads
</a><li> &nbsp;  &nbsp; <a href=#t142>
9.3.4 Mutexes
</a><li> &nbsp;  &nbsp; <a href=#t143>
9.3.5 Condition variables
</a><li> &nbsp;  &nbsp; <a href=#t144>
9.3.6 Cancellation
</a><li> &nbsp;  &nbsp; <a href=#t145>
9.3.7 Thread-specific data
</a><li> &nbsp;  &nbsp; <a href=#t146>
9.3.8 Realtime scheduling
</a><li> &nbsp;  &nbsp; <a href=#t147>
9.3.9 Fork handlers
</a><li> &nbsp;  &nbsp; <a href=#t148>
9.3.10 Stdio
</a><li> &nbsp;  &nbsp; <a href=#t149>
9.3.11 Thread-safe functions
</a><li> &nbsp;  &nbsp; <a href=#t150>
9.3.12 Signals
</a><li> &nbsp;  &nbsp; <a href=#t151>
9.3.13 Semaphores
</a><li><a href=#t152>
10 Future standardization
</a><li> &nbsp; <a href=#t153>
10.1 X/OpenXSH5(UNIX98)
</a><li> &nbsp;  &nbsp; <a href=#t154>
10.1.1 POSIX options for XSH5
</a><li> &nbsp;  &nbsp; <a href=#t155>
10.1.2 Mutex type
</a><li> &nbsp;  &nbsp; <a href=#t156>
10.1.3 Set concurrency level
</a><li> &nbsp;  &nbsp; <a href=#t157>
10.1.4 Stack guard size
</a><li> &nbsp;  &nbsp; <a href=#t158>
10.1.5 Parallel I/O
</a><li> &nbsp;  &nbsp; <a href=#t159>
10.1.6 Cancellation points
</a><li> &nbsp;  &nbsp; <a href=#t160>
10.2.1 Barriers
</a><li> &nbsp;  &nbsp; <a href=#t161>
10.2.2 Read/write locks
</a><li> &nbsp;  &nbsp; <a href=#t162>
10.2.3 Spinlocks
</a><li> &nbsp;  &nbsp; <a href=#t163>
10.2.4 Condition variable wait clock
</a><li> &nbsp;  &nbsp; <a href=#t164>
10.2.5 Thread abort
</a><li> &nbsp; <a href=#t165>
10.3 POSIX 1003.14
</a><li><a href=#t166>
Bibliography
</a><li><a href=#t167>
Thread resources on the Internet
</a><li> &nbsp; <a href=#t168>
Newsgroups
</a><li> &nbsp; <a href=#t169>
Web sites
</a><li><a href=#t170>

</a>
<hr><div align=right>Взято из Флибусты, <a href=http://flibusta.net/b/235412>flibusta.net</a></div>
</body></html>